<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jingsam</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jingsam.github.io/"/>
  <updated>2018-03-02T09:36:07.778Z</updated>
  <id>https://jingsam.github.io/</id>
  
  <author>
    <name>jingsam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用pkg打包Node.js应用</title>
    <link href="https://jingsam.github.io/2018/03/02/pkg.html"/>
    <id>https://jingsam.github.io/2018/03/02/pkg.html</id>
    <published>2018-03-02T03:23:39.000Z</published>
    <updated>2018-03-02T09:36:07.778Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js应用不需要经过编译过程，可以直接把源代码拷贝到部署机上执行，确实比C++、Java这类编译型应用部署方便。然而，Node.js应用执行需要有运行环境，意味着你需要先在部署机器上安装Node.js。虽说没有麻烦到哪里去，但毕竟多了一个步骤，特别是对于离线环境下的部署机，麻烦程度还要上升一级。假设你用Node.js写一些小的桌面级工具软件，部署到客户机上还要先安装Node.js，有点“大炮打蚊子”的感觉。更严重的是，如果部署机器上游多个Node.js应用，而且这些应用要依赖于不同的Node.js版本，那就更难部署了。</p>
<p>理想的情况是将Node.js打包为一个单独的可执行文件，部署的时候直接拷贝过去就行了。除了部署方便外，因为不需要再拷贝源代码了，还有利于保护知识产权。</p>
<p>将Node.js打包为可执行文件的工具有pkg、nexe、node-packer、enclose等，从打包速度、使用便捷程度、功能完整性来说，pkg是最优秀的。这篇文章就来讲一讲半年来我使用pkg打包Node.js应用的一些经验。</p>
<p>pkg的打包原理简单来说，就是将js代码以及相关的资源文件打包到可执行文件中，然后劫持<code>fs</code>里面的一些函数，使它能够读到可执行文件中的代码和资源文件。例如，原来的<code>require(&#39;./a.js&#39;)</code>会被劫持到一个虚拟目录<code>require(&#39;/snapshot/a.js&#39;)</code>。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>pkg既可以全局安装也可以局部安装，推荐采用局部安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install pkg --save-dev</div></pre></td></tr></table></figure>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>pkg使用比较简单，执行下<code>pkg -h</code>就可以基本了解用法，基本语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkg [options] &lt;input&gt;</div></pre></td></tr></table></figure>
<p><code>&lt;input&gt;</code>可以通过三种方式指定：</p>
<p>1.一个脚本文件，例如<code>pkg index.js</code>;<br>2.<code>package.json</code>，例如<code>pkg package.json</code>，这时会使用<code>package.json</code>中的<code>bin</code>字段作为入口文件；<br>3.一个目录，例如<code>pkg .</code>，这时会寻找指定目录下的<code>package.json</code>文件，然后在找<code>bin</code>字段作为入口文件。</p>
<p><code>[options]</code>中可以指定打包的参数：<br>1.<code>-t</code>指定打包的目标平台和Node版本，如<code>-t node6-win-x64,node6-linux-x64,node6-macos-x64</code>可以同时打包3个平台的可执行程序；<br>2.<code>-o</code>指定输出可执行文件的名称，但如果用<code>-t</code>指定了多个目标，那么就要用<code>--out-path</code>指定输出的目录；<br>3.<code>-c</code>指定一个JSON配置文件，用来指定需要额外打包脚本和资源文件，通常使用<code>package.json</code>配置。</p>
<p>使用pkg的最佳实践是：在<code>package.json</code>中的<code>pkg</code>字段中指定打包参数，使用<code>npm scripts</code>来执行打包过程，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  &quot;bin&quot;: &quot;./bin/www&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;pkg&quot;: &quot;pkg . --out-path=dist/&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;pkg&quot;: &#123;</div><div class="line">    &quot;scripts&quot;: [...]</div><div class="line">    &quot;assets&quot;: [...],</div><div class="line">    &quot;targets&quot;: [...]</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>scripts</code>和<code>assets</code>用来配置未打包进可执行文件的脚本和资源文件，文件路径可以使用glob通配符。这里就浮现出一个问题：为什么有的脚本和资源文件打包不进去呢？</p>
<p>要回答这个问题，就涉及到pkg打包文件的机制。按照pkg文档的说法，pkg只会自动地打包相对于<code>__dirname</code>、<code>__filename</code>的文件，例如<code>path.join(__dirname, &#39;../path/to/asset&#39;)</code>。至于<code>require()</code>，因为require本身就是相对于<code>__dirname</code>的，所以能够自动打包。假设文件中有以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">require(&apos;./build/&apos; + cmd + &apos;.js&apos;)</div><div class="line">path.join(__dirname, &apos;views/&apos; + viewName)</div></pre></td></tr></table></figure>
<p>这些路径都不是常量，pkg没办法帮你自动识别要打包哪个文件，所以文件就丢失了，所以这时候就使用<code>scripts</code>和<code>assets</code>来告诉pkg，这些文件要打包进去。那么我们怎么知道哪些文件没有被打包呢？难倒要一行行地去翻源代码吗？其实很简单，只需要把打包好的文件运行下，报错信息一般就会告诉你缺失哪些文件，并且pkg在打包过程中也会提示一些它不能自动打包的文件。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>如果说pkg还有哪儿还可以改进的地方，那就是无法自动打包二进制模块<code>*.node</code>文件。如果你的项目中引用了二进制模块，如sqlite3，那么你需要手动地将<code>*.node</code>文件复制到可执行文件同一目录，我通常使用命令<code>cp node_modules/**/*.node .</code>一键完成。但是，如果你要跨平台打包，例如在windows上打包linux版本，相应的二进制模块也要换成linux版本，通常需要你手动的下载或者编译。</p>
<p>那为什么pkg不能将二进制模块打包进去呢？我猜想是require载入一个js文件和node文件，它们的机制是不一样的。另外从设计来说，不自动打包二进制模块也是合理的，因为二进制模块都是平台相关的。如果我在windows上生成一个linux文件，那么就需要拉取linux版本的<code>.node</code>文件，这是比较困难的。并且有些二进制模块不提供预编译版本，需要安装的时候编译，pkg再牛也不可能模拟一个其他平台的编译环境吧。nexe可以自动打包二进制模块，但是只能打包当前平台和当前版本的可执行文件。这意味着如果Node.js应用引用了二进制包，那么这个应用就不能跨平台打包了，所以我认为这方面，nexe不能算是一个好的设计。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js应用不需要经过编译过程，可以直接把源代码拷贝到部署机上执行，确实比C++、Java这类编译型应用部署方便。然而，Node.js应用执行需要有运行环境，意味着你需要先在部署机器上安装Node.js。虽说没有麻烦到哪里去，但毕竟多了一个步骤，特别是对于离线环境下的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《ThinkPad之道》书评</title>
    <link href="https://jingsam.github.io/2018/02/27/thinkpad.html"/>
    <id>https://jingsam.github.io/2018/02/27/thinkpad.html</id>
    <published>2018-02-27T03:27:47.000Z</published>
    <updated>2018-02-27T08:46:47.770Z</updated>
    
    <content type="html"><![CDATA[<p>最近在西西弗书店断断续续地读完了《ThinkPad之道》这本书，本书讲的是“Thinkpad之父”内藤在正和他所领导的大和实验室，在研发ThinkPad系列笔记本电脑的过程所面临的种种困难和压力，最终成就了一款经典产品。</p>
<p>本人大学期间拆装过无数笔记本电脑，自认为笔记本电脑没什么技术含量，无非就是几个零件组装起来。记得有一次拆装一个ThinkPad电脑，每次复原后总是会多出来几个螺丝，神奇的是每次电脑都能正常开机。心中不免有些疑惑，明明可以用更少的螺丝，为什么还要用那么多螺丝呢？看了这本书之后，明白了这些多余的螺丝，是为了保证ThinkPad在任何环境下都能正常使用。</p>
<p>ThinkPad起初是给哈佛商学院的学生使用的，后来才逐步拓展到其他大学和商务市场。刚开始时，ThinkPad在大学的故障率非常高，甚至需要专门在大学建立售后服务中心，应对大学生笔记本返修问题。内藤在正通过在大学中实地调研，发现大学生对ThinkPad的折磨程度超过了他的想象。例如，大学生会把装着ThinkPad的书包垫在台阶上，直接坐上去，由于小红点和屏幕只有2毫米的间隙，过重的压力会导致屏幕破裂；也会将ThinkPad放入装有十几公斤书本的书包中，骑着单车，让ThinkPad随意地翻滚；甚至在嬉戏玩耍的时候，将装有ThinkPad的书包扔来扔去。</p>
<p>为了让ThinkPad能够承受住大学生的“折磨”，大和实验室专门成立了测试ThinkPad承受能力的“酷刑室”。例如，有将笔记本开合一万次的仪器，用来测试笔记本铰链的质量；有将笔记本放在一个满是灰尘的空间中，看能不能正常使用；有将各种牛奶、果汁泼溅到笔记本键盘上，模拟使用时有液体溅入的场景。</p>
<p>最终，他们克服了种种困难，让ThinkPad成为了“稳定、可靠、质量”的代名词。靠着优秀的品质，ThinkPad进入过太空，深入过雨林，攀登过珠峰，游历过纳米比亚沙漠。</p>
<p>内藤在正和他的团队持续不断地对ThinkPad的改进，是一个典型的工匠精神的体现。然而，这么优秀的ThinkPad，为什么会被IBM卖给联想呢？因为IBM的PC部门一直在亏损。而且，生产核心器件如CPU、硬盘存储、屏幕的部门早已变卖，所以IBM认为PC这条产品线已经没有了核心竞争力，利润提不上去，卖给联想是明智的选择。</p>
<p>ThinkPad转手给联想之后，联想保留了日本大和实验室和美国罗利实验室，可以说保存了ThinkPad的核心团队。从我的观察来看，联想接手ThinkPad之后，一个主要的贡献是让人人都能用得起“小黑”（ThinkPad）。曾几何时，“小黑”是和“小白”（MacBook）一级的高端电脑，动辄几万块，一般人用不起。ThinkPad的质量确实好，大和实验室想尽千万种方法，提高ThinkPad的可靠性。这种不断进取的工匠精神从一些方面是好的，然而也带来了一些弊端。内藤在正也承认，他们可以在某一方面的技术做好精益求精，但是缺少宏观的视野，即所谓的“见木不见林”。不断地提高ThinkPad的可靠性，一方面这些可靠性需要有额外的零部件和加工方法支撑，因而增加了成本，导致ThinkPad的售价居高不下；另一方面，这些可靠性有些过度了，毕竟不是每台ThinkPad都是要“上刀山下火海”的。联想接手后，降低ThinkPad的成本，扩宽ThinkPad的价格范围，进军个人和家庭消费市场。现在，一个普通大学生拿4000块钱也可以买得到ThinkPad，真正让人人都用得起ThinkPad。</p>
<p>有段时间，ThinkPad的老用户抱怨，现在的“小黑”已经不是原来的“小黑”，话语中透露出失望的语气。但是，我认为“小黑”的精神没有丢，高端的ThinkPad产品仍然可靠，而中低端的ThinkPad产品也有着“小黑”的影子。现在无处不在的ThinkPad表明，ThinkPad在联想的经营下，焕发了新的活力。</p>
<p>ThinkPad的经历，不禁让我思考，到底什么才是好的产品？IBM时代的ThinkPad，可靠耐用，从技术上说是好的产品，但从商业角度和消费者的角度来说，不是好的产品，因为价格太贵了。联想时代的ThinkPad，牺牲了一些可靠性，换来了价格的降低，个人消费得起，可靠性方面也能满足日常使用，这时候ThinkPad才成为了好的产品。</p>
<p>本人同为技术人员，遇到挑战往往有一股狠劲，不解决不罢休，但容易钻牛角尖，缺乏大局观。现实世界的问题，不是都能靠技术来解决的。一款好的产品，不见得需要技术上先进，关键是要让消费者以可接受的价格满足他们的需求。所以，不能埋头只做技术，要倾听消费者的意见、进行商业上的考量、做技术上的取舍，这样才能做出好的产品。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在西西弗书店断断续续地读完了《ThinkPad之道》这本书，本书讲的是“Thinkpad之父”内藤在正和他所领导的大和实验室，在研发ThinkPad系列笔记本电脑的过程所面临的种种困难和压力，最终成就了一款经典产品。&lt;/p&gt;
&lt;p&gt;本人大学期间拆装过无数笔记本电脑，自认
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018计划</title>
    <link href="https://jingsam.github.io/2018/02/26/2018-plan.html"/>
    <id>https://jingsam.github.io/2018/02/26/2018-plan.html</id>
    <published>2018-02-26T02:10:28.000Z</published>
    <updated>2018-02-26T03:38:18.416Z</updated>
    
    <content type="html"><![CDATA[<p>过去一年，发现自己越来越难以下笔写东西，原因是身体和思想上的双重懒惰。常常是心中拟定了很多写作的题目，而到要下笔写的时候，总是觉得我对这个主题研究还不够深入全面，然后就默默地为自己找到一个借口：“等我把这个研究透之后再下笔写”，最终就不了了之了。</p>
<p>博文对于我而言，是一种对技术的总结和沉淀。回望2017，自己的博文写得很少，心中很是失落。失落在于自己的心太浮躁，对技术没有进行总结和沉淀。</p>
<p>我下决心在2018年要多写文章，在此立下flag：“2018年每月要产出4篇文章，全年要有48篇文章上线”。要实现这个目标，首先“等我把这个研究透之后再下笔写”这种借口就不成立了，想到某个主题直接写就是了，深度不够？再来一篇。其二，时间上要保障，自己要把逛社交网站、看新闻的时间，抽出来作为写作的时间。三是注意力要集中，不能什么技术研究到一半，注意力又转移到其他技术上了。</p>
<p>关于写作的主题范围，主要还是矢量瓦片方面的技术，包括mapbox-gl-js、矢量切片工具、矢量瓦片服务以及矢量瓦片在时空大数据可视化方面的应用。</p>
<p>关于个人的技术成长，总来的说，要强核心、补短板、宽视野。“强核心”是要强化自己在在线制图和大数据可视化方面的积累，这是自己的核心竞争力，看家老本不能丢。“补短板”是补全自己在Web开发方面的不足，主要是CSS、WebGL以及对MVVM模式的认识，这方面需要自己系统地阅读书籍以及流行库的源代码。“宽视野”是要扩大自己的技术范围，自己不能局限于某一项技术上，要广泛涉猎，知道各项技术的原理，能够敏锐地察觉到某项技在地理信息中的应用前景。</p>
<p>最后，以上的目标要实现的前提是，自己要加强时间的管理。过去的一年，自己没闲着，一直在忙项目上的事情。但从心底来说，对于去年自己的成果，不甚满意，我认为本来还可以完成更多事情。究其原因，自己在时间的安排、任务优先级的把控方面很是不足。所以，今年迫切要改掉坏习惯，把自己的时间规划好。具体做法还是多动笔杆子，把自己的计划事项写下来，这样自己才能不断地排优先级、做计划、实施以及最后的回顾。</p>
<p>总而言之，“凡事预则立，不预则废”。2018，我要做一个有计划的人。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过去一年，发现自己越来越难以下笔写东西，原因是身体和思想上的双重懒惰。常常是心中拟定了很多写作的题目，而到要下笔写的时候，总是觉得我对这个主题研究还不够深入全面，然后就默默地为自己找到一个借口：“等我把这个研究透之后再下笔写”，最终就不了了之了。&lt;/p&gt;
&lt;p&gt;博文对于我而
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mapbox-gl-js接入GeoJSON大文件的优化策略</title>
    <link href="https://jingsam.github.io/2017/10/23/large-geojson-with-mapbox-gl-js.html"/>
    <id>https://jingsam.github.io/2017/10/23/large-geojson-with-mapbox-gl-js.html</id>
    <published>2017-10-23T01:35:06.000Z</published>
    <updated>2017-11-02T02:33:34.105Z</updated>
    
    <content type="html"><![CDATA[<p>mapbox-gl-js可以接受GeoJSON数据，在前端动态地绘制GeoJSON数据。需要说明的是，mapbox-gl-js并不能直接渲染GeoJSON数据，而是通过<code>geojson-vt</code>这个库，在前端动态地将GeoJSON数据转换为矢量瓦片后渲染。至于为什么不支持直接渲染GeoJSON数据，我猜想是因为mapbox-gl-js对于点、线、面、符号、注记等要素的绘制规则都是基于矢量瓦片的，为GeoJSON另外实现一套绘制规则，不仅增大了实现成本，而且两套规则可能会出现冲突。</p>
<p>传统的矢量数据需要预先切片、存储、发布服务，并且当数据更新时又得重新切片，对于小项目来说有点大炮打蚊子的感觉。GeoJSON数据源的好处是接入容易、更新方便，并且市面上有很多工具可以将各种矢量数据转换为GeoJSON格式。</p>
<p>通常来说，GeoJSON数据源适合于少量的矢量数据，大批量的矢量数据最好还是预先切片。但多少数据算是”少量数据呢“？从经验上讲，应该将GeoJSON数据控制在20M以下。需要说明的是，之所以提出”20M“这个经验值，并不是因为mapbox-gl-js对于渲染超过20M的GeoJOSN数据有困难，而是综合考虑网络请求时间和解析数据的时间。实际上，mapbox-gl-js处理100M的GeoJSON数据都没有什么问题，但是把大量的GeoJSON数据整体请求过来所产生的耗时，会严重影响用户体验。所以对于大量的GeoJSON数据，最好预先切片，这样前端可以分块请求，减少网络请求时间和解析数据的时间。</p>
<p>虽然使用GeoJSON大文件作为数据源不是最佳选择，但有些情况下我们不得不使用GeoJSON作为数据源，例如数据是由第三方通过API提供的、数据是实时更新的。当接入大GeoJSON数据时，我们可以通过以下几种优化策略，提高地图绘制的效率。</p>
<h1 id="使用cluster选项"><a href="#使用cluster选项" class="headerlink" title="使用cluster选项"></a>使用cluster选项</h1><p>如果需要接入的数据是点数据，并且十分密集，这时应该对点进行聚合。特别密集的点在小缩放级别会重叠在一起，造成注记压盖叠加，可视化效果不好。使用聚合后，小的缩放级别显示聚合数据，大的缩放级别显示原始数据，兼顾了综合和细节。并且，聚合减少了单张瓦片的数据量，使得引擎绘制更快，交互更流畅。</p>
<p>mapbox-gl-js是通过<code>supercluster</code>这个库对GeoJSON数据进行聚合。其原理是两个点的显示距离小于聚合半径时，聚合为一个点要素，这个点会有一个<code>point_count</code>字段记录聚合的点的数目。需要注意的是，并不是每个层级上所有的点都被聚合，有些孤立的点会保留原位。那么如何区分聚合的和未聚合的点要素呢？可以使用有没有<code>point_cluster</code>进行判断，即使用<code>&quot;filter&quot;: [&quot;has&quot;, &quot;point_count&quot;]</code>过滤出聚合的点要素，使用<code>&quot;filter&quot;: [&quot;!has&quot;, &quot;point_count&quot;]</code>过滤出未聚合的点要素。</p>
<p>mapbox-gl-js通过<code>cluster</code>、<code>clusterRadius</code>、<code>clusterMaxZoom</code>三个参数控制点聚合的效果，并且是要在<code>source</code>里面配置。从逻辑上讲，这三个是控制聚合的效果的，应该放到<code>layer</code>上更符合直觉。然而，mapbox-gl-js的聚合过程并不是在渲染层实现的，而是在数据层实现的，即在动态切片的时候对数据做了聚合操作。所以，从实现角度来讲，将聚合控制参数放在<code>source</code>是合情合理的。以下是这三个参数的说明：</p>
<ul>
<li><code>cluster</code>：设为<code>true</code>开启GeoJSON数据聚合，只对点数据有效；</li>
<li><code>clusterRaius</code>：聚合半径，默认为50像素。当你发现有很多点没有被聚合时，可以适当调大这个参数；</li>
<li><code>clusterMaxZoom</code>：聚合的最大层级，大于这个层级的数据不再聚合，默认值是<code>maxzoom - 1</code>。</li>
</ul>
<h1 id="减小buffer"><a href="#减小buffer" class="headerlink" title="减小buffer"></a>减小buffer</h1><p>矢量瓦片一般会向边界外围扩张一定距离，作为缓冲区，以免边界上的接边要素出现断开的现象。缓冲区越大，出现断裂的可能性越小，但同时导致每张瓦片的尺寸变大，渲染的效率也更低。可以适当减小缓冲区的大小，减小瓦片的额体积，提高渲染效率。</p>
<p><code>buffer</code>的默认值是128像素，能够应付大部分情况。当GeoJSON是点数据，并且用来渲染点要素的符号和注记文本宽度比较小时，可以尝试将<code>buffer</code>设置为0或者稍大的值。</p>
<h1 id="减小maxzoom"><a href="#减小maxzoom" class="headerlink" title="减小maxzoom"></a>减小maxzoom</h1><p><code>maxzoom</code>用来控制将GeoJSON数据切割成矢量瓦片的最大级别，默认值是18级。减小<code>maxzoom</code>，可以加快切片的速度。一般来说，切割到12级，可以保证一定的精度和速度，满足大部分应用需求。</p>
<h1 id="对数据进行minify"><a href="#对数据进行minify" class="headerlink" title="对数据进行minify"></a>对数据进行minify</h1><p>对GeoJSON数据进行minify，即移除JSON中多余的空格、换行符、注释，以及减少坐标点的小数位，可以减小GeoJSON的体积，减小加载时间。</p>
<h1 id="使用URL加载数据"><a href="#使用URL加载数据" class="headerlink" title="使用URL加载数据"></a>使用URL加载数据</h1><p>使用GeoJSON作为数据源，既可以将GeoJSON数据内联到样式文件中，也可以通过URL引用。从直觉上讲，使用内联的GeoJSON不需要网络请求，应该比URL方式更快，然而并不是这样的。使用内联的方式加载大量GeoJSON数据，有以下几个弊端：</p>
<ol>
<li>使样式文件变大，增加了解析的时间；</li>
<li>内联的GeoJSON数据解析后无法释放，将会一直占用内存。</li>
</ol>
<p>因此，对于大GeoJSON数据，尽量以URL的方式加载，可以减少客户端的内存占用。</p>
<h1 id="渲染时增大minzoom"><a href="#渲染时增大minzoom" class="headerlink" title="渲染时增大minzoom"></a>渲染时增大minzoom</h1><p>在配置GeoJSON渲染图层时，默认的<code>minzoom</code>是0，可以适当增大<code>minzoom</code>。<code>geojson-vt</code>在动态切片时，默认小于5级的瓦片是按需生成，大于或等于5级是预先生成。所以，但渲染图层的<code>minzoom</code>大于等于5时，小层级的瓦片不会生成，减少了计算负担。另外，增大<code>minzoom</code>，可以在小层级不需要加载、解析、渲染瓦片，所以渲染更为流畅。</p>
<h1 id="渲染时允许符号重叠"><a href="#渲染时允许符号重叠" class="headerlink" title="渲染时允许符号重叠"></a>渲染时允许符号重叠</h1><p>在配置GeoJSON渲染图层时，可以设置允许注记符号重叠，即设置<code>icon-allow-overlap: true</code>，提高渲染的效率。</p>
<p>mapbox-gl-js在渲染注记符号和文本时，会有一个碰撞检测的过程，即当两个注记有重叠，则隐藏一个。常规条件下，这个碰撞检测很快，耗时可以忽略不计。但是，如果数据中的点非常密集，这部分耗时还是比较客观的。所以，设置<code>icon-allow-overlap: true</code>关闭这个检测过程，可以提高渲染效率。</p>
<p>当然，可以进一步设置允许注记文本也可以重叠，即设置<code>text-allow-overlap: true</code>，继续提高渲染效率。然而，从用户的角度来说，地图上出现符号重叠可以忍受，文本重叠就比较难看了。所以，一般不推荐设置允许注记文本重叠。</p>
<h1 id="对数据进行切分"><a href="#对数据进行切分" class="headerlink" title="对数据进行切分"></a>对数据进行切分</h1><p>如果GeoJSON数据实在很大，可以将GeoJSON数据切分为几块，分别加载。比如，原来是一个GeoJSON大文件，现在把它切分为两个比较小的GeoJSON文件，可以提高处理的效率，原因在于：</p>
<ol>
<li>切分的数据可以并行请求。例如，请求两个5M的数据，比单独请求一个10M的数据要快；</li>
<li><code>geojson-vt</code>处理小文件比处理大文件快。</li>
</ol>
<h1 id="预先切片"><a href="#预先切片" class="headerlink" title="预先切片"></a>预先切片</h1><p>如果GeoJSON数据太大了，比如100M，以上的种种优化方法都不可行。GeoJSON没办法增量加载，必须将完整的GeoJSON数据请求过来，才能开始处理。大的GeoJSON数据，光网络请求就会占用大量时间，所以必须预先切片，分块加载。</p>
<p>预先切片有诸多好处，如减少网络请求时间、渲染效率高。但是，预先切片需要工具切片、瓦片服务器发布服务，而且数据更新有点麻烦。到底切不切片，是动态切片还是预先切片，需要根据数据的情况来确定。</p>
<p>你可以将数据上传到Mapbox Studio进行自动切片，也可以使用开源工具<a href="https://github.com/mapbox/tippecanoe" target="_blank" rel="external">tippecanoe</a>对GeoJSON数据自行切片。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.mapbox.com/rendering-big-geodata-on-the-fly-with-geojson-vt-4e4d2a5dd1f2" target="_blank" rel="external">https://blog.mapbox.com/rendering-big-geodata-on-the-fly-with-geojson-vt-4e4d2a5dd1f2</a></li>
<li><a href="https://blog.mapbox.com/clustering-millions-of-points-on-a-map-with-supercluster-272046ec5c97" target="_blank" rel="external">https://blog.mapbox.com/clustering-millions-of-points-on-a-map-with-supercluster-272046ec5c97</a></li>
<li><a href="https://gist.github.com/ryanbaumann/2d5c851aebf46e4ef5702ee29ead6bdb" target="_blank" rel="external">https://gist.github.com/ryanbaumann/2d5c851aebf46e4ef5702ee29ead6bdb</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mapbox-gl-js可以接受GeoJSON数据，在前端动态地绘制GeoJSON数据。需要说明的是，mapbox-gl-js并不能直接渲染GeoJSON数据，而是通过&lt;code&gt;geojson-vt&lt;/code&gt;这个库，在前端动态地将GeoJSON数据转换为矢量瓦片后渲染
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mapbox-gl如何高效地高亮要素</title>
    <link href="https://jingsam.github.io/2017/10/20/mapbox-gl-highlight.html"/>
    <id>https://jingsam.github.io/2017/10/20/mapbox-gl-highlight.html</id>
    <published>2017-10-20T00:42:01.000Z</published>
    <updated>2017-10-20T08:46:42.451Z</updated>
    
    <content type="html"><![CDATA[<p>mapbox-gl基于矢量瓦片的前端渲染技术，使得要素高亮变得简单。要素高亮具体如何实现，有如下三种方法：</p>
<h1 id="第一种：动态过滤"><a href="#第一种：动态过滤" class="headerlink" title="第一种：动态过滤"></a>第一种：动态过滤</h1><p>这种方法的基本思路是添加一个高亮图层，然后根据鼠标hover的要素id，动态地改变filter条件，实现要素的高亮。</p>
<p>使用到的主要接口是<code>map.on(&#39;mousemove&#39;, layer, e)</code>，其中<code>e</code>可以获取到当前鼠标位置的features，效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/f3au0qLo/4/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试中发现，在图斑比较密集的情况下，高亮非常卡，滞后严重，效率并不高。</p>
<h1 id="第二种：数据源镜像"><a href="#第二种：数据源镜像" class="headerlink" title="第二种：数据源镜像"></a>第二种：数据源镜像</h1><p>第二种方法是对第一种方法的改进，思路如下：对原始数据源做一个镜像，即添加一个新的数据源，名称不通但指向的是同一套数据,例如下面示例中的<code>source-mirror</code>，高亮图层的数据源指向<code>source-mirror</code>。改进后的效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/rj16bqa4/4/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试可以发现，稍微改进一下，高亮的效率提升很大。</p>
<p>但为什么做一个数据源镜像就可以显著地提高高亮的效率呢？我猜想是mapbox-gl在绘制时，会按照数据源对图层分组。指向同一个数据源的图层组中，任意一个图层的渲染条件改变，将会以整个图层组为粒度重新进行运算。在第一种方法中，高亮图层和其他图层都指向同一个数据源，动态地改变高亮图层的过滤条件，导致了很大的运算开销。而第二种方法，为高亮图层单独分配一个数据源，动态地改变高亮图层的过滤条件，也只会导致高亮图层的重绘。</p>
<h1 id="第三种：动态生成高亮数据源"><a href="#第三种：动态生成高亮数据源" class="headerlink" title="第三种：动态生成高亮数据源"></a>第三种：动态生成高亮数据源</h1><p>我们能不能再进一步提高高亮的效率呢？有。第三种方法的思路是：为高亮图层生成一个空的GeoJSON数据源，然后将鼠标hover到的要素动态地填充到数据源中。</p>
<p>使用的接口只要是<code>map.getSource(source).setData(geojson)</code>，其中<code>getSource</code>用于根据sourceId获取数据源，<code>setData</code>用于动态更新数据。效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/ykoyet0w/4/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试可以发现，这种方法甚至比第二种方法效率更高。原因在于要高亮的要素往往很小，前段切成瓦片可能就一两张，因此不用去整体从原始数据源的瓦片种过滤，效率会更高。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一种方法最常用，小批量数据效率还行，但涉及到大数据量情况下，效率就不太理想了。</p>
<p>第二种方法通过小小的改进，就可以极大地提高效率，实现起来也很简单。</p>
<p>第三种方法效率最高，但其中引入了<code>turf.union</code>去合并features，带来了额外的依赖。因此，从简单和优雅的角度来说，我更推荐使用第二种方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mapbox-gl基于矢量瓦片的前端渲染技术，使得要素高亮变得简单。要素高亮具体如何实现，有如下三种方法：&lt;/p&gt;
&lt;h1 id=&quot;第一种：动态过滤&quot;&gt;&lt;a href=&quot;#第一种：动态过滤&quot; class=&quot;headerlink&quot; title=&quot;第一种：动态过滤&quot;&gt;&lt;/a&gt;第
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker save与docker export的区别</title>
    <link href="https://jingsam.github.io/2017/08/26/docker-save-and-docker-export.html"/>
    <id>https://jingsam.github.io/2017/08/26/docker-save-and-docker-export.html</id>
    <published>2017-08-26T06:24:00.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有写博客了，坟头草都长了老高了。写博客要靠惯性，一旦停下来时间长了，就很难再坚持下去。今天艰难地捡起来，以后每周至少写一篇。</p>
<p>这篇文章讲一讲docker save和docker export的区别。</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>docker save和docker export都能导出镜像包，咋看起来区别似乎不大。本文就针对这个问题，试图搞清楚docker save和docker export的功能是什么？适用于什么应用场景？</p>
<p>本文的测试的Docker版本如下，不保证所有版本的docker都能重现本文的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;docker version</div><div class="line"></div><div class="line">Client:</div><div class="line"> Version:      17.07.0-ce-rc1</div><div class="line"> API version:  1.31</div><div class="line"> Go version:   go1.8.3</div><div class="line"> Git commit:   8c4be39</div><div class="line"> Built:        Wed Jul 26 05:19:44 2017</div><div class="line"> OS/Arch:      windows/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line"> Version:      17.07.0-ce-rc1</div><div class="line"> API version:  1.31 (minimum version 1.12)</div><div class="line"> Go version:   go1.8.3</div><div class="line"> Git commit:   8c4be39</div><div class="line"> Built:        Wed Jul 26 05:25:01 2017</div><div class="line"> OS/Arch:      linux/amd64</div><div class="line"> Experimental: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>另外我是在Windows on bash里面操作docker，有些命令如<code>ls</code>并不是windows命令，如果想要复现我的试验，请换成相应的windows命令。</p>
<h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p>docker的命令行接口设计得很优雅，很多命令的帮助直接在后面加<code>--help</code>就可以查看。</p>
<p>docker save的帮助如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker save --<span class="built_in">help</span></div><div class="line"></div><div class="line">Usage:  docker save [OPTIONS] IMAGE [IMAGE...]</div><div class="line"></div><div class="line">Save one or more images to a tar archive (streamed to STDOUT by default)</div><div class="line"></div><div class="line">Options:</div><div class="line">      --<span class="built_in">help</span>            Print usage</div><div class="line">  -o, --output string   Write to a file, instead of STDOUT</div></pre></td></tr></table></figure></p>
<p>从命令行帮助可以看出，docker save是用来将一个或多个image打包保存的工具。</p>
<p>例如我们想将镜像库中的postgres和mongo打包，那么可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save -o images.tar postgres:9.6 mongo:3.4</div></pre></td></tr></table></figure></p>
<p>打包之后的<code>images.tar</code>包含<code>postgres:9.6</code>和<code>mongo:3.4</code>这两个镜像。</p>
<p>虽然命令行参数要求指定image，实际上也可以对container进行打包，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</div><div class="line">3623943d369f        postgres:9.6        <span class="string">"docker-entrypoint..."</span>   3 hours ago         Up 3 hours          5432/tcp            postgres</div><div class="line"></div><div class="line">&gt;docker save -o b.tar postgres</div><div class="line">&gt;docker save -o c.tar postgres:9.6</div><div class="line">&gt;ls -al</div><div class="line">-rwxrwxrwx 1 root root 277886464 8月  26 14:40 b.tar</div><div class="line">-rwxrwxrwx 1 root root 277886464 8月  26 14:41 c.tar</div></pre></td></tr></table></figure></p>
<p>通过以上命令可以看到，<code>b.tar</code>和<code>c.tar</code>是完全一模一样的。这说明，docker save如果指定的是container，docker save将保存的是容器背后的image。</p>
<p>将打包后的镜像载入进来使用docker load，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker load -i images.tar</div></pre></td></tr></table></figure></p>
<p>上述命令将会把<code>postgres:9.6</code>和<code>mongo:3.4</code>载入进来，如果本地镜像库已经存在这两个镜像，将会被覆盖。</p>
<p>docker save的应用场景是，如果你的应用是使用docker-compose.yml编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用docker save将用到的镜像打个包，然后拷贝到客户服务器上使用docker load载入。</p>
<h2 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export"></a>docker export</h2><p>照例查看下docker export的帮助：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker export --help</div><div class="line"></div><div class="line">Usage:  docker export [OPTIONS] CONTAINER</div><div class="line"></div><div class="line">Export a container&apos;s filesystem as a tar archive</div><div class="line"></div><div class="line">Options:</div><div class="line">      --help            Print usage</div><div class="line">  -o, --output string   Write to a file, instead of STDOUT</div></pre></td></tr></table></figure></p>
<p>从帮助可以看出，docker export是用来将container的文件系统进行打包的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export -o postgres-export.tar postgres</div></pre></td></tr></table></figure></p>
<p>docker export需要指定container，不能像docker save那样指定image或container都可以。</p>
<p>将打包的container载入进来使用docker import，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import postgres-export.tar postgres:latest</div></pre></td></tr></table></figure></p>
<p>从上面的命令可以看出，docker import将container导入后会成为一个image，而不是恢复为一个container。</p>
<p>另外一点是，docker import可以指定IMAGE[:TAG]，说明我们可以为镜像指定新名称。如果本地镜像库中已经存在同名的镜像，则原有镜像的名称将会被剥夺，赋给新的镜像。原有镜像将成为孤魂野鬼，只能通过IMAGE ID进行操作。</p>
<p>docker export的应用场景主要用来制作基础镜像，比如你从一个ubuntu镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p>
<h2 id="docker-save和docker-export的区别"><a href="#docker-save和docker-export的区别" class="headerlink" title="docker save和docker export的区别"></a>docker save和docker export的区别</h2><p>总结一下docker save和docker export的区别：</p>
<ol>
<li>docker save保存的是镜像（image），docker export保存的是容器（container）；</li>
<li>docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；</li>
<li>docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。</li>
</ol>
<h2 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h2><p>前面所讲的内容都是些基础知识，相信各位读者只要仔细看下官方文档就能知晓。这一节我来讲讲文档上没有的东西。</p>
<p>docker load和docker import都可以将tar包导入为镜像，我不禁脑洞一下，docker load能不能导入docker export的容器包，docker import能不能导入docker save的镜像包呢？</p>
<p>以下开始试验，准备以下两个文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;ls -al</div><div class="line">-rwxrwxrwx 1 root root 271760384 8月  26 12:15 postgres-export.tar</div><div class="line">-rwxrwxrwx 1 root root 398292480 8月  26 12:13 postgres-save.tar</div></pre></td></tr></table></figure></p>
<p>其中<code>postgres-export.tar</code>是通过docker export导出的容器包，<code>postgres-save.tar</code>是通过docker save保存的镜像包，两者都是基于<code>postgres:9.6</code>镜像。从文件大小可以直观的发现，<code>postgres-export.tar</code>显然要比<code>postgres-save.tar</code>小100多M。</p>
<p>现在试试docker load容器包<code>postgres-export.tar</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;docker load -i postgres-export.tar</div><div class="line">open /var/lib/docker/tmp/docker-import-082344818/bin/json: no such file or directory</div></pre></td></tr></table></figure></p>
<p>显然，docker load不能载入容器包。</p>
<p>那么，反过来，docker import载入镜像包可不可以呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;docker import postgres-save.tar postgres</div><div class="line">sha256:8910feec1ee2fac8c152dbdd0aaab360ba0b833af5c3ad59fcd648b9a24d4838</div><div class="line">&gt;docker image ls</div><div class="line">REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">postgres                                        latest              8910feec1ee2        2 minutes ago       398MB</div></pre></td></tr></table></figure></p>
<p>WTF，竟然成功了！！！</p>
<p>莫慌，再试试启动一个postgres容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;docker run postgres</div><div class="line">C:\Program Files\Docker\Docker\resources\bin\docker.exe: Error response from daemon: No command specified.</div><div class="line">See &apos;C:\Program Files\Docker\Docker\resources\bin\docker.exe run --help&apos;.</div></pre></td></tr></table></figure></p>
<p>虽然能够成功地导入为一个镜像，然而这个镜像并不能使用。</p>
<p>要搞清楚到底是怎么回事，我们先看看镜像包和容器包由什么区别：</p>
<p><img src="/assets/docker-save-vs-docker-export.png" alt="docker save vs docker export"></p>
<p>从上面可以看出右边的<code>postgres-export.tar</code>的内容是一个linux系统的文件目录，猜测就是一个linux镜像。而<code>postgres-save.tar</code>里面到底是什么内容呢？点开一个文件夹看看：</p>
<p><img src="/assets/postgres-save.png" alt="postgres-save.tar"></p>
<p>其实就是一个分层的文件系统。Docker镜像实际上就是由这样的一层层文件进行叠加起来的，上层的文件会覆盖下层的同名文件。如果将<code>postgres-save.tar</code>中的各层文件合并到一起，基本就是<code>postgres-export.tar</code>的内容。由于<code>postgres-save.tar</code>里面的各层文件会存在很多重复的文件，这也解释了为什么<code>postgres-save.tar</code>会比<code>postgres-export.tar</code>大100多M。</p>
<p>docker load必须要载入的是一个分层文件系统，而<code>postgres-export.tar</code>并不具有这样的结构，因此无法载入。</p>
<p>而docker import仅仅是将tar包里面的文件复制进来，所以不管tar包里面的文件结构是怎样的，都可以载入进来，所以能够载入<code>postgres-save.tar</code>。但<code>postgres-save.tar</code>并不是一个有效的操作系统镜像，因此当我试图以改镜像启动容器时，容器并不能启动。</p>
<p>我们再来看看docker import的帮助：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Usage:  docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</div><div class="line"></div><div class="line">Import the contents from a tarball to create a filesystem image</div><div class="line"></div><div class="line">Options:</div><div class="line">  -c, --change list      Apply Dockerfile instruction to the created image</div><div class="line">      --<span class="built_in">help</span>             Print usage</div><div class="line">  -m, --message string   Set commit message <span class="keyword">for</span> imported image</div></pre></td></tr></table></figure></p>
<p>似乎和docker commit很像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</div><div class="line"></div><div class="line">Create a new image from a container<span class="string">'s changes</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">Options:</span></div><div class="line"><span class="string">  -a, --author string    Author (e.g., "John Hannibal Smith</span></div><div class="line"><span class="string">                         &lt;hannibal@a-team.com&gt;")</span></div><div class="line"><span class="string">  -c, --change list      Apply Dockerfile instruction to the created image</span></div><div class="line"><span class="string">      --help             Print usage</span></div><div class="line"><span class="string">  -m, --message string   Commit message</span></div><div class="line"><span class="string">  -p, --pause            Pause container during commit (default true)</span></div></pre></td></tr></table></figure></p>
<p>发现docker import和docker commit都有<code>--change</code>和<code>--message</code>选项。我们可以将docker import理解为将外部文件复制进来形成只有一层文件系统的镜像，而docker commit则是将当前的改动提交为一层文件系统，然后叠加到原有镜像之上。</p>
<p>关于docker save和docker export的区别讲得差不多，拜了个拜。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://docs.docker.com/engine/reference/commandline/save/" target="_blank" rel="external">docker save帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/load/" target="_blank" rel="external">docker load帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/export/" target="_blank" rel="external">docker export帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/import/" target="_blank" rel="external">docker import帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/commit/" target="_blank" rel="external">docker commit帮助文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没有写博客了，坟头草都长了老高了。写博客要靠惯性，一旦停下来时间长了，就很难再坚持下去。今天艰难地捡起来，以后每周至少写一篇。&lt;/p&gt;
&lt;p&gt;这篇文章讲一讲docker save和docker export的区别。&lt;/p&gt;
&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue之slot深度复制</title>
    <link href="https://jingsam.github.io/2017/03/08/vnode-deep-clone.html"/>
    <id>https://jingsam.github.io/2017/03/08/vnode-deep-clone.html</id>
    <published>2017-03-08T11:41:02.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>在Vue中，<code>slot</code>是一个很有用的特性，可以用来向组件内部插入一些内容。<code>slot</code>就是“插槽”的意思，用大白话说就是：定义组件的时候留几个口子，由用户来决定插入的内容。</p>
<p>例如我们定义一个组件<code>MyComponent</code>，其包含一个<code>slot</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当调用<code>&lt;MyComponent&gt;123&lt;/MyComponent&gt;</code>时，会渲染为如下DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  123</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>现在又有新需求了，我们希望调用<code>&lt;MyComponent&gt;123&lt;/MyComponent&gt;</code>时，渲染出这样的DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  123</div><div class="line">  123</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>看起来很容易实现，即再为<code>MyComponent</code>添加一个<code>slot</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>渲染出的结构也确实如你所愿，唯一美中不足的是控制台有一个小小的Warning：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Duplicate presence of slot &quot;default&quot; found in the same render tree</div></pre></td></tr></table></figure></p>
<p>如果你不是强迫症患者，这时候你可以收工安心回家睡觉了。直到有一天你的同事向你抱怨，为什么向<code>MyComponent</code>插入一个自定义组件会渲染不出来？</p>
<p>例如有一自定义组件<code>MyComponent2</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent2&apos;, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div&gt;456&lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当调用<code>&lt;MyComponent&gt;&lt;MyComponent2&gt;&lt;/MyComponent2&gt;&lt;/MyComponent&gt;</code>时，预期渲染为如下DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;div&gt;456&lt;/div&gt;</div><div class="line">  &lt;div&gt;456&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>为什么不能正常工作呢？估计是前面的那个Warning搞得鬼，通过查询发现在Vue 2.0中不允许有重名的<code>slot</code>:</p>
<blockquote>
<p>重名的 Slots 移除<br>同一模板中的重名 <slot> 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用 prop 来传递。</slot></p>
</blockquote>
<p>文档中提示可以用<code>props</code>来实现，然而在我的用例中显然是不合适的。经过搜索后，最靠谱的方法是手写render函数，将<code>slot</code>中的内容复制到其他的位置。</p>
<p>将之前的<code>MyComponent</code>改为render函数的方式定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  render (createElement) &#123;</div><div class="line">    return createElement(&apos;div&apos;, [</div><div class="line">      ...this.$slots.default,</div><div class="line">      ...this.$slots.default</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在上面的定义中我们插入了两个<code>this.$slots.default</code>，测试下能不能正常工作。然而并没有什么卵用，Vue文档在render函数这一章有以下说明：</p>
<blockquote>
<p>VNodes 必须唯一<br>所有组件树中的 VNodes 必须唯一</p>
</blockquote>
<p>这意味着我们不能简单地在不同位置引用<code>this.$slots.default</code>，必须对<code>slot</code>进行深度复制。深度复制的函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function deepClone(vnodes, createElement) &#123;</div><div class="line"></div><div class="line">  function cloneVNode (vnode) &#123;</div><div class="line">    const clonedChildren = vnode.children &amp;&amp; vnode.children.map(vnode =&gt; cloneVNode(vnode));</div><div class="line">    const cloned = createElement(vnode.tag, vnode.data, clonedChildren);</div><div class="line">    cloned.text = vnode.text;</div><div class="line">    cloned.isComment = vnode.isComment;</div><div class="line">    cloned.componentOptions = vnode.componentOptions;</div><div class="line">    cloned.elm = vnode.elm;</div><div class="line">    cloned.context = vnode.context;</div><div class="line">    cloned.ns = vnode.ns;</div><div class="line">    cloned.isStatic = vnode.isStatic;</div><div class="line">    cloned.key = vnode.key;</div><div class="line"></div><div class="line">    return cloned;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  const clonedVNodes = vnodes.map(vnode =&gt; cloneVNode(vnode))</div><div class="line">  return clonedVNodes;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的核心函数就是<code>cloneVNode()</code>，它递归地创建VNode，实现深度复制。VNode的属性很多，我并不了解哪些是关键属性，只是参照着Vue的源码一并地复制过来。</p>
<p>基于以上函数，我们更改<code>MyComponent</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  render (createElement) &#123;</div><div class="line">    return createElement(&apos;div&apos;, [</div><div class="line">      ...this.$slots.default,</div><div class="line">      ...deepClone(this.$slots.default, createElement)</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>经测试，一切正常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Vue 1.0中重名的slots并不会出现什么问题，不知道为什么在2.0中取消了这个功能。我听说React提供了复制Element的标准函数，希望Vue也能提供这个函数，免得大家踩坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Vue中，&lt;code&gt;slot&lt;/code&gt;是一个很有用的特性，可以用来向组件内部插入一些内容。&lt;code&gt;slot&lt;/code&gt;就是“插槽”的意思，用大白话说就是：定义组件的时候留几个口子，由用户来决定插入的内容。&lt;/p&gt;
&lt;p&gt;例如我们定义一个组件&lt;code&gt;MyCo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手机上也可以愉快地搞nodejs开发</title>
    <link href="https://jingsam.github.io/2017/02/07/nodejs-on-android.html"/>
    <id>https://jingsam.github.io/2017/02/07/nodejs-on-android.html</id>
    <published>2017-02-07T09:18:58.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在微博上看到尤雨溪的这么一则微博：<br><img src="/assets/2017-02-07-1.png" alt=""></p>
<p>嗬！在手机上也能跑nodejs，有点儿意思哈。顺手查了查nodejs官网，发现nodejs是支持ARM处理器的，有了这个先决条件，手机上跑nodejs应该没什么大障碍了。本文就来分享一下我在手机上跑nodejs的一点经验。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你得有一部Android手机，iPhone的硬件条件有，但是由于IOS是一个封闭的系统，实际操作起来会很困难。</p>
<p>软件方面需要安装<a href="1">Termux</a>，这是Android平台下的一个开源的终端模拟器。</p>
<p>另外，我建议安装一个编程键盘<a href="2">Hacker’s Keyboard</a>，因为一般的输入法没有Ctrl、Alt、Tab、Esc这些常用控制键，到时候会很麻烦。安装Hacker’s Keyboard，设置为全键盘模式。</p>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>首先得把nodejs安装到手机上。Termux强大的地方在于它带有一个包管理器<code>apt</code>，使用<code>apt</code>可以直接安装nodejs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt update</div><div class="line">apt install nodejs</div></pre></td></tr></table></figure></p>
<p>这样node和npm都安装好了，node的版本是v6.9.4，版本还比较新。</p>
<p>搞开发嘛，做好把git和vim也安装上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install git vim</div></pre></td></tr></table></figure></p>
<p>有了npm之后，我们就可以随意安装需要的包了，这里以vue-cli为例，来跑一个vuejs工程。过程与在电脑上是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm i vue-cli -g</div><div class="line">vue init webpack vue-test</div><div class="line">cd vue-test</div><div class="line">npm i</div><div class="line">npm run dev</div></pre></td></tr></table></figure></p>
<p>浏览器打开localhost:8080，你就可以看到vuejs的欢迎页面了。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>由于Android权限管理的原因，你并不能随意地在任何位置写入文件。你的活动范围必须在Termux的权限之内，即<code>data/data/com.termux/files</code>目录下。虽然你可以写文件到SD卡，但是有些包symbolink的时候会失败，所以保险的做法是所有的操作都在HOME目录下进行，即<code>data/data/com.termux/files/home</code>目录。</p>
<p>在HOME目录下操作的坏处是，但你卸载Termux时，HOME下的所有文件也会删除。所以玩玩而已，不要当真，哈哈！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实话讲，在手机上不长不方便，我想有一下3点：</p>
<ol>
<li>屏幕太小。本来屏幕空间就有限，输入法还要占一半，估计可以通过投屏解决；</li>
<li>没有好的编辑器。本来就没人会在手机上搞正经开发嘛，所以不会有好的编辑器，还好Vim可以凑合着用；</li>
<li>输入不方便。这个也是最大的问题，手机键盘真的太不方便了，有点想念诺基亚N97了。</li>
</ol>
<p><img src="/assets/2017-02-07-2.jpg" alt=""></p>
<p>关于手机键盘，最好能携带方便，搜了下淘宝，下面两款似乎不错哦：<br><img src="/assets/2017-02-07-3.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在微博上看到尤雨溪的这么一则微博：&lt;br&gt;&lt;img src=&quot;/assets/2017-02-07-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用travis-ci持续部署nodejs应用</title>
    <link href="https://jingsam.github.io/2017/01/23/deploy-nodejs-with-travis-ci.html"/>
    <id>https://jingsam.github.io/2017/01/23/deploy-nodejs-with-travis-ci.html</id>
    <published>2017-01-23T03:26:23.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>Travis-ci是一款持续集成（Continuous Integration）服务，它能够很好地与Github结合，每当代码更新时自动地触发集成过程。</p>
<p>Travis-ci配置简单，很多nodejs项目都用它做自动测试。然而，对于持续集成，仅做到自动测试是不够的，还要有后续的自动部署，才能完成“提交代码 =&gt; 自动测试 =&gt; 自动部署”的集成链条。</p>
<p>本文以nodejs应用为例，来谈谈如何利用travis-ci完成自动部署。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>从自动测试到自动部署的核心问题是测试机与生产服务器的信任问题，即如何安全地把程序包传输到生产服务器。市面上的部署工具如scp、ansible、chef，都绕不开这个核心问题。</p>
<p>以scp为例，测试机登录生产服务器的方式有两种：密码和秘钥。密码登录方式需要交互式地输入密码，总不能每次测试的时候，人为地输入密码吧，所以密码方式行不通。</p>
<p>秘钥的方式可以实现自动登录，但首次将测试机的公钥传输给生产服务器仍然需要密码。似乎走入了死胡同，但办法总是有的。我们知道开发机是可以登录到生产服务器的，那么我们就可以<strong>将开发机的公钥复制到生产服务器，将开发机的私钥复制到测试机，测试机通过私钥来伪装成开发机，自动地登录到生产服务器</strong>。</p>
<p>解决了自动登录的问题，另一个问题是怎么将开发机的私钥复制到测试机上。由于测试机每次都是新开的一个虚拟机，这个新开的虚拟机IP不固定，所以没办法直接登录上去。解决办法是将私钥文件作为代码库的一部分提交，这样测试机每次从代码库上拉取代码的同时也获取到了秘钥文件，通过这种方式就实现了私钥从开发机复制到测试机。</p>
<p>将私钥文件提交到代码库有一个很严重的安全性问题，即任何人只要得到了这个私钥文件，他就可以随心所欲的操纵生产服务器。幸好，travis-ci提供了加密方案，它能够将私钥文件加密，加密后的文件只在当前代码库有效。</p>
<p>总的来说，通过复制私钥完成自动登录以及对私钥加密来保障安全性，我们就可以建立起测试机与生产服务器的信任通道，测试机就可以安全地操作生产服务器完成自动部署。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>现在我以scp方式部署nodejs应用为例，来说明travis-ci做自动部署的配置。</p>
<p>首先，建立起开发机与生产服务器的信任关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id username@host</div></pre></td></tr></table></figure></p>
<p>然后，加密你的私钥，私钥文件通常在<code>~/.ssh/id_rsa</code>。加密私钥文件需要使用travis这个命令行工具，它是一个ruby包，使用gem安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gem install travis</div><div class="line">travis login</div></pre></td></tr></table></figure></p>
<p>输入账号密码登录成功后，使用<code>travis encrypt-file</code>加密：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt-file ~/.ssh/id_rsa --add</div></pre></td></tr></table></figure></p>
<p>上面命令执行完后，会生成一段解密命令并添加到<code>.travis.yml</code>中：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">~/.ssh/id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div></pre></td></tr></table></figure></p>
<p>接下来，把加密后的私钥文件（id_rsa.enc）复制到代码库中，千万要注意不要错把未加密的私钥文件（id_rsa）复制到你的代码库中。然后把上面的解密命令的<code>-in ~/.ssh/id_rsa.enc</code>改为<code>-in id_rsa.enc</code>。</p>
<p>通过上面的过程就基本建立测试机与生产服务器的信任关系，但还有一些小细节要处理。例如，降低<code>id_rsa</code>文件的权限，否则ssh处于安全方面的原因会拒绝读取秘钥；将生产服务器地址加入到测试机的信任列表中，否则连接时会询问是否信任服务器。更改后的配置如下:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div><div class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line"><span class="bullet">  -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"Host 102.201.64.94\n\tStrictHostKeyChecking no\n"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></div></pre></td></tr></table></figure></p>
<p>最后，测试机就可以愉快地操作生产服务器了，例如下面是一个nodejs应用的<code>.travis.yml</code>文件配置：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="attr">language:</span> <span class="string">node_js</span></div><div class="line"><span class="attr">node_js:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">'4.4.4'</span></div><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div><div class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line"><span class="bullet">  -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"Host 102.201.64.94\n\tStrictHostKeyChecking no\n"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></div><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">prune</span> <span class="bullet">--production</span>  <span class="comment"># 删除devDependencies</span></div><div class="line"><span class="bullet">  -</span> <span class="string">tar</span> <span class="bullet">-jcf</span> <span class="string">indoor-server.tar.bz2</span> <span class="string">*</span>    <span class="comment"># 打包并压缩代码</span></div><div class="line"><span class="bullet">  -</span> <span class="string">scp</span> <span class="string">indoor-server.tar.bz2</span> <span class="string">jingsam@102.201.64.94:~/</span>  <span class="comment"># 复制到生产服务器上</span></div><div class="line"><span class="bullet">  -</span> <span class="string">ssh</span> <span class="string">jingsam@102.201.64.94</span> <span class="string">'mkdir -p indoor-server &amp;&amp; tar -jxf indoor-server.tar.bz2 -C indoor-server'</span>   <span class="comment"># 解压</span></div><div class="line"><span class="bullet">  -</span> <span class="string">ssh</span> <span class="string">jingsam@102.201.64.94</span> <span class="string">'cd indoor-server &amp;&amp; pm2 startOrReload pm2.json'</span>  <span class="comment"># 重启pm2</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章讲的自动部署其实与nodejs关系不大，完全适用于各种语言的自动部署，其原理都是相通的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Travis-ci是一款持续集成（Continuous Integration）服务，它能够很好地与Github结合，每当代码更新时自动地触发集成过程。&lt;/p&gt;
&lt;p&gt;Travis-ci配置简单，很多nodejs项目都用它做自动测试。然而，对于持续集成，仅做到自动测试是不够
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用node-pre-gyp加速二进制包安装</title>
    <link href="https://jingsam.github.io/2017/01/12/node-pre-gyp-mirror.html"/>
    <id>https://jingsam.github.io/2017/01/12/node-pre-gyp-mirror.html</id>
    <published>2017-01-12T02:36:34.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>node-pre-gyp是一个分发nodejs二进制程序包的工具，负责将预编译好的二进制程序直接下载到用户目录。它介于npm与node-gyp之间，只在相应平台二进制包不存在时才调用node-gyp编译。</p>
<p>node-pre-gyp存在的意义是什么呢？一些简单的nodejs C++扩展直接从源代码编译安装问题不大，但复杂的扩展编译环境难搭建、编译耗时长，因而从源代码安装非常麻烦。node-pre-gyp能够将预编译好的二进制包直接下载到用户目录，只在必要的时候才调用node-gyp从源代码编译，大大加快了nodejs C++扩展的安装速度。</p>
<p>node-pre-gyp需要开发者将各平台编译好的二进制包上传到网络上，并在package.json的<code>binary</code>字段指明二进制包的位置。然而，很多开发者选择将二进制包上传到aws上，导致国内无法正常下载（被墙）。幸好，可以在npm中设置<code>--{module_name}_binary_host_mirror</code>选项来指定二进制包的位置。例如，安装v8-profiler可以使用如下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install v8-profiler --profiler_binary_host_mirror=https://npm.taobao.org/mirrors/node-inspector/</div></pre></td></tr></table></figure></p>
<p>为了让国内开发者也能享受到node-pre-gyp带来的好处，我使用阿里云做了一个镜像，镜像的地址是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://foxgis.oss-cn-shanghai.aliyuncs.com</div></pre></td></tr></table></figure></p>
<p>如果要安装sqlite3，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install sqlite3 --sqlite3_binary_host_mirror=https://foxgis.oss-cn-shanghai.aliyuncs.com</div></pre></td></tr></table></figure></p>
<p>目前是放到阿里云OSS上的，速度还可以，镜像上面包有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mapnik mapbox-gl-native sqlite3 fontnik gdal osrm zipfile</div></pre></td></tr></table></figure></p>
<p>如果有其他包需要放到上面的，请给我留言或者发邮件（abc#whu.edu.cn）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;node-pre-gyp是一个分发nodejs二进制程序包的工具，负责将预编译好的二进制程序直接下载到用户目录。它介于npm与node-gyp之间，只在相应平台二进制包不存在时才调用node-gyp编译。&lt;/p&gt;
&lt;p&gt;node-pre-gyp存在的意义是什么呢？一些简单的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>少年，不要滥用箭头函数啊</title>
    <link href="https://jingsam.github.io/2016/12/08/things-you-should-know-about-arrow-functions.html"/>
    <id>https://jingsam.github.io/2016/12/08/things-you-should-know-about-arrow-functions.html</id>
    <published>2016-12-08T08:30:55.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<p>在ES6大行其道的今天，不应用点ES6特性似乎有些政治不正确。最近刚好有个Node的项目，最低要支持到nodejs 4.0，在<a href="1">node.green</a>看了下ES6的支持度，我想使用的特性基本都有支持，遂决定在新项目中采用ES6来写。</p>
<p>当然第一件事情就是毫不留情地消灭var，项目中能用const的地方不用let，能用let的地方不用var。</p>
<p>第二件事情就是使用劳动人民喜闻乐见的箭头函数替代function。当我心满意足地看到满屏的<code>=&gt;</code>时，现实给了我一记响亮的耳光——改过之后的程序错误百出！</p>
<p>所以，当我们使用箭头函数时，一定要搞清楚箭头函数是什么回事，适用于什么场景。本文就针对以上问题来讨论下箭头函数。</p>
<h2 id="箭头函数是什么？"><a href="#箭头函数是什么？" class="headerlink" title="箭头函数是什么？"></a>箭头函数是什么？</h2><p>箭头函数的语法我就不讲了，相信大家都见识过。跟我一样，大家喜欢箭头函数90%的原因是它好看。除了好看，它是不是与function等价呢？肯定不等价，因为TC39不可能仅因为好看而引入一个语法糖（class除外）。</p>
<p>箭头函数的渊源可以追溯到上古时期一个叫lambda演算的东西。lambda演算是数学家提出来的，有些数学家跟我们程序员一样也很懒，数学定理那么多，今天要证三角定律，明天要证勾股定律，累不累！那能不能将所有的证明问题用一个统一的体系进行形式化描述，然后由机器来完成自动推导呢？lambda演算就是干这个的，图灵也搞了一套体系叫图灵机，两者是等价的。</p>
<p>关于lambda演算说了这么多，好像跟今天要讲的箭头函数没什么关系？其实是有关系的，lambda演算深刻影响了箭头函数的设计。数学家们喜欢用纯函数式编程语言，纯函数的特点是没有副作用，给予特定的输入，总是产生确定的输出，甚至有些情况下通过输出能够反推输入。要实现纯函数，必须使函数的执行过程不依赖于任何外部状态，整个函数就像一个数学公式，给定一套输入参数，不管是在地球上还是火星上执行都是同一个结果。</p>
<p>箭头函数要实现类似纯函数的效果，必须剔除外部状态。所以当你定义一个箭头函数，在普通函数里常见的<code>this</code>、<code>arguments</code>、<code>caller</code>是统统没有的。</p>
<h2 id="箭头函数没有this"><a href="#箭头函数没有this" class="headerlink" title="箭头函数没有this"></a>箭头函数没有<code>this</code></h2><p>箭头函数没有<code>this</code>，那下面的代码明显可以取到<code>this</code>啊：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></div><div class="line">  <span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line"></div><div class="line">  b()</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>以上箭头函数中的<code>this</code>其实是父级作用域中的<code>this</code>，即函数<code>foo</code>的<code>this</code>。箭头函数引用了父级的变量，构成了一个闭包。以上代码等价于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></div><div class="line">  <span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(self.a)</div><div class="line"></div><div class="line">  b()</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>箭头函数不仅没有<code>this</code>，常用的<code>arguments</code>也没有。如果你能获取到<code>arguments</code>，那它一定是来自父作用域的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>])</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>上例中如果箭头函数有<code>arguments</code>，就应该输出的是3而不是1。</p>
<p>一个经常犯的错误是使用箭头函数定义对象的方法，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  foo: <span class="number">1</span>,</div><div class="line">  bar: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>以上代码中，箭头函数中的<code>this</code>并不是指向<code>a</code>这个对象。对象<code>a</code>并不能构成一个作用域，所以再往上到达全局作用域，<code>this</code>就指向全局作用域。如果我们使用普通函数的定义方法，输出结果就符合预期，这是因为<code>a.bar()</code>函数执行时作用域绑定到了<code>a</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  foo: <span class="number">1</span>,</div><div class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>另一个错误是在原型上使用箭头函数，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.foo = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">A.prototype.bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</div><div class="line">a.bar()  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>同样，箭头函数中的<code>this</code>不是指向<code>A</code>，而是根据变量查找规则回溯到了全局作用域。同样，使用普通函数就不存在问题。</p>
<p>通过以上说明，我们可以看出，箭头函数除了传入的参数之外，真的是什么都没有！如果你在箭头函数引用了<code>this</code>、<code>arguments</code>或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。</p>
<h2 id="什么情况下该使用箭头函数"><a href="#什么情况下该使用箭头函数" class="headerlink" title="什么情况下该使用箭头函数"></a>什么情况下该使用箭头函数</h2><p>到这里，我们可以发现箭头函数并不是万金油，稍不留神就会踩坑。</p>
<p>至于什么情况该使用箭头函数，《You Don’t Know About JS》给出了一个决策图：<br><img src="/assets/arrow-function.png" alt="arrow function"></p>
<p>以上决策图看起来有点复杂，我认为有三点比较重要：</p>
<ol>
<li>箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在<code>map</code>、<code>reduce</code>、<code>filter</code>的回调函数定义中；</li>
<li>不要在最外层定义箭头函数，因为在函数内部操作<code>this</code>会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将<code>this</code>控制在可见的范围内；</li>
<li>如开头所述，箭头函数最吸引人的地方是简洁。在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ES6大行其道的今天，不应用点ES6特性似乎有些政治不正确。最近刚好有个Node的项目，最低要支持到nodejs 4.0，在&lt;a href=&quot;1&quot;&gt;node.green&lt;/a&gt;看了下ES6的支持度，我想使用的特性基本都有支持，遂决定在新项目中采用ES6来写。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>打包 Vue 组件库的正确姿势</title>
    <link href="https://jingsam.github.io/2016/11/18/bundle-vue-components.html"/>
    <id>https://jingsam.github.io/2016/11/18/bundle-vue-components.html</id>
    <published>2016-11-17T16:15:28.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便其他开发者使用组件库，开发的 Vue 组件库在发布之前需要对其打包。本文基于 Webpack 讨论打包 Vue 组件库的正确方法。</p>
<h2 id="选择正确的打包格式"><a href="#选择正确的打包格式" class="headerlink" title="选择正确的打包格式"></a>选择正确的打包格式</h2><p>首先，我们必须明确组件库的使用场景。有些场景是直接使用 <code>&lt;script&gt;</code> 在 HTML 中引入，有些场景是使用打包工具在后台构建。作为组件库，应该兼容这些使用场景。组件库应该保持中立，不应该限定于某种使用方式或者打包工具。例如，虽然 Webpack 很流行，组件库不能声明只支持 Webpack 方式使用，忽略了其他选择。原因在于，打包工具并不只有 webpack，还有 browserify、rollup 等。另外，前端工具发展很快，今年流行的工具明年可能就没人用了，你肯定不希望你的组件库会随着某个工具不流行而消逝吧。回顾下曾经流行的 grunt、glup，一大堆基于它们的插件随着工具本身的不流行而被扔进了垃圾箱。</p>
<p>为了支持多种使用场景，我们需要选择合适的打包格式。常见的打包格式有 CMD、AMD、UMD，CMD只能在 Node 环境执行，AMD 只能在浏览器端执行，UMD 同时支持两种执行环境。显而易见，我们应该选择 UMD 格式。Webpack 中指定输出格式的设置项为 <code>output.libraryTarget</code>，其支持的格式有：</p>
<ul>
<li>“var” - 以一个变量形式输出： var Library = xxx (default)；</li>
<li>“this” - 以 this 的一个属性输出： this[“Library”] = xxx；</li>
<li>“commonjs” - 以 exports 的一个属性输出：exports[“Library”] = xxx；</li>
<li>“commonjs2” - 以 module.exports 形式输出：module.exports = xxx；</li>
<li>“amd” - 以 AMD 格式输出；</li>
<li>“umd” - 同时以 AMD、CommonJS2 和全局属性形式输出。</li>
</ul>
<p>以下是 <code>webpack.config.js</code> 中 <code>output</code> 设置的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">    publicPath: <span class="string">'/dist/'</span>,</div><div class="line">    filename: <span class="string">'iview.js'</span>,</div><div class="line">    library: <span class="string">'iview'</span>,       <span class="comment">// 模块名称</span></div><div class="line">    libraryTarget: <span class="string">'umd'</span>,   <span class="comment">// 输出格式</span></div><div class="line">    umdNamedDefine: <span class="literal">true</span>    <span class="comment">// 是否将模块名称作为 AMD 输出的命名空间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此，我们解决了组件库输出的问题。</p>
<h2 id="如何打包组件依赖"><a href="#如何打包组件依赖" class="headerlink" title="如何打包组件依赖"></a>如何打包组件依赖</h2><p>在<a href="/2016/11/01/peerDependencies-in-Vue-components.html">前一篇</a>文章中我们讨论了组件库实质上是 Vue 的插件，Vue 应该是组件库的外部依赖。组件库的使用者会自行导入 Vue，打包的时候，不应该将 Vue 打包进组件库。</p>
<p>在 webpack 中，我们可以将 Vue 设置为 <code>externals</code>，以避免将 Vue 打包进组件库，相应的设置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">externals: &#123;</div><div class="line">    vue: <span class="string">'vue'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>啊哈，我们搞定了组件依赖问题。至此，读者可能很皱起眉头开始埋怨我了：这么简单的问题，查下 webpack 文档不就得了，还用得着我啰里啰嗦地写这么多！</p>
<p>事实上，问题往往没有我们想得那么简单！如果你将打包后的组件库以 <code>&lt;script&gt;</code> 标签形式直接引入，你会发现并不能正常执行，提示 vue 未定义。</p>
<p>为了分析问题，我们将打包的代码前几行拿出来看看：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">webpackUniversalModuleDefinition</span>(<span class="params">root, factory</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span>)</div><div class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"vue"</span>));</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd)</div><div class="line">        define(<span class="string">"iview"</span>, [<span class="string">"vue"</span>], factory);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span>)</div><div class="line">        exports[<span class="string">"iview"</span>] = factory(<span class="built_in">require</span>(<span class="string">"vue"</span>));</div><div class="line">    <span class="keyword">else</span></div><div class="line">        root[<span class="string">"iview"</span>] = factory(root[<span class="string">"vue"</span>]);</div><div class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">__WEBPACK_EXTERNAL_MODULE_157__</span>) </span>&#123;</div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>我们可以看见，打包后的代码以 4 种形式声明了 Vue 依赖：</p>
<ol>
<li><code>module.exports = factory(require(&quot;vue&quot;))</code> - commonjs2 形式；</li>
<li><code>define(&quot;iview&quot;, [&quot;vue&quot;], factory)</code> - AMD 形式；</li>
<li><code>exports[&quot;iview&quot;] = factory(require(&quot;vue&quot;))</code> - commonjs 形式；</li>
<li><code>root[&quot;iview&quot;] = factory(root[&quot;vue&quot;])</code> - 全局变量形式。</li>
</ol>
<p>以 <code>&lt;script&gt;</code> 标签形式使用组件时，会同样使用 <code>&lt;script&gt;</code> 标签导入 Vue。Vue 导入的变量是 “window.Vue” 而不是 “window.vue”，因此会出现 vue 未定义的错误。</p>
<p>幸好，webpack 可以为各种导入形式设置不同名称，设置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">externals: &#123;</div><div class="line">    vue: &#123;</div><div class="line">        root: <span class="string">'Vue'</span>,</div><div class="line">        commonjs: <span class="string">'vue'</span>,</div><div class="line">        commonjs2: <span class="string">'vue'</span>,</div><div class="line">        amd: <span class="string">'vue'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次打包，你可以发现打包的组件库不管是 <code>&lt;script&gt;</code> 标签方式还是后端构建，都可以正常工作了。</p>
<p>最后，帖一个打包 iView 组件库的 webpack 配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        main: <span class="string">'./src/index.js'</span></div><div class="line">    &#125;,</div><div class="line">    output: &#123;</div><div class="line">        path: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">        publicPath: <span class="string">'/dist/'</span>,</div><div class="line">        filename: <span class="string">'iview.js'</span>,</div><div class="line">        library: <span class="string">'iview'</span>,</div><div class="line">        libraryTarget: <span class="string">'umd'</span>,</div><div class="line">        umdNamedDefine: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    externals: &#123;</div><div class="line">        vue: &#123;</div><div class="line">            root: <span class="string">'Vue'</span>,</div><div class="line">            commonjs: <span class="string">'vue'</span>,</div><div class="line">            commonjs2: <span class="string">'vue'</span>,</div><div class="line">            amd: <span class="string">'vue'</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    resolve: &#123;</div><div class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>]</div><div class="line">    &#125;,</div><div class="line">    <span class="built_in">module</span>: &#123;</div><div class="line">        loaders: [&#123;</div><div class="line">            test: <span class="regexp">/\.vue$/</span>,</div><div class="line">            loader: <span class="string">'vue'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.js$/</span>,</div><div class="line">            loader: <span class="string">'babel'</span>,</div><div class="line">            exclude: <span class="regexp">/node_modules/</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.css$/</span>,</div><div class="line">            loader: <span class="string">'style!css!autoprefixer'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.less$/</span>,</div><div class="line">            loader: <span class="string">'style!css!less'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.(gif|jpg|png|woff|svg|eot|ttf)\??.*$/</span>,</div><div class="line">            loader: <span class="string">'url?limit=8192'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.(html|tpl)$/</span>,</div><div class="line">            loader: <span class="string">'vue-html'</span></div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">            <span class="string">'process.env'</span>: &#123;</div><div class="line">                NODE_ENV: <span class="string">'"development"'</span></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便其他开发者使用组件库，开发的 Vue 组件库在发布之前需要对其打包。本文基于 Webpack 讨论打包 Vue 组件库的正确方法。&lt;/p&gt;
&lt;h2 id=&quot;选择正确的打包格式&quot;&gt;&lt;a href=&quot;#选择正确的打包格式&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开发组件库时 Vue 应该放哪儿：devDependencies or peerDependencies？</title>
    <link href="https://jingsam.github.io/2016/11/01/peerDependencies-in-Vue-components.html"/>
    <id>https://jingsam.github.io/2016/11/01/peerDependencies-in-Vue-components.html</id>
    <published>2016-11-01T11:16:58.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<p>最近在和 Aresn 开发 iView 组件库的时候，关于依赖包 Vue 到底是放在 devDependencies 还是 peerDependencies 有些争论。本着打破砂锅问到底的精神，这篇文章讨论下 package.json 里面的各种 depedencies 字段到底是干嘛的。</p>
<p>npm 的 package.json 包括 5 种 dependencies：</p>
<ol>
<li><code>dependencies</code>：应用能够正常运行所依赖的包。这种 dependencies 是最常见的，用户在使用 <code>npm install</code> 安装你的包时会自动安装这些依赖。</li>
<li><code>devDependencies</code>：开发应用时所依赖的工具包。通常是一些开发、测试、打包工具，例如 webpack、ESLint、Mocha。应用正常运行并不依赖于这些包，用户在使用 <code>npm install</code> 安装你的包时也不会安装这些依赖。</li>
<li><code>peerDependencies</code>：应用运行依赖的宿主包。最典型的就是插件，例如各种 jQuery 插件，这些插件本身不包含 jQeury，需要外部提供。用户使用 npm 1 或 2 时会自动安装这种依赖，npm 3 不会自动安装，会提示用户安装。</li>
<li><code>bundledDependencies</code>：发布包时需要打包的依赖，似乎很少见。</li>
<li><code>optionalDependencies</code>：可选的依赖包。此种依赖不是程序运行所必须的，但是安装后可能会有新功能，例如一个图片解码库，安装了 <code>optionalDependencies</code> 后会支持更多的格式。</li>
</ol>
<p>从以上的定义可以看出，<code>dependencies</code> 是程序运行依赖，<code>devDependencies</code> 一般是一些开发工具，<code>peerDependencies</code> 一般用于插件。</p>
<p>下表是我在 awesome-vue 中找到的 28 个 Vue 组件库，统计了 Vue 在这些库中的位置。其中，11 个库选择放到 <code>dependencies</code>，10 个库选择放到 <code>devDependencies</code>，4 个库选择放到 <code>peerDependencies</code>，2 个库选择不放 Vue 依赖，最后还有 1 个库选择在 <code>devDependencies</code> 和 <code>peerDependencies</code> 同时加上 Vue 依赖。</p>
<table>
<thead>
<tr>
<th>UI</th>
<th>dependencies</th>
<th>devDependencies</th>
<th>peerDependencies</th>
<th>none</th>
</tr>
</thead>
<tbody>
<tr>
<td>vue-strap</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>gritcode-components</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Keen-UI</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>material-ui-vue</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-admin</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-carbon</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-impression</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vuikit</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-material</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-kit</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-material-design</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vuestrap-base-components</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vux</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-materialize</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mint-ui</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>N3-components</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-desktop</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-beauty</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>radon-ui</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-antd</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bootstrap-vue</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>iview</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>wovue</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>vue-bulma</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>quasar</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>vueboot</td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>material-components</td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>element</td>
<td></td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>
<p>下面分析下各种选择的优劣：</p>
<ul>
<li><code>dependencies</code>：放到 <code>dependencies</code> 的好处是安装组件库的时候 Vue 会自动安装。问题是已有的工程项目中往往已经安装了 Vue，会导致在 npm 1 或 2 中重复安装 Vue。虽然此问题在 npm 3 中可以规避，但是如果已安装的 Vue 版本与组件库所依赖的版本不兼容时，Vue 仍然会重复安装。</li>
<li><code>devDependencies</code>：由于组件库单元测试时会用到 Vue，所以严格来说 Vue 是属于开发工具包，放到 <code>devDependencies</code> 合情合理。但是，在 <code>devDependencies</code> 中的 Vue 依赖不会自动安装，所以需要用户去查文档来确定到底应该安装哪个版本的 Vue，对用户似乎不太友好。</li>
<li><code>peerDevDependencies</code>：Vue 组件库本质上是 Vue 的插件，依赖于外部提供的 Vue。把 Vue 放到这里，npm 能够提示用户需要安装哪个版本的 Vue，这点比 <code>devDependencies</code>  友好。问题在于，从 npm 3 开始，<code>peerDevDependencies</code> 中的依赖不会自动安装，会导致自动集成测试失败。</li>
<li>不添加依赖：这基本上是最差的选择了，用户甚至不能知道组件库到底依赖哪个版本的 Vue，只能靠猜。</li>
<li><code>devDependencies</code>、<code>peerDevDependencies</code> 同时添加：这是我和 Element UI 的开发者讨论后最优的做法。<code>peerDevDependencies</code> 中的 Vue 是组件库运行所依赖的 Vue 的最低版本，而 <code>devDependencies</code> 运行测试时需要的 Vue 版本，一般情况下 <code>devDependencies &gt;= peerDevDependencies</code>。这种做法保证了 npm 1、2、3 都不会出问题，并且当用户安装组件库时给予友好的提示信息。</li>
</ul>
<p>到这里，我们可以得出以下结论：<strong>在开发 Vue 组件库是，应当同时在 <code>devDependencies</code> 和 <code>peerDevDependencies</code> 添加 Vue 依赖。</strong></p>
<p>最后，可能有人会说：哥们，何必较真呢，能用不就行了吗？我的观点是，如果大家都按照规范来，会减少很多不必要的麻烦。想想看，如果大家在 npm 上发布包的时候不遵守 semver 规范，你还有信心说，你的程序只要 npm install 就能正常运行么？</p>
<p>按老罗的话说，我不是为了输赢，我就是认真！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在和 Aresn 开发 iView 组件库的时候，关于依赖包 Vue 到底是放在 devDependencies 还是 peerDependencies 有些争论。本着打破砂锅问到底的精神，这篇文章讨论下 package.json 里面的各种 depedencies 字
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊 Vue 组件命名那些事</title>
    <link href="https://jingsam.github.io/2016/10/30/vue-components-naming.html"/>
    <id>https://jingsam.github.io/2016/10/30/vue-components-naming.html</id>
    <published>2016-10-30T07:56:01.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>There are only two things in Computer Sciences: cache invalidation and naming things.<br>—— Phil Karlton</p>
</blockquote>
<p>诚如上述所言，编程中变量命名确实令人很头疼。我们模糊地知道，Vue 组件的名称最好不要和原生 HTML 标签相同。为了避免重名，通常会在组件名称前面加上一个前缀，如 <code>el-button</code>、<code>el-input</code>、<code>el-date-picker</code>。这通常不会有什么问题，但有时候你的模板中混杂了原生 HTML 标签和组件标签，要想区分它们并不是很容易。</p>
<p>当我看到 Ant.design 的 React 组件是下面这样的时候，我感觉到一种自由的味道。首先，组件名可以使用原生 HTML 标签名，意味着再也不用较劲脑汁去规避原生 HTML 标签了。另外，这些组件都使用了首字母大写标签名，使它们很容易地与原生小写的 HTML 标签区分。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;Button type=<span class="string">"primary"</span>&gt;Primary&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">    &lt;Input placeholder="Basic usage" /</span>&gt;</div><div class="line">    &lt;Select defaultValue=<span class="string">".com"</span> style=&#123;&#123; <span class="attr">width</span>: <span class="number">70</span> &#125;&#125;&gt;</div><div class="line">      &lt;Option value=<span class="string">".com"</span>&gt;.com&lt;<span class="regexp">/Option&gt;</span></div><div class="line"><span class="regexp">      &lt;Option value=".jp"&gt;.jp&lt;/</span>Option&gt;</div><div class="line">      &lt;Option value=<span class="string">".cn"</span>&gt;.cn&lt;<span class="regexp">/Option&gt;</span></div><div class="line"><span class="regexp">      &lt;Option value=".org"&gt;.org&lt;/</span>Option&gt;</div><div class="line">    &lt;<span class="regexp">/Select&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>div&gt;,</div><div class="line">  mountNode</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>受 Ant.design 的启发，我思考 Vue 组件命名能不能达到同样的效果呢？要找到答案，必须摸清楚 Vue 组件命名到底有什么限制。下面将分别从 Vue 1.0 和 Vue 2.0 来谈谈组件命名的机制：</p>
<h2 id="Vue-1-0-组件命名机制"><a href="#Vue-1-0-组件命名机制" class="headerlink" title="Vue 1.0 组件命名机制"></a>Vue 1.0 组件命名机制</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><p>我们以一个最简单的例子来研究 Vue 组件的注册过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>通过跟踪代码的执行过程，发现对组件的名称有两处检查。</p>
<ol>
<li><p>检查名称是否与 HTML 元素或者 Vue 保留标签重名，不区分大小写。可以发现，只检查了常用的 HTML 元素，还有很多元素没有检查，例如 <code>button</code>、<code>main</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; (commonTagRE.test(id) || reservedTagRE.test(id))) &#123;</div><div class="line">  warn(<span class="string">'Do not use built-in or reserved HTML elements as component '</span> + <span class="string">'id: '</span> + id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;</span></div><div class="line"><span class="comment">// var reservedTagRE = /^(slot|partial|component)$/i;</span></div></pre></td></tr></table></figure>
</li>
<li><p>检查组件名称是否以字母开头，后面跟字母、数值或下划线。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="regexp">/^[a-zA-Z][\w-]*$/</span>.test(name)) &#123;</div><div class="line">  warn(<span class="string">'Invalid component name: "'</span> + name + <span class="string">'". Component names '</span> + <span class="string">'can only contain alphanumeric characaters and the hyphen.'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>基于以上两点，可以总结出组件的命名规则为：组件名以字母开头，后面跟字母、数值或下划线，并且不与 HTML 元素或 Vue 保留标签重名。</p>
<p>然而我们注意到，在上面的检查中，不符合规则的组件名称是 warn 而不是 error，意味着检查并不是强制的。实际上，<strong>Vue 组件注册的名称是没有限制的</strong>。你可以用任何 JavaScript 能够表示的字符串，不管是数字、特殊符号、甚至汉字，都可以成功注册。</p>
<h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><p>虽然 Vue 组件没有命名限制，但是我们终究是要在模板中引用的，不合理的组件名可能会导致我们无法引用它。</p>
<p>为了弄清楚 Vue 是如何将模板中的标签对应到自定义组件的，我们以一段简单的代码说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;my-component&gt;&lt;/my-component&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>总体来说，模板解析分为两个过程：</p>
<p>首先，Vue 会将 <code>template</code> 中的内容插到 DOM 中，以方便解析标签。由于 HTML 标签不区分大小写，所以在生成的标签名都会转换为小写。例如，当你的 <code>template</code> 为 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 时，插入 DOM 后会被转换为 <code>&lt;mycomponent&gt;&lt;/mycomponent&gt;</code>。</p>
<p>然后，通过标签名寻找对应的自定义组件。<strong>匹配的优先顺序从高到低为：原标签名、camelCase化的标签名、PascalCase化的标签名。</strong>例如 <code>&lt;my-component&gt;</code> 会依次匹配 my-component、myComponent、MyComponent。camelCase 和 PascalCase 的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> camelizeRE = <span class="regexp">/-(\w)/g</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> str.replace(camelizeRE, toUpper);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUpper</span>(<span class="params">_, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pascalize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> camelCase = camelize(str);</div><div class="line">  <span class="keyword">return</span> camelCase.charAt(<span class="number">0</span>).toUpperCase() + camelCase.slice(<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于一个 Vue 新手，经常对以下示例代码不能正常运行感到非常疑惑：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;MyComponent&gt;&lt;/MyComponent&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>如果我们按照模板解析的过程推理，就很好解释了。模板 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 插入到 DOM 后会变成 <code>&lt;mycomponent&gt;&lt;/mycomponent&gt;</code>。标签 mycomponent 匹配的组件依次为 mycomponent（原标签名）、mycomponent（camelCase形式）、Mycomponent（PascalCase形式），并没有匹配到注册的组件名 MyComponent，所以会报找不到组件 <mycomponent> 的警告。</mycomponent></p>
<h3 id="命名限制"><a href="#命名限制" class="headerlink" title="命名限制"></a>命名限制</h3><p>通过分析组件注册和模板解析的过程，发现 Vue 组件命名限制并没有我们想象得多。大家可以尝试一下各种命名，我试过 <code>&lt;a_=-*%按钮&gt;&lt;/a_=-*%按钮&gt;</code> 都可正常运行。</p>
<p>但是，并不意味着完全没有限制。由于在模板需要插入到 DOM 中，所以模板中的标签名必须能够被 DOM 正确地解析。主要有三种情况：一是完全不合法的标签名，例如 &lt;/&gt;；二是与 HTML 元素重名会产生不确定的行为，例如使用 input 做组件名不会解析到自定义组件，使用 button 在 Chrome 上正常但在 IE 上不正常；三是与 Vue 保留的 slot、partial、component 重名，因为会优先以本身的意义解析，从而产生非预期的结果。</p>
<p>上述命名限制存在的根本原因，在于模板解析的过程依赖了 DOM。能不能对模板解析过程改进一下，使其不依赖于 DOM 呢？实际上，这正是 Vue 2.0 的主要改进，将模板解析过程使用 Virtual DOM 实现，使得组件命名更加灵活。</p>
<h2 id="Vue-2-0-组件命名机制"><a href="#Vue-2-0-组件命名机制" class="headerlink" title="Vue 2.0 组件命名机制"></a>Vue 2.0 组件命名机制</h2><h3 id="组件注册-1"><a href="#组件注册-1" class="headerlink" title="组件注册"></a>组件注册</h3><p>Vue 2.0 的组件注册过程与 Vue 1.0 基本相同，只是 HTML 标签和 Vue 保留标签范围有些不同：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 区分大小写</span></div><div class="line"><span class="keyword">var</span> isHTMLTag = makeMap(</div><div class="line">  <span class="string">'html,body,base,head,link,meta,style,title,'</span> +</div><div class="line">  <span class="string">'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,'</span> +</div><div class="line">  <span class="string">'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,'</span> +</div><div class="line">  <span class="string">'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,'</span> +</div><div class="line">  <span class="string">'s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,'</span> +</div><div class="line">  <span class="string">'embed,object,param,source,canvas,script,noscript,del,ins,'</span> +</div><div class="line">  <span class="string">'caption,col,colgroup,table,thead,tbody,td,th,tr,'</span> +</div><div class="line">  <span class="string">'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,'</span> +</div><div class="line">  <span class="string">'output,progress,select,textarea,'</span> +</div><div class="line">  <span class="string">'details,dialog,menu,menuitem,summary,'</span> +</div><div class="line">  <span class="string">'content,element,shadow,template'</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// 不区分大小写</span></div><div class="line"><span class="keyword">var</span> isSVG = makeMap(</div><div class="line">  <span class="string">'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,'</span> +</div><div class="line">  <span class="string">'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,'</span> +</div><div class="line">  <span class="string">'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view'</span>,</div><div class="line">  <span class="literal">true</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> isReservedTag = <span class="function"><span class="keyword">function</span> (<span class="params">tag</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> isHTMLTag(tag) || isSVG(tag)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 区分大小写</span></div><div class="line"><span class="keyword">var</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure></p>
<p>虽然 HTML 元素重名警告的标签数大大增加了，但重要的是重名区分大小写，所以我们可以愉快地使用 Input、Select、Option 等而不用担心重名。这个功劳属于 Vue 2.0 引入的 Virtual DOM。</p>
<h3 id="模板解析-1"><a href="#模板解析-1" class="headerlink" title="模板解析"></a>模板解析</h3><p>前面提到，Vue 2.0 相对于 1.0 的最大改进就是引入了 Virtual DOM，使模板的解析不依赖于 DOM。</p>
<p>使用 Virtual DOM 解析模板时，不必像 DOM 方式那样将模板中的标签名转成小写，而是原汁原味地保留原始标签名。然后，使用原始的标签名进行匹配组件。例如，<code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 不会转为为小写形式，直接以 MyComponent 为基础开始匹配。当然，匹配的规则与 1.0 是一样的，即依次匹配：原标签名、camelCase化的标签名、PascalCase化的标签名。</p>
<p>之前在 1.0 不能正常运行的示例代码，在 2.0 中可以正常运行了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;MyComponent&gt;&lt;/MyComponent&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在 Vue 1.0 和 2.0 中还有一种定义组件模板的方式，即使用 DOM 元素。在这种情况下，解析模板时仍然会将标签转为小写形式。所以下面的代码，在 1.0 和 2.0 均不能正常运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.html</span></div><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &lt;MyComponent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ main.js</span></div><div class="line"><span class="regexp">Vue.component('MyComponent', &#123;</span></div><div class="line"><span class="regexp">  template: '&lt;div&gt;hello, world&lt;/</span>div&gt;<span class="string">'</span></div><div class="line"><span class="string">&#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">new Vue(&#123;</span></div><div class="line">  el: '#app'</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="命名限制-1"><a href="#命名限制-1" class="headerlink" title="命名限制"></a>命名限制</h3><p>Vue 2.0 中组件的命名限制与 1.0 的最大区别在于区分了大小写。总结一下就是：一是不使用非法的标签字符；二是不与 HTML 元素（区分大小写）或 SVG 元素（不区分大小写）重名；三是不使用 Vue 保留的 slot 和 component（区分大小写）。</p>
<p>除了以上三条，由于 Vue 2.0 内置了 KeepAlive、Transition、TransitionGroup 三个组件，所以尽量避免与这三个组件重名。但从另一方面讲，你也可以故意重名来实现一些特殊的功能。例如，keep-alive 的匹配顺序为 keep-alive、keepAlive、KeepAlive，所以我们可以注册一个 keep-alive 组件来拦截 KeepAlive 匹配。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我们可以知道 Vue 2.0 完全可以像 React 那样使用 PascalCase 形式的组件标签。对于 Vue 1.0，想以 PascalCase 形态写模板，尽量以全小写或者仅首字母大写形式注册组件，例如 <code>&lt;InputNumber&gt;</code> 组件，可以注册为 inputnumber 或者 Inputnumber。但是，如果你想在 1.0 中使用 Input、Select 这类与 HTML 元素重名的标签名，基本上是无解的，所以是时候尝试下 Vue 2.0 了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;There are only two things in Computer Sciences: cache invalidation and naming things.&lt;br&gt;—— Phil Karlton&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue.js 2.0 独立构建和运行时构建的区别</title>
    <link href="https://jingsam.github.io/2016/10/23/standalone-vs-runtime-only-build-in-vuejs2.html"/>
    <id>https://jingsam.github.io/2016/10/23/standalone-vs-runtime-only-build-in-vuejs2.html</id>
    <published>2016-10-23T04:54:52.000Z</published>
    <updated>2017-10-19T23:34:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Vue.js 2.0 时，有独立构建（standalone）和运行时构建（runtime-only）两种版本可供选择。而在 Vue.js 1.0 中，却没有这种版本区别。到底该使用哪一个版本？这让我有点懵逼的感觉。本着知其然还要知其所以然的精神，我决定好好研究下两者间的区别。</p>
<p>Vue.js 的官方教程上是这么说的：</p>
<blockquote>
<ul>
<li>独立构建包括编译和支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。</li>
<li>运行时构建不包括模板编译，不支持 template 选项。运行时构建，可以用 render 选项，但它只在单文件组件中起作用，因为单文件组件的模板是在构建时预编译到 render 函数中，运行时构建只有独立构建大小的 30%，只有 16Kb min+gzip 大小。</li>
</ul>
</blockquote>
<p>看了半天，实在没搞清两者之间的区别。经过一番搜索，终于搞清楚了问题的本源，且听我娓娓道来。</p>
<p>Vue.js 的运行过程实际上包含两步。第一步，编译器将字符串模板（template）编译为渲染函数（render），称之为编译过程；第二步，运行时实际调用编译的渲染函数，称之为运行过程。</p>
<p>由于 Vue.js 1.0 的编译过程需要依赖浏览器的 DOM，所以无法（或者说没有意义）将编译器和运行时分开。因此在 Vue.js 1.0 分发包中，编译器和运行时是打包在一起，都在浏览器端执行。</p>
<p>然而到了 Vue.js 2.0，为了支持服务端渲染（server-side rendering），编译器不能依赖于 DOM，所以必须将编译器和运行时分开。这就形成了独立构建（编译器 + 运行时）和运行时构建（仅运行时）。显而易见，运行时构建要小于独立构建。</p>
<p>在现代前端工程构建中，通常会使用 vue-loader 和 vueify 预编译模板。在这种情况下，只需要打包运行时，而不需要打包编译器，运行时构建即可满足所需。当然，如果你需要在前端使用 <code>template</code> 选项实时编译模板，那么还是需要使用独立构建将编译器发送到浏览器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Vue.js 2.0 时，有独立构建（standalone）和运行时构建（runtime-only）两种版本可供选择。而在 Vue.js 1.0 中，却没有这种版本区别。到底该使用哪一个版本？这让我有点懵逼的感觉。本着知其然还要知其所以然的精神，我决定好好研究下两者
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Mapbox 地图样式规范》中文版上线啦</title>
    <link href="https://jingsam.github.io/2016/10/19/mapbox-gl-style-spec.html"/>
    <id>https://jingsam.github.io/2016/10/19/mapbox-gl-style-spec.html</id>
    <published>2016-10-19T04:29:01.000Z</published>
    <updated>2017-10-19T23:34:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>最近逮空翻译了下《Mapbox 地图样式规范》，对于英文不好或者懒得看英文的朋友们可能会有用。</p>
<p>页面托管到了 <a href="https://jingsam.github.io/mapbox-gl-style-spec">Github</a> 上，现在也正在和 Mapbox 沟通，看能不能发布到 <a href="http://www.mapbox.cn/" target="_blank" rel="external">mapbox.cn</a> 上，服务下广大中国 Mapboxer。</p>
<p>当然，如果有什么翻译不到位或者错误的地方，欢迎给我发 <a href="https://github.com/jingsam/mapbox-gl-style-spec/issues" target="_blank" rel="external">issue</a>。</p>
<p><img src="/assets/mapbox-gl-style-spec.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近逮空翻译了下《Mapbox 地图样式规范》，对于英文不好或者懒得看英文的朋友们可能会有用。&lt;/p&gt;
&lt;p&gt;页面托管到了 &lt;a href=&quot;https://jingsam.github.io/mapbox-gl-style-spec&quot;&gt;Github&lt;/a&gt; 上，现在也正在
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多边形centroid的计算方法</title>
    <link href="https://jingsam.github.io/2016/10/05/centroid.html"/>
    <id>https://jingsam.github.io/2016/10/05/centroid.html</id>
    <published>2016-10-05T04:53:50.000Z</published>
    <updated>2017-10-19T23:34:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2016/09/26/polylabel2.html">上一篇</a>计算多边形的最佳注记点的算法中，需要计算多边形的centroid。本文就来讲一讲多边形centroid的计算方法。</p>
<h2 id="Centroid的定义"><a href="#Centroid的定义" class="headerlink" title="Centroid的定义"></a>Centroid的定义</h2><p><a href="https://en.wikipedia.org/wiki/Centroid" target="_blank" rel="external">Centroid</a>是多边形的质量中心（Center of mass）。假设多边形是一块厚度均匀的薄板，当我们用一根绳子从一个平衡点吊起薄板时，薄板能够保持水平稳定，那么这个平衡点就是centroid。</p>
<p><img src="/assets/tilt-slab-construction.jpg" alt="tilt-slab-construction"></p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>我们先从1维直线说起，如下图，在原点的一端不同位置上分别挂着重10kg、5kg、7kg的砝码。如果我们将三个砝码当成一个整体，挂在同一个位置，使其产生的杠杆效应与之前相同，那么这个位置点就相当于质心。</p>
<p><img src="/assets/Image1203.gif" alt="Center of mass"></p>
<p>计算方法如下：</p>
<p>总惯性 = 10 × 2 + 5 × 4 + 7 × 5 = 75 kg.m<br>总质量 = 10 + 5 + 7 = 22 kg<br>假设质心距离原点为d，那么 22 x d = 75，得出 d = 75 / 22 ≈ 3.4 m</p>
<p><img src="/assets/Image1207.gif" alt="Center of mass 2"></p>
<p>上述计算1维直线上的质心很简单，那么现在扩展到2维平面。如下图，矩形的质心很容易求得为 (2，1)。</p>
<p><img src="/assets/Image1208.gif" alt="Center of mass 3"></p>
<p>如果更复杂的形状呢？</p>
<p><img src="/assets/Image1211.gif" alt="Center of mass 4"></p>
<p>计算方法是将多边形分解为多个容易求质心的规则矩形，过程如下：</p>
<p>首先将多边形分解为左右两个规则矩形，如下图：</p>
<p><img src="/assets/Image1212.gif" alt="Center of mass 5"></p>
<p>左矩形的面积为 3 x 2 = 6，质心为 (-0.5, 1)<br>左矩形的面积为 2 x 4 = 8，质心为 (2, 2)</p>
<p>我们假设多边形质量是均匀分布的，那么矩形的面积就可以代表它的质量，所以在x轴上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">6 x -0.5 + 8 x 2 = (6 + 8) x dx</div><div class="line">-3 + 16 = 14 x dx</div><div class="line">13 = 14 x dx</div><div class="line">dx = 13 / 14</div></pre></td></tr></table></figure></p>
<p>同理，在y轴上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">6 x 1 + 8 x 2 = (6 + 8) x dy</div><div class="line">6 + 16 = 14 x dy</div><div class="line">22 = 14 x dy</div><div class="line">dy = 11 / 7</div></pre></td></tr></table></figure></p>
<p>最终求得多边形的质心为(13/14, 11/7)</p>
<p>由以上过程，我们可以得出一个更为普遍的结论：</p>
<p>质心 = 惯性 / 质量</p>
<p>用公式表达即为：<br><img src="/assets/eq1.png" alt="eq1"></p>
<p>对于任意不规则多边形，如何利用上述公式计算质心呢？其原理是将多边形剖分为三角形，然后分别计算每个三角形的面积和质心。</p>
<p><img src="/assets/PolygonArea1.png" alt="Polygon area"></p>
<p>对于三角形的面积，我们可以采用向量积公式计算:<br>$<br>signedArea(ABC)=\frac{1}{2}(x_1y_2 - x_2y_1)<br>$<br><img src="/assets/figure7.jpg" alt="Area of triangle"></p>
<p>对于三角形的质心，采用如下公式计算：<br>$<br>centroid(ABC)=(\frac{A_x + B_x + C_x}{3}, \frac{A_y + B_y + C_y}{3})<br>$<br><img src="/assets/figure8.jpg" alt="Centroid of triangle"></p>
<p>剩下的任务是选择一个剖分点P，将多边形剖分为多个三角形。由于我们在用向量积计算三角形面积时，其结果是有正负的。选择哪一个剖分点，并不影响最终加和后的总面积，<strong>前提是多边形的坐标点按逆时针排列</strong>。所以，为了简便期间，选取坐标原点作为剖分点。<br><img src="/assets/PolygonArea3.png" alt="Polygon area"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// polygon按顺时针排列顶点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCentroid</span>(<span class="params">polygon</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> totalArea = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> totalX = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> totalY = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> points = polygon[<span class="number">0</span>]</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length; ++i) &#123;</div><div class="line">    <span class="comment">// a、b以及原点构成一个三角形</span></div><div class="line">    <span class="keyword">var</span> a = points[i + <span class="number">1</span>]</div><div class="line">    <span class="keyword">var</span> b = points[i]</div><div class="line"></div><div class="line">    <span class="keyword">var</span> area = <span class="number">0.5</span> * (a[<span class="number">0</span>] * b[<span class="number">1</span>] - b[<span class="number">0</span>] * a[<span class="number">1</span>])  <span class="comment">// 计算面积</span></div><div class="line">    <span class="keyword">var</span> x = (a[<span class="number">0</span>] + b[<span class="number">0</span>]) / <span class="number">3</span>  <span class="comment">// 计算x方向质心</span></div><div class="line">    <span class="keyword">var</span> y = (a[<span class="number">1</span>] + b[<span class="number">1</span>]) / <span class="number">3</span>  <span class="comment">// 计算y方向质心</span></div><div class="line"></div><div class="line">    totalArea += area</div><div class="line">    totalX += area * x</div><div class="line">    totalY += area * y</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> [totalX / totalArea, totalY/ totalArea]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2016/09/26/polylabel2.html&quot;&gt;上一篇&lt;/a&gt;计算多边形的最佳注记点的算法中，需要计算多边形的centroid。本文就来讲一讲多边形centroid的计算方法。&lt;/p&gt;
&lt;h2 id=&quot;Centroid的定义&quot;&gt;&lt;a href=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>求点到多边形的距离的算法实现</title>
    <link href="https://jingsam.github.io/2016/09/26/polydist.html"/>
    <id>https://jingsam.github.io/2016/09/26/polydist.html</id>
    <published>2016-09-26T04:09:10.000Z</published>
    <updated>2017-10-19T23:34:16.170Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的<a href="/2016/09/26/polylabel2.html">博文</a>中，多边形注记点搜寻算法需要计算点到多边形的距离，本文就来讲一讲如何用JS实现点到多边形距离的计算。</p>
<h2 id="如何定义点到多边形的距离？"><a href="#如何定义点到多边形的距离？" class="headerlink" title="如何定义点到多边形的距离？"></a>如何定义点到多边形的距离？</h2><p>在本文中，点到多边形的距离定义如下：</p>
<ol>
<li>点到多边形边界的最短距离。</li>
<li>点在多边形内部，距离为正；在多边形外部，距离为负；在边上，距离为零。</li>
</ol>
<p>根据上面的定义，计算点到多边形的距离需要解决两个问题：</p>
<ol>
<li>点到多边形的最短距离如何计算？</li>
<li>如何判断点在多边形内部、外部、还是在边界上？</li>
</ol>
<h2 id="点到多边形最短距离的计算"><a href="#点到多边形最短距离的计算" class="headerlink" title="点到多边形最短距离的计算"></a>点到多边形最短距离的计算</h2><p>计算点到多边形最短距离的基本原理是：依次计算点到多边形每条边的距离，然后筛选出最短距离。</p>
<p><img src="/assets/min-dist.png" alt="min-dist"></p>
<p>如下图，假设<code>AB</code>为多边形的一条边，现在求点<code>P</code>到<code>AB</code>的距离。</p>
<p><img src="/assets/segment-dist.png" alt="segment-dist"></p>
<p>根据<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E9%87%8F%E7%A7%AF" target="_blank" rel="external">向量内集</a>的公式（$\vec{a} \cdot \vec{b} = |a||b|cosθ$）,我们可以推出：<br>$<br>\vec{AB} \cdot \vec{AP} = |AB||AP|cosθ = |AB||AD|<br>\ 设 |AD| = t|AB|<br>\ 则 t = \frac{\vec{AB} \cdot \vec{AP}}{|AB|^2}<br>$</p>
<p>根据以上公式，我们可以求出<code>t</code>，进而求出点<code>D</code>的坐标，最终<code>PD</code>的长度就很容易求得了。</p>
<p>但是还有一些边界条件需要注意，即最终<code>D</code>点不是落在<code>AB</code>上，有以下上中情况：</p>
<ol>
<li><code>t &lt; 0</code>，<code>D</code>在<code>BA</code>延长线上，此时最短距离取<code>PA</code>；</li>
<li><code>0 &lt;= t &lt;= 1</code>，<code>D</code>在<code>AB</code>上，此时最短距离取<code>PD</code>；</li>
<li><code>t &gt; 1</code>，<code>D</code>在<code>AB</code>延长线上，此时最短距离取<code>PB</code>；</li>
</ol>
<p><img src="/assets/t.png" alt="t"></p>
<p>JS实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointToSegmentDist</span>(<span class="params">p, a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> AB = [b[<span class="number">0</span>] - a[<span class="number">0</span>], b[<span class="number">1</span>] - a[<span class="number">1</span>]]</div><div class="line">  <span class="keyword">var</span> AP = [p[<span class="number">0</span>] - a[<span class="number">0</span>], p[<span class="number">1</span>] - a[<span class="number">1</span>]]</div><div class="line"></div><div class="line">  <span class="keyword">var</span> AB_AP = AB[<span class="number">0</span>] * AP[<span class="number">0</span>] + AB[<span class="number">1</span>] * AP[<span class="number">1</span>]</div><div class="line">  <span class="keyword">var</span> distAB2 = AB[<span class="number">0</span>] * AB[<span class="number">0</span>] + AB[<span class="number">1</span>] * AB[<span class="number">1</span>]</div><div class="line"></div><div class="line">  <span class="keyword">var</span> D = [a[<span class="number">0</span>], a[<span class="number">1</span>]]</div><div class="line">  <span class="keyword">if</span> (distAB2 != <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">var</span> t = AB_AP / distAB2</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (t &gt; <span class="number">1</span>) &#123;</div><div class="line">      D = [b[<span class="number">0</span>], b[<span class="number">1</span>]]</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</div><div class="line">      D = [a[<span class="number">0</span>] + AB[<span class="number">0</span>] * t, a[<span class="number">1</span>] + AB[<span class="number">1</span>] * t]</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      D = [a[<span class="number">0</span>], a[<span class="number">1</span>]]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> AD = [p[<span class="number">0</span>] - a[<span class="number">0</span>], p[<span class="number">1</span>] - a[<span class="number">1</span>]]</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(AD[<span class="number">0</span>] * AD[<span class="number">0</span>] + AD[<span class="number">1</span>] * AD[<span class="number">1</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="判断点与多边形的位置关系"><a href="#判断点与多边形的位置关系" class="headerlink" title="判断点与多边形的位置关系"></a>判断点与多边形的位置关系</h2><p>判断点与多边形的位置关系，常用的算法是射线法，即经过点沿水平方向做一条直线，观察点左边或右边交点的个数。如果交点个数为奇数，点在多变形内部；交点个数为偶数，点在多边形外部。</p>
<p><img src="/assets/ray.gif" alt="ray"></p>
<p>如下图，<code>ab</code>与过<code>p</code>点的水平线相交于c，则有：<br>$<br>\frac{x_2 - x_1}{y_2 - y_1} = \frac{x’ - x_1}{y - y_1}<br>\ 那么 x’ = \frac{(x_2 - x_1)(y - y_1)}{y_2 - y_1} + x_1<br>$</p>
<p><img src="/assets/ray2.png" alt="ray2"></p>
<p>JS 算法实现为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointInPolygon</span>(<span class="params">p, polygon</span>) </span>&#123;</div><div class="line">  <span class="comment">// 统计p点右边交点的个数</span></div><div class="line">  <span class="keyword">var</span> count = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; polygon.length; k++) &#123;</div><div class="line">    <span class="keyword">var</span> ring = polygon[k]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ring.length - <span class="number">1</span>; i++) &#123;</div><div class="line">      <span class="keyword">var</span> a = ring[i]</div><div class="line">      <span class="keyword">var</span> b = ring[j]</div><div class="line"></div><div class="line">      <span class="keyword">if</span> ((a[<span class="number">1</span>] &gt; y !== b[<span class="number">1</span>] &gt; y) &amp;&amp;</div><div class="line">        (x &lt; (b[<span class="number">0</span>] - a[<span class="number">0</span>]) * (y - a[<span class="number">1</span>]) / (b[<span class="number">1</span>] - a[<span class="number">1</span>]) + a[<span class="number">0</span>])) count++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> count % <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>解决了以上两个难题之后，下面给出完整实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointToPolygonDist</span>(<span class="params">p, polygon</span>) </span>&#123;</div><div class="line">  <span class="comment">// 统计p点右边交点的个数</span></div><div class="line">  <span class="keyword">var</span> count = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> minDist = <span class="literal">Infinity</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; polygon.length; k++) &#123;</div><div class="line">    <span class="keyword">var</span> ring = polygon[k]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ring.length - <span class="number">1</span>; i++) &#123;</div><div class="line">      <span class="keyword">var</span> a = ring[i]</div><div class="line">      <span class="keyword">var</span> b = ring[j]</div><div class="line"></div><div class="line">      <span class="keyword">if</span> ((a[<span class="number">1</span>] &gt; y !== b[<span class="number">1</span>] &gt; y) &amp;&amp;</div><div class="line">        (x &lt; (b[<span class="number">0</span>] - a[<span class="number">0</span>]) * (y - a[<span class="number">1</span>]) / (b[<span class="number">1</span>] - a[<span class="number">1</span>]) + a[<span class="number">0</span>])) count++;</div><div class="line"></div><div class="line">      minDist = <span class="built_in">Math</span>.min(minDist, pointToSegmentDist(p, a, b))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (count % <span class="number">2</span> === <span class="number">0</span>) minDist = -minDist</div><div class="line"></div><div class="line">  <span class="keyword">return</span> minDist</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的&lt;a href=&quot;/2016/09/26/polylabel2.html&quot;&gt;博文&lt;/a&gt;中，多边形注记点搜寻算法需要计算点到多边形的距离，本文就来讲一讲如何用JS实现点到多边形距离的计算。&lt;/p&gt;
&lt;h2 id=&quot;如何定义点到多边形的距离？&quot;&gt;&lt;a href=&quot;#如
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多边形注记点搜索算法实现</title>
    <link href="https://jingsam.github.io/2016/09/26/polylabel2.html"/>
    <id>https://jingsam.github.io/2016/09/26/polylabel2.html</id>
    <published>2016-09-26T03:52:27.000Z</published>
    <updated>2017-10-19T23:34:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2016/09/24/polylabel.html">上一篇</a>博文中，我讲了多边形注记点搜索算法的基本原理，本篇文章讲一讲如何用JS实现。</p>
<p>建议读者阅读本篇博文之前，一定要先了解<a href="/2016/09/24/polylabel.html">上一篇</a>博文中提到的算法原理。</p>
<h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>我们定义一个函数接口，接受一个多边形，计算其标注点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">polylabel</span>(<span class="params">polygon</span>) </span>&#123;</div><div class="line">  <span class="comment">// TODO</span></div><div class="line">  <span class="keyword">return</span> [x, y]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.export = polylabel</div></pre></td></tr></table></figure></p>
<p>使用时，我们可以这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var polylabel = require(&apos;polylabel&apos;)</div><div class="line"></div><div class="line">var polygon = [[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]]</div><div class="line">var point = polylabel(polygon)</div></pre></td></tr></table></figure></p>
<p>对于polygon，我们采用geojson对多边形的坐标定义格式，即多边形由多个环组成，其中第一个环是外环，其他的为内环。所以<code>polygon[0]</code>表示第一个环，<code>ploygon[0][0]</code>表示起点坐标。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始实现polylabel之前，需要一些辅助函数和库。</p>
<p>首先，我们定义网格对象<code>Cell</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cell</span>(<span class="params">x, y, h, polygon</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x  <span class="comment">// 中心点x</span></div><div class="line">  <span class="keyword">this</span>.y = y  <span class="comment">// 中心点y</span></div><div class="line">  <span class="keyword">this</span>.h = h  <span class="comment">// 中心点到网格的距离，相当于格网大小的1/2</span></div><div class="line">  <span class="keyword">this</span>.d = pointToPolygonDist(x, y, polygon)  <span class="comment">// 中心点到多边形的距离</span></div><div class="line">  <span class="keyword">this</span>.max = <span class="keyword">this</span>.d + <span class="keyword">this</span>.h * <span class="built_in">Math</span>.SQRT2     <span class="comment">// 网格内部区域到多边形的最大距离</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义网格对象的主要目的是方便求取最大距离<code>this.max</code>，有了网格对象<code>Cell</code>之后，每当我们实例化一个cell对象，我们就可以知道这个网格区域的最大距离以及它所代表的区域。</p>
<p><code>pointToPolygonDist</code>是计算点到多边形的距离的函数，其基本原理是计算点到多边形每条边的距离，取最短距离即为点到多边形的距离。详细的算法实现我考虑专门用一篇文章来讲。</p>
<p><code>this.d + this.h * Math.SQRT2</code>即为我们之前在算法原理中求得的最大距离<code>dist + radius</code>，由于格网是一个正方形，其外接圆形的半径即为中心点到任意一个顶点的距离，即<code>this.h * Math.SQRT2</code>。</p>
<p><img src="/assets/radius.png" alt="radius"></p>
<p>另一个需要准备的是一个<a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank" rel="external">优先级队列</a>的数据结构，它与一般的队列不同在于，优先级队列中的元素都是经过排序的。每当push一个元素，并不是简单地将该元素放入队列末尾，而是会将该元素与队列中的元素进行比较，放到一个合适的位置上。</p>
<p>我们可以定义一个优先级队列，队列里存储的是格网对象。每push入一个格网，根据最大距离<code>max</code>进行排序，大的在前，小的在后。由此，我们可以分裂格网时，只需从队首pop出一个格网进行操作。</p>
<p>优先级队列的一个JS实现是<a href="https://github.com/mourner/tinyqueue" target="_blank" rel="external">tinyqueue</a>，同样是Vladimir Agafonkin的作品。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Queue = <span class="built_in">require</span>(<span class="string">'tinyqueue'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">polylabel</span>(<span class="params">polygon</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 计算bbox，为切分网格做准备</span></div><div class="line">  <span class="keyword">var</span> minX, minY, maxX, maxY</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; polygon[<span class="number">0</span>].length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> p = polygon[<span class="number">0</span>][i]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">0</span>] &lt; minX) minX = p[<span class="number">0</span>]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">1</span>] &lt; minY) minY = p[<span class="number">1</span>]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">0</span>] &gt; maxX) maxX = p[<span class="number">0</span>]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">1</span>] &gt; maxY) maxY = p[<span class="number">1</span>]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 计算长和宽，初始格网大小和高度</span></div><div class="line">  <span class="keyword">var</span> width = maxX - minX</div><div class="line">  <span class="keyword">var</span> height = maxY - minY</div><div class="line">  <span class="keyword">var</span> cellSize = <span class="built_in">Math</span>.min(width, height)</div><div class="line">  <span class="keyword">var</span> h = cellSize / <span class="number">2</span></div><div class="line"></div><div class="line">  <span class="comment">// 初始化一个存储Cell的优先级队列，按距离从大到小排列</span></div><div class="line">  <span class="keyword">var</span> cellQueue = <span class="keyword">new</span> Queue(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> b.max - a.max</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 将多边形切分</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = minX; x &lt; maxX; x += cellSize) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> y = minY; y &lt; maxY; y += cellSize) &#123;</div><div class="line">      cellQueue.push(<span class="keyword">new</span> Cell(x + h, y + h, h, polygon));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 取对首为最优格网</span></div><div class="line">  <span class="keyword">var</span> bestCell = cellQueue.peek()</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (cellQueue.length) &#123;</div><div class="line">    <span class="keyword">var</span> cell = cellQueue.pop()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cell.d &gt; bestCell.d) bestCell = cell</div><div class="line"></div><div class="line">    <span class="comment">// 最大距离小于最优格网的距离，直接淘汰</span></div><div class="line">    <span class="keyword">if</span> (cell.max &lt;= bestCell.d) <span class="keyword">continue</span></div><div class="line"></div><div class="line">    <span class="comment">// 将格网裂为4个小格网</span></div><div class="line">    h = cell.h / <span class="number">2</span></div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x - h, cell.y - h, h, polygon))</div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x + h, cell.y - h, h, polygon))</div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x - h, cell.y + h, h, polygon))</div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x + h, cell.y + h, h, polygon))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> [bestCell.x, bestCell.y]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p>上一节描述了多边形注记点搜寻算法的基本实现，我们还需要对其进行优化，提升算法效率。</p>
<p>为了提升效率，我们可以增加一个容差参数，允许最后的注记点有一定的误差，以减少运算次数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if (cell.max &lt;= bestCell.d) continue</span></div><div class="line"><span class="keyword">if</span> (cell.max - bestCell.d &lt;= precision) <span class="keyword">continue</span></div></pre></td></tr></table></figure></p>
<p>另外，我们可以在初始时，用centroid作为初始最优点，因为大多数凸多边形的centroid就是最佳注记点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var bestCell = cellQueue.peek()</span></div><div class="line"><span class="keyword">var</span> bestCell = getCentroidCell(polygon)</div></pre></td></tr></table></figure></p>
<p>当然，多变形的centeroid怎么求，估计又得用一篇博文来说了。</p>
<p>感觉给自己挖了好多坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2016/09/24/polylabel.html&quot;&gt;上一篇&lt;/a&gt;博文中，我讲了多边形注记点搜索算法的基本原理，本篇文章讲一讲如何用JS实现。&lt;/p&gt;
&lt;p&gt;建议读者阅读本篇博文之前，一定要先了解&lt;a href=&quot;/2016/09/24/polyla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多边形注记点搜索的算法原理</title>
    <link href="https://jingsam.github.io/2016/09/24/polylabel.html"/>
    <id>https://jingsam.github.io/2016/09/24/polylabel.html</id>
    <published>2016-09-23T17:34:18.000Z</published>
    <updated>2017-10-19T23:34:16.170Z</updated>
    
    <content type="html"><![CDATA[<p>在制图过程中，对多边形进行标注是一个常见的需求。然而如何快速找到一个合适的注记点，确不是一个很容易的事情。</p>
<p>最近，Leaflet的作者<a href="https://github.com/mourner" target="_blank" rel="external">Vladimir Agafonkin</a>大神发表了一篇<a href="https://www.mapbox.com/blog/polygon-center/" target="_blank" rel="external">博文</a>，描述了他如何用100多行JS代码，实现一个高效的多边形标注点搜寻<a href="https://github.com/mapbox/polylabel" target="_blank" rel="external">算法</a>。</p>
<p>虽然他在博文中描述了算法的原理，但是对于我这种数学不好的人，有些细节方面的东西还不甚了解。因此，此篇文章将以我这种小白角度，事无巨细地解释下他的算法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于一个多边形，哪一个点才适合做标注点呢？自然而然我们就会想到是重心，即<a href="https://en.wikipedia.org/wiki/Centroid" target="_blank" rel="external">centroid</a>。然而对于凹多边形或者环，它们的重心会出现在多边形外部，这明显不是我们想要的。</p>
<p><img src="/assets/centeroid.png" alt="centeroid"></p>
<p>一个合适的标注点，应该是多边形的视觉中心，即以该点为圆心在多边形内部画一个圆，该圆的面积是最大的。假如我们定义一个点到多边形的距离为该点到多边形各边的最短距离，并且规定点在多边形内部时距离为正，点在外部时距离为负。所以多边形标注问题就可以简化为寻找离多边形最远的点，即<a href="https://en.wikipedia.org/wiki/Pole_of_inaccessibility" target="_blank" rel="external">pole of inaccessibility</a>。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>理论上，只要知道多边形的各点坐标，必定能够用数学公式求出这个离多边形最远的点。然而，求解这个标注点的精确坐标必定非常耗时，实际上我们只需要一个近似解就足够了。</p>
<p>如何搜寻这个点呢？其实算法原理很简单，即利用分而治之的思想，先搜寻一小块区域，逐步淘汰差的区域，逐步缩小搜寻范围，最终找到最优点。具体步骤为：</p>
<ol>
<li>对多边形进行格网划分，求出格网内部的点到多边形的最大距离。</li>
<li>按最大距离对格网进行排序，淘汰距离小的格网，保留距离大的格网。</li>
<li>对剩下的格网再进行细分，重复步骤1和步骤2。</li>
</ol>
<p>在以上的步骤中，格网内部的点到多边形的最大距离如何计算是一个问题。如下图，格网中心点到多边形的距离为<code>dist</code>，到顶点的距为<code>radius</code>，那么格网到多边形的最大距离<code>maxd = dist + radius</code>。</p>
<p><img src="/assets/dist.jpg" alt="dist"></p>
<p>如何证明上述计算最大距离的公式呢？我几何学得不好，没办法给出严密的数学证明，但是我可以通过图示予以说明。</p>
<p>如下图，设多边形内部一点<code>O</code>，其距多边形的距离<code>OA</code>长度为<code>dist</code>。以<code>O</code>为圆心，以<code>radius</code>为半径作一个圆。延长AO，交圆于点<code>B</code>，那么<code>AB</code>的长度为<code>dist + radius</code>。在圆内部任意取一点<code>B&#39;</code>，显然<code>AB&#39; &lt;= AB = dist + radius</code>。假设点<code>B‘</code>到多边形的距离为<code>d</code>，那么<code>d &lt;= AB&#39; &lt;= AB = dist + radius</code>。所以对于圆内的任意一点，其到多边形的距离必定小于等于<code>dist + radius</code>。在圆内部取一个正方形区域，仍然符合<code>d &lt;= dist + radius</code>，这就证明格网区域的最大距离为<code>dist + radius</code>。</p>
<p><img src="/assets/proof.png" alt="proof"></p>
<p>如何对格网进行细分呢？我们可以用四叉树，将一个格网分割为4个小格网。</p>
<p><img src="/assets/quadtree.jpg" alt="quadtree"></p>
<p>搜寻标注点的算法原理是不是很简单？我将在下一篇博文中详细描述如何用JS实现该算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在制图过程中，对多边形进行标注是一个常见的需求。然而如何快速找到一个合适的注记点，确不是一个很容易的事情。&lt;/p&gt;
&lt;p&gt;最近，Leaflet的作者&lt;a href=&quot;https://github.com/mourner&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
    
  </entry>
  
</feed>
