<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jingsam</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jingsam.github.io/"/>
  <updated>2018-05-28T14:36:47.904Z</updated>
  <id>https://jingsam.github.io/</id>
  
  <author>
    <name>jingsam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手动更新Homebrew formula</title>
    <link href="https://jingsam.github.io/2018/05/23/edit-a-brew-formula.html"/>
    <id>https://jingsam.github.io/2018/05/23/edit-a-brew-formula.html</id>
    <published>2018-05-23T06:24:01.000Z</published>
    <updated>2018-05-28T14:36:47.904Z</updated>
    
    <content type="html"><![CDATA[<p>Homebrew是macOS上的软件包管理神器，类似于Ubuntu的apt-get，是使用mac作为开发机时的必装软件之一。Homebrew的软件包术语叫Formula，中文解释就是”配方”。Homebrew有“家酿、自制”的意思，80年代硅谷有一个著名的计算机俱乐部叫“Homebrew Homebrew Computer Club”，苹果的创始人Steve Jobs和Steve Wozniak都曾是这个俱乐部的活跃分子。“家酿”一个东西当然得有“配方”，所以这个取名很形象。</p>
<p>使用homebrew安装软件很方便，一条命令<code>brew install your-formula-name</code>就可以搞定。更新formula到最新版本，使用<code>brew upgrade your-formula-name</code>即可。</p>
<p>但是，各种formula是人工维护的，当软件包更新后，formula不见得能及时更新到最新版本。本文就以gdal为例，说明如何手动编辑formula文件，以此来将软件更新到最新版本。</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>Homebrew中的每个软件包都是通过一个<code>formula.rb</code>文件来配置软件的源代码URL、依赖、编译规则和选项，例如以下是gdal的formula文件：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gdal</span> &lt; Formula</span></div><div class="line">  desc <span class="string">"Geospatial Data Abstraction Library"</span></div><div class="line">  homepage <span class="string">"http://www.gdal.org/"</span></div><div class="line">  url <span class="string">"https://download.osgeo.org/gdal/2.2.4/gdal-2.2.4.tar.xz"</span></div><div class="line">  sha256 <span class="string">"6f75e49aa30de140525ccb58688667efe3a2d770576feb7fbc91023b7f552aa2"</span></div><div class="line">  revision <span class="number">2</span></div><div class="line"></div><div class="line">  bottle <span class="keyword">do</span></div><div class="line">    rebuild <span class="number">2</span></div><div class="line">    sha256 <span class="string">"00b28455769c3d5d6ea13dc119f213f320c247489cb2ce9d03f7791d4b53919b"</span> =&gt; <span class="symbol">:high_sierra</span></div><div class="line">    sha256 <span class="string">"1365de6a18caeb84d6a50e466a63be9c7541b1fab21edfc3012812157464f2c0"</span> =&gt; <span class="symbol">:sierra</span></div><div class="line">    sha256 <span class="string">"8c0fd81eda5a91c8a75a78795f96b6dd9c53e74974bd38cc004b55a44ae95932"</span> =&gt; <span class="symbol">:el_capitan</span></div><div class="line">  <span class="keyword">end</span></div><div class="line"></div><div class="line">  ....</div></pre></td></tr></table></figure>
<p>以上是一个ruby文件，好在并不需要懂ruby的语法就能看懂formula文件。<code>desc</code>和<code>homepage</code>都是描述性信息，不对软件安装产生什么影响。<code>url</code>是软件源代码的位置，编译安装时从此位置将源代码下载下来。<code>sha256</code>是源代码包的校验码，这是保证下载下来的包不被篡改。<code>revision</code>是修订版本号，主要用来保持版本号不变的情况下，对软件包打补丁，每打一次补丁，修订版本号就自增一次。当使用<code>brew install</code>安装软件包时，除非使用<code>--build-from-source</code>强制指定使用源代码安装，大部分情况下，brew会下载编译好的二进制包，这样安装起来更快。<code>bottle</code>选项就记录了各版本macOS下预编译的二进制包的校验码，这部分内容是homebrew的自动集成工具自动维护的，我们并不需要编辑修改。</p>
<p>更改上面的<code>url</code>和<code>sha256</code>，即可将formula的配置更新到任意版本。编辑好后，使用<code>brew install</code>或者<code>brew upgrade</code>进行安装或者更新升级。</p>
<p>Homebrew实际上是通过git来管理formula配置文件的，因此我们还可以发送Pull request，将我们的更新推送到GitHub上，让别人也能够方便地更新软件包。</p>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><p>这部分以更新gdal 2.2.4到2.3.0为例，来说明手动更新formula的步骤。由于写作本文时，gdal已经更新到2.3.0，所以某些步骤的输出可能与本文不一致，但不妨碍理解更新步骤。</p>
<h2 id="编辑配置"><a href="#编辑配置" class="headerlink" title="编辑配置"></a>编辑配置</h2><p>使用<code>brew edit gdal</code>即可打开<code>gdal.rb</code>开始编辑，我们将<code>url</code>更新为2.3.0版本的源代码链接：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gdal</span> &lt; Formula</span></div><div class="line">  desc <span class="string">"Geospatial Data Abstraction Library"</span></div><div class="line">  homepage <span class="string">"http://www.gdal.org/"</span></div><div class="line">  url <span class="string">"https://download.osgeo.org/gdal/2.3.0/gdal-2.3.0.tar.xz"</span></div><div class="line">  sha256 <span class="string">"6f75e49aa30de140525ccb58688667efe3a2d770576feb7fbc91023b7f552aa2"</span></div><div class="line">  revision <span class="number">2</span></div><div class="line"></div><div class="line">  ...</div></pre></td></tr></table></figure>
<p>理论上我们还需要更新<code>sha256</code>，使它和<code>url</code>相匹配。但是<code>sha256</code>需要我们使用工具计算或者从发布网站上找，不是很方便。我们可以通过下一步的安装调试，来自动计算<code>sha256</code>。</p>
<h2 id="安装调试"><a href="#安装调试" class="headerlink" title="安装调试"></a>安装调试</h2><p>使用<code>brew install gdal --verbose --debug --build-from-source</code>来安装调试gdal的formula，如果已经安装旧版本的gdal，那么使用<code>brew upgrade gdal --verbose --debug --build-from-source</code>。<code>--verbose</code>表示显示详细输出，便于调试；<code>--debug</code>打开调试；<code>--build-from-source</code>强制从源代码编译。</p>
<p>安装过程中，会报sha256校验码不匹配的警告，并打印出<code>url</code>所指向的源代码包的sha256校验值，这是因为在上一步我们并没有修改<code>sha256</code>，配置文件中<code>sha256</code>还是gdal 2.2.4版本的。这时候重新使用<code>brew edit gdal</code>打开并编辑formula文件，将<code>sha256</code>更改为正确的校验值。</p>
<p>最后，再安装调试，经过漫长的编译，成功地安装上了gdal的最新版本。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试包括对软件包的测试和对formula文件的测试。使用<code>brew test gdal</code>可以测试gdal的功能是否正常，使用<code>brew audit --strict gdal</code>测试formula文件是否正确。运行<code>brew audit</code>时，会报告<code>revision 2</code>需被删除，这是因为当前homebrew线上库中还没有gdal 2.3.0，意味着本地端的gdal应该是第一版本，不存在修订版本之说。同样地，使用<code>brew edit gdal</code>打开并删除<code>revision</code>部分，然后再重新测试。</p>
<h2 id="推送更新"><a href="#推送更新" class="headerlink" title="推送更新"></a>推送更新</h2><p>通过上述步骤，我们完成了gdal的手动更新，如果将更新推送到homebrew的线上库中，那么其他人就可以方便地更新到最新版本。并且推送到线上库后，homebrew的自动集成工具会自动地编译生成二进制包，这样就不需要从源代码编译那么耗时了，可谓是利人利己。</p>
<p>由于homebrew是在GitHub上协作的，所以更新一个formula就和发一个Pull request是一样的，基本步骤如下：</p>
<p>1.使用<code>cd $(brew --repository homebrew/homebrew-core)</code>切换到本地的homebrew-core目录；<br>2.使用<code>git commit</code>提交自己的修改；<br>3.把<a href="https://github.com/Homebrew/homebrew-core" target="_blank" rel="external">https://github.com/Homebrew/homebrew-core</a> fork一份；<br>4.使用<code>git remote add</code>命令添加自己的fork的homebrew-core库；<br>5.使用<code>git push</code>推送将本地提交推送到自己的fork的homebrew-core库中；<br>6.在GitHub网页上发起Pull request。</p>
<h2 id="一键更新"><a href="#一键更新" class="headerlink" title="一键更新"></a>一键更新</h2><p>上面一步步完成了编辑配置、安装调试、测试、推送更新，操作起来有些繁琐。但其实homebrew还提供了一个工具，能够一键完成上面4个步骤，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew bump-formula-pr gdal --URL=https://download.osgeo.org/gdal/2.3.0/gdal-2.3.0.tar.xz --audit --strict</div></pre></td></tr></table></figure>
<p><code>brew bump-formula-pr</code>自动的修改formula配置文件、检查文件错误、提交并推送更新，其中提交并推送更新的过程需要使用<code>hub</code>来在终端上操作GitHub，可以使用<code>brew install hub</code>来安装这个工具。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Homebrew是macOS上的软件包管理神器，类似于Ubuntu的apt-get，是使用mac作为开发机时的必装软件之一。Homebrew的软件包术语叫Formula，中文解释就是”配方”。Homebrew有“家酿、自制”的意思，80年代硅谷有一个著名的计算机俱乐部叫“H
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux进程后台运行</title>
    <link href="https://jingsam.github.io/2018/05/07/linux-nohup.html"/>
    <id>https://jingsam.github.io/2018/05/07/linux-nohup.html</id>
    <published>2018-05-07T09:25:15.000Z</published>
    <updated>2018-05-21T07:17:40.752Z</updated>
    
    <content type="html"><![CDATA[<p>在linux上启动Web服务，当退出终端后，Web服务进程也会随着关闭。产生这种问题的原因在于，当用户注销或者网络断开后，终端后收到挂断信号（SIGHUP）,并向子进程广播SIGHUP信号，子进程收到SIGHUP信号而关闭。因此，让linux后台持续运行的方法有以下几种：</p>
<p>1.改变子进程的所属的父进程，只要父进程不关闭，子进程也不会关闭；<br>2.让子进程忽略挂断信号，即使收到SIGHUP信号，也任性地继续运行；<br>3.不向子进程广播SIGHUP信号，子进程收不到SIGHUP信号，因而不会关闭。</p>
<h1 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h1><p>使用<code>setsid</code>可以新开一个session运行进程，此session不从属于当前终端，因此终端关闭时进程也不会退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;setsid ping www.baidu.com</div><div class="line">&gt;ps -ef | grep www.baidu.com</div><div class="line">501 57697     1   0  5:55下午 ttys000    0:00.01 ping www.baidu.com</div></pre></td></tr></table></figure>
<p>从上面可以看出，ping进程的父进程是1，即init进程，因此只要电脑不关机，ping进程就不会停止。</p>
<p>linux下自带<code>setsid</code>这个命令，但是macOS上并没有这个命令。此时，可以结合使用<code>()</code>和<code>&amp;</code>达到同样的效果。<code>()</code>可以新开一个subshell，<code>&amp;</code>让命令后台运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;(ping www.baidu.com &amp;)</div><div class="line">&gt;ps -ef | grep www.baidu.com</div><div class="line">501 57781     1   0  6:01下午 ttys000    0:00.00 ping www.baidu.com</div></pre></td></tr></table></figure>
<p>可以看到，效果与<code>setsid</code>是一样的。</p>
<h1 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h1><p>使用<code>nohup</code>可以使进程忽略SIGHUP信号，这种方式也是最常用的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;nohup ping www.baidu.com &amp;</div><div class="line">[1]  + 59193 exit 127   nohup www.baidu.com</div><div class="line"></div><div class="line">&gt;ps -ef | grep www.baidu.com</div><div class="line">501 59193 39100   0  6:05下午 ttys000    0:00.01 ping www.baidu.com</div></pre></td></tr></table></figure>
<p>可以看到，ping进程的父进程并不为1，nohup是让进程忽略SIGHUP信号实现进程不退出的。</p>
<p>需要注意的是，当在<code>zsh</code>中使用<code>nohup</code>时，退出终端时会提示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zsh: you have running jobs.</div></pre></td></tr></table></figure>
<p>再次强行退出，那么进程仍然会被干掉。这时候，采用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup ping www.baidu.com &amp;!</div></pre></td></tr></table></figure>
<h1 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h1><p>使用nohup的前提是，进程以nohup来启动。但是，如果启动时忘记了以nohup启动，有什么方法在不停止进程的情况，让它继续后台运行呢？接下来就要将另外一个命令：<code>disown</code>。<code>disown</code>的原理是，将子进程从终端任务队列中移除，所以即使终端挂断，子进程也收不到SIGHUP信号。</p>
<p>假设现在使用ping命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;ping www.baidu.com</div><div class="line">64 bytes from 14.215.177.38: icmp_seq=0 ttl=51 time=19.642 ms</div><div class="line">64 bytes from 14.215.177.38: icmp_seq=1 ttl=51 time=97.976 ms</div><div class="line">64 bytes from 14.215.177.38: icmp_seq=2 ttl=51 time=88.996 ms</div><div class="line">...</div></pre></td></tr></table></figure>
<p>这时采用<code>Ctrl + z</code>使它进入后台，使用<code>jobs</code>查看后台进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;jobs</div><div class="line">[1]  + suspended  ping www.baidu.com</div></pre></td></tr></table></figure>
<p>可以看到虽然ping进程进入后台，但是进程被挂起了，没有继续运行。使用<code>bg</code>命令可以使他在后台继续运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;bg %1</div><div class="line">[1]  + 58174 continued  ping www.baidu.com</div><div class="line">&gt;jobs</div><div class="line">[1]  + running    ping www.baidu.com</div></pre></td></tr></table></figure>
<p>通过组合<code>Ctrl + z</code>和<code>bg</code>，成功地将前台进程变为了后台进程。为了让进程不随终端关闭而终止，还差最后一步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;disown %1</div><div class="line">&gt;jobs</div></pre></td></tr></table></figure>
<p>上面使用<code>jobs</code>命令查看任务队列，发现ping进程不在任务队列中，意味着进程不会收到SIGHUP信号。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>以上我们通过三种方式，避免进程随着终端关闭而被杀掉：</p>
<ol>
<li><code>setsid</code>改变父进程，只要父进程不关闭，进程就可以持续运行；</li>
<li><code>nohup</code>使得进程忽略SIGHUP信号，父进程即使发送挂断信号，进程也不会终止；</li>
<li><code>disown</code>将进程从任务队列中移除，保证进程收不到SIGHUP信号。</li>
</ol>
<p>但是，以上种种方法只是避免了进程受到SIGHUP信号的影响，进程的持续运行还需要一些其他环境，例如stdin、stdout以及stderr。通常从终端启动的进程，会继承终端的stdin、stdout和stderr。当终端断掉之后，stdin、stdout和stderr也会随着消失，若此时后台进程需要读写stdin、stdout、stderr，该进程将会暂停或者挂住。所以，为保证进程正常后台运行，最好启动时对输入输出重定向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;ping www.baidu.com &gt; a.log 2&gt;&amp;1 &amp;</div></pre></td></tr></table></figure>
<p>此时，将stdout和stderr重定向到文件<code>a.log</code>中，文件<code>a.log</code>不受终端关闭的影响。如果进程依赖于stdin，意思是进程需要由于键盘输入，那就说明这是个交互式程序，交互式程序后台运行就没多大意义了。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/index.html" target="_blank" rel="external">Linux 技巧：让进程在后台可靠运行的几种方法</a><br><a href="https://unix.stackexchange.com/questions/3886/difference-between-nohup-disown-and" target="_blank" rel="external">Difference between nohup, disown and &amp;</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在linux上启动Web服务，当退出终端后，Web服务进程也会随着关闭。产生这种问题的原因在于，当用户注销或者网络断开后，终端后收到挂断信号（SIGHUP）,并向子进程广播SIGHUP信号，子进程收到SIGHUP信号而关闭。因此，让linux后台持续运行的方法有以下几种：&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Windows Server 2012评估版本延长使用期限</title>
    <link href="https://jingsam.github.io/2018/03/13/windows-server-rearm.html"/>
    <id>https://jingsam.github.io/2018/03/13/windows-server-rearm.html</id>
    <published>2018-03-13T07:00:51.000Z</published>
    <updated>2018-03-13T07:24:31.128Z</updated>
    
    <content type="html"><![CDATA[<p>最近一台Windows Server 2012 R2数据库服务器隔一个小时就关机，恰巧碰到要演示，这种突发情况让我手忙脚乱。（别问我为什么要用Windows Server做服务器，客户要求的）网上搜了下，发现是Windows授权到期了，需要激活。</p>
<p>网上确实有很多Windows Server破解激活工具，但是有各种各样的工具，不知道哪个能起作用。而且，这些工具大部分杀毒软件都报有病毒，不太敢用。最重要的是，破解激活涉及到版权问题，道义上过不去。</p>
<p>由于我使用的是Windows Server评估版本，评估版本可以重置5次试用期，所以加上安装的那次，那么理论了最多可以试用1080天，差不多3年。</p>
<p>重置方法很简单，以管理员身份打开命令提示符，输入以下命令即可重置试用期，获得180天试用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slmgr.vbs /rearm</div></pre></td></tr></table></figure>
<p><strong>重置成功后需要重启一次才能生效。</strong></p>
<p>通过以下命令可以查看剩余的试用时间和可重置次数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">slmgr.vbs /dlv</div></pre></td></tr></table></figure>
<p>那么重置次数试用完之后怎么办呢？据说可以通过改注册表的方式获得额外的重置次数，但是这种方法可能违反了系统试用协议。具体的做法是使用<code>regedit</code>打开注册表编辑器，找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HKEY_LOCAL_MACHINE -&gt; SOFTWARE -&gt; Microsoft -&gt; Windows NT -&gt; CurrentVersion -&gt; SoftwareProtectionPlatform</div></pre></td></tr></table></figure>
<p>将键<code>SkipRearm</code>的值设为1，再用<code>slmgr.vbs /rearm</code>继续重置，据说这种方法可以使用8次。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.vixual.net/blog/archives/180" target="_blank" rel="external">Windows Server 2012 評估版與延長使用期限</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一台Windows Server 2012 R2数据库服务器隔一个小时就关机，恰巧碰到要演示，这种突发情况让我手忙脚乱。（别问我为什么要用Windows Server做服务器，客户要求的）网上搜了下，发现是Windows授权到期了，需要激活。&lt;/p&gt;
&lt;p&gt;网上确实有很
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于package.json中main字段的指向问题</title>
    <link href="https://jingsam.github.io/2018/03/12/npm-main.html"/>
    <id>https://jingsam.github.io/2018/03/12/npm-main.html</id>
    <published>2018-03-12T11:58:22.000Z</published>
    <updated>2018-03-13T07:30:29.575Z</updated>
    
    <content type="html"><![CDATA[<p><code>package.json</code>中的<code>main</code>字段指向的是Library的入口，通常有3个选择：</p>
<p>1.指向源代码入口文件，如<code>src/index.js</code>;<br>2.指向打包后的开发版本，如<code>dist/library.js</code>;<br>3.指向打包后的发布版本，如<code>dist/library.min.js</code>。</p>
<p>引用Library的方式也分为两种：</p>
<p>1.通过script标签直接引用，适用于简单页面；<br>2.通过require或import方式引用，需要借助打包工具打包，适用于复杂页面。</p>
<p>本文探讨一下<code>main</code>字段如何指定，才能兼顾各种引用方式。</p>
<h1 id="指向源代码入口文件"><a href="#指向源代码入口文件" class="headerlink" title="指向源代码入口文件"></a>指向源代码入口文件</h1><p>第一种方式指向源码入口，这种情况仅适用于require方式引用。由于指向的是源代码，需要库使用者借助打包工具如webpack，自行对库进行打包。此方式存在以下问题：</p>
<p>1.webpack配置babel-loader一般会排除node_modules，意味着不会对library进行转译，可能会导致打包后的代码中包含ES6代码，造成低版本浏览器兼容问题；<br>2.如果library的编译需要一些特别的loader或loader配置，使用者需要在自己的配置中加上这些配置，否则会造成编译失败；<br>3.使用者的打包工具需要收集library的依赖，造成打包编译速度慢，影响开发体验。</p>
<p>总的来说，第一种方式需要使用者自行对library进行编译打包，对使用者造成额外的负担，因此源代码入口文件不适宜作为库的入口。但是，如果library的目标运行环境只是node端，由于node端不需要对源代码进行编译打包，所以这种情况下可以使用<code>src/index.js</code>作为库入口。</p>
<h1 id="指向打包后的开发版本"><a href="#指向打包后的开发版本" class="headerlink" title="指向打包后的开发版本"></a>指向打包后的开发版本</h1><p>开发版本的主要作用是便于调试，文件体积并不是开发版本所关心的问题，这是因为开发版本通常是托管在localhost上，文件大小基本没影响。</p>
<p>开发版本主要通过以下手段来方便调试，提升开发体验：</p>
<p>1.预先进行依赖收集和babel转译，即使用者不再需要对library进行这两步工作了，提高编译打包的效率；<br>2.尽量保留源代码的格式，保证开发版本里面的源代码基本可读；<br>3.保留警告信息，对开发者对库的错误或不合理调用进行提示。</p>
<p>其中第3点是通过库代码中添加如下类似代码实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (process.env.NODE_ENV === &apos;development&apos;) &#123;</div><div class="line">  console.warn(&apos;Some useful warnings.&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成开发版本的似乎，webpack的DefinePlugin会将<code>process.env.NODE_ENV</code>替换为<code>development</code>，所以以上代码变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (&apos;development&apos; === &apos;development&apos;) &#123;</div><div class="line">  console.warn(&apos;Some useful warnings.&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就表示上述条件一直成立，warning信息会显示出来。</p>
<p>最近和iview的开发者争论一件事，即在生成library的开发版本的时候，<code>NODE_ENV</code>应该设置为<code>development</code>还是<code>production</code>。他们认为应该设置为<code>production</code>，理由是可以减小开发版本的体积。假设DefinePlugin将<code>process.env.NODE_ENV</code>替换为<code>production</code>，之前的示例代码会变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (&apos;production&apos; === &apos;development&apos;) &#123;</div><div class="line">  console.warn(&apos;Some useful warnings.&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就意味着你使用库开发应用时，不会看到任何警告信息，这不利于提前发现错误。可能有的人会说，我的源代码中没有<code>if (process.env.NODE_ENV === &#39;development&#39;) {}</code>这类代码，所以设置为<code>production</code>也不会有任何问题呀。殊不知，虽然你的源代码中这种没有这类提示代码，但是你的devependencies里面可能会有啊，这样做就会关闭依赖中的warning信息。</p>
<p>可能又有疑问：“引用开发版本的包体积很大，岂不是让我的应用打包上线版本很大？”其实完全不用担心，因为应用打包为上线版本时，会经过两个额外的工作：</p>
<p>1.使用DefinePlugin将<code>process.env.NODE_ENV</code>替换为<code>production</code>，关闭所有警告信息；<br>2.使用UglifyJsPlugin对应用代码进行minify，减小应用体积。同时会删除<code>if (&#39;production&#39; === &#39;development&#39;) {}</code>这类永远不会执行的代码，进一步减小应用体积。</p>
<p>所以，在开发时应用开发版本，不必担心最后的应用体积。但是如果开发时是以script标签的方式引用库的开发版本，上线时应该替换为响应的发布版本。</p>
<h1 id="指向打包后的发布版本"><a href="#指向打包后的发布版本" class="headerlink" title="指向打包后的发布版本"></a>指向打包后的发布版本</h1><p>发布版本追求的是尽量减小体积，因为相比于JS引擎解析的时间，网络传输是最慢的，所以要通过减小库的体积，减少网络传输的时间。</p>
<p>减小发布版本的文件体积，主要是通过将<code>process.env.NODE_ENV</code>设置为<code>production</code>，然后再使用UglifyJsPlugin对应用代码进行minify以及删除永不执行的代码。</p>
<p>那么将库的发布版本作为入口文件合不合适呢？显然不合适，因为发布版本的是经过高度压缩精简的，代码完全不可读，应用开发阶段难以调试。</p>
<p>发布版本是适用于在应用上线时，通过script标签形式引用。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>通过上面的分析，可以发现将库的开发版本作为库的入口才是正确合理的做法，即设置<code>&quot;main&quot;: &quot;dist/library.js&quot;</code>。而作为库的开发者，也要遵循约定，生成库的开发版本的时候，使用<code>development</code>环境变量，保留警告信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;中的&lt;code&gt;main&lt;/code&gt;字段指向的是Library的入口，通常有3个选择：&lt;/p&gt;
&lt;p&gt;1.指向源代码入口文件，如&lt;code&gt;src/index.js&lt;/code&gt;;&lt;br&gt;2.指向打包后的开发版本，如&lt;co
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Library项目的Webpack配置</title>
    <link href="https://jingsam.github.io/2018/03/06/webpack.html"/>
    <id>https://jingsam.github.io/2018/03/06/webpack.html</id>
    <published>2018-03-06T06:24:48.000Z</published>
    <updated>2018-03-07T09:03:12.306Z</updated>
    
    <content type="html"><![CDATA[<p>知乎上有个提问，叫“如何成为高级Webpack配置工程师”，戏谑Webpack已经复杂到成为一门专业学问了。但Webpack确实是非常复杂的，一般人只能做到入门而无法精通。Webpack的复杂性在于要完成各种各样的功能，即不仅要处理js、css、html、图片、字体等各种格式的前端资源，还要对这些资源进行转译、精简、提取、分割、打包等一系列操作。</p>
<p>Webpack在当前前端工程化中占有很重要的地位，前端工程化是为了提高前端开发的效率，但是前端工程化中的工具链配置的复杂度也逐渐提高。有时候新开一个项目，光是配置这些工具就要花一两天，这对于小型项目有点得不偿失。在配置工具链的时间花费大，诚然webpack本身配置参数多，我认为更重要的原因在于平时过于依赖于vue-cli、react-scripts这类自动化生成工具，没有具体地了解每个配置项的作用。</p>
<p>最近要开发一个可视化的JS库，但是vue-cli、react-scripts这类自动化生成工具主要针对的是SPA，对开发Library支持不好，因而尝试下手动配置webpack、eslint、babel、prettier这些工具。好在开发的是Library，主要处理JS代码，如果是SPA，那就需要处理各种各样的前端资源，还是建议使用vue-cli、react-scripts。</p>
<p>本文主要是做步骤记录，用于指导以后进行简单项目的手动配置，因而本篇文章不探讨深度内容。</p>
<h1 id="生成package-json"><a href="#生成package-json" class="headerlink" title="生成package.json"></a>生成package.json</h1><p>这块没什么好说的，借助<code>npm init</code>或<code>yarn init</code>可以快速地生成<code>package.json</code>文件。我通常习惯于先在<code>scripts</code>中把主要的开发命令写出来，以下是我的<code>scripts</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;build-dev&quot;: &quot;webpack --config build/webpack.dev.config.js&quot;,</div><div class="line">    &quot;build-prod&quot;: &quot;webpack --config build/webpack.prod.config.js&quot;,</div><div class="line">    &quot;build&quot;: &quot;npm run build-dev &amp;&amp; npm run build-prod&quot;,</div><div class="line">    &quot;start&quot;: &quot;webpack-dev-server --config build/webpack.dev.config.js&quot;,</div><div class="line">    &quot;lint&quot;: &quot;eslint src/*.js&quot;,</div><div class="line">    &quot;format&quot;: &quot;prettier-eslint --write src/*.js&quot;</div><div class="line">  &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>scripts</code>配置也体现了下文要讲的工程目录结构，即<code>build</code>里面放webpack配置文件，<code>src</code>里面放源代码，详细的内容在下一节描述。</p>
<p><code>main</code>默认是<code>index.js</code>，即指向源代码的入口文件。但是本项目主要开发的库是作为其他项目的node_modules，一般不会再对库进行转译，所以为了方便将本库集成到前段工程项目中，<code>main</code>应该指向转译好的UMD格式文件。本项目的<code>main</code>配置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;main&quot;: &quot;dist/geoeye.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="规划目录结构"><a href="#规划目录结构" class="headerlink" title="规划目录结构"></a>规划目录结构</h1><p>我认为工程的目录结构非常重要，它能够反映代码的模块划分，好的目录结构让人赏心悦目、容易理解。我按照以下目录进行组织：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">build  // 编译配置</div><div class="line">  |- webpack.dev.config.js</div><div class="line">  |- webpack.prod.config.js</div><div class="line">dist  // 编译好的库文件</div><div class="line">  |- geoeye.js</div><div class="line">  |- geoeye.min.js</div><div class="line">  |- geoeye.min.js.map</div><div class="line">src   // 源代码</div><div class="line">debug // 用于调试</div><div class="line">test  // 测试</div><div class="line">package.json</div></pre></td></tr></table></figure>
<h1 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h1><p>Webpack 4刚发布，据说简化了配置，所以本项目就来尝尝鲜。Webpack 4相比原来需要额外安装一个webpack-cli，并且要求node版本不小于6.11.5，安装命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev webpack webpack-cli</div></pre></td></tr></table></figure>
<p>接下来就要配置<code>webpack.dev.config.js</code>和<code>webpack.prod.config.js</code>。webpack官方文档推荐用一个<code>webpack.common.config.js</code>提取公共配置后，再用<code>webpack-merge</code>合并。由于本项目配置比较简单，重复的地方不多，所以就不用引入额外的复杂度了。如果项目的配置复杂到同一种配置需要重复3次以上，那么还是需要采用<code>webpack-merge</code>合并的，因为同时更改3个地方很容易出错。</p>
<p>本项目的<code>webpack.dev.config.js</code>的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;)</div><div class="line">const webpack = require(&apos;webpack&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &apos;./src/index.js&apos;,</div><div class="line">  output: &#123;</div><div class="line">    path: path.join(__dirname, &apos;../dist&apos;),</div><div class="line">    filename: &apos;geoeye.js&apos;,</div><div class="line">    library: &apos;geoeye&apos;,</div><div class="line">    libraryTarget: &apos;umd&apos;,</div><div class="line">    umdNamedDefine: true</div><div class="line">  &#125;,</div><div class="line">  devtool: &apos;cheap-module-eval-source-map&apos;,</div><div class="line">  devServer: &#123;</div><div class="line">    contentBase: &apos;./debug&apos;,</div><div class="line">    publicPath: &apos;/dist/&apos;,</div><div class="line">    hot: true,</div><div class="line">    open: true,</div><div class="line">    overlay: true</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        loader: &apos;babel-loader&apos;,</div><div class="line">        exclude: /node_modules/</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  mode: &apos;development&apos;,</div><div class="line">  plugins: [</div><div class="line">    new webpack.HotModuleReplacementPlugin()</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本项目的<code>webpack.prod.config.js</code>的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;)</div><div class="line">const webpack = require(&apos;webpack&apos;)</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &apos;./src/index.js&apos;,</div><div class="line">  output: &#123;</div><div class="line">    path: path.join(__dirname, &apos;../dist&apos;),</div><div class="line">    filename: &apos;geoeye.min.js&apos;,</div><div class="line">    library: &apos;geoeye&apos;,</div><div class="line">    libraryTarget: &apos;umd&apos;,</div><div class="line">    umdNamedDefine: true</div><div class="line">  &#125;,</div><div class="line">  devtool: &apos;source-map&apos;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        loader: &apos;babel-loader&apos;,</div><div class="line">        exclude: /node_modules/</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  mode: &apos;production&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上有以下几个地方需要注意：</p>
<p>1.<code>entry</code>中使用相对于当前目录时，<code>./</code>不能省略，即<code>./src/index.js</code>不能写为<code>src/index.js</code>。<br>2.<code>output</code>中的<code>path</code>一定要是绝对路径；<br>3.<code>libraryTarget</code>设为<code>umd</code>以兼容浏览器和commonjs环境；<br>4.webpack 4新引入了<code>mode</code>配置，会自动做一些优化，可以为<code>development</code>或<code>production</code>，不能省略<code>mode</code>的配置；<br>5.<code>mode</code>为<code>development</code>时，HotModuleReplacementPlugin不是默认载入的，所以为了使开发时候能够热替换，需要手动加上这个配置；</p>
<h1 id="配置babel"><a href="#配置babel" class="headerlink" title="配置babel"></a>配置babel</h1><p>babel负责将高语言特性JS源代码转译为低语言特性JS代码，以兼容低版本浏览器，当前推荐采用<code>babel-preset-env</code>，它能根据要兼容的浏览器版本，有选择性地转译，而不是像以前一样统统转译为ES5。</p>
<p>使用以下命令安装babel以及配套工具：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-core babel-preset-env babel-loader</div></pre></td></tr></table></figure>
<p><code>.babelrc</code>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;ie 11&quot;]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置eslint和prettier"><a href="#配置eslint和prettier" class="headerlink" title="配置eslint和prettier"></a>配置eslint和prettier</h1><p>eslint能够检查源代码中的格式错误以及少量的语法错误，prettier是用来自动地格式化代码。它们的主要区别在于，eslint主要用来检查代码格式，prettier主要用来修复代码格式。虽然<code>eslint --fix</code>也能自动修复一些格式错误，但只能修复少数几种格式错误，功能十分有限。prettier的格式修复功能很强，但是如果代码中有错误，例如有尾逗号、引用未知变量，prettier不管这些，仍然帮你格式化，这就让你很难提早发现代码中的错误。</p>
<p>eslint和prettier相爱相杀，让它们和谐相处，才能更好地为我们提供服务。总体思想是eslint的检查规则尽量与prettier的格式规则保持一致，代码先用prettier格式化之后再用<code>eslint --fix</code>修复并检查。</p>
<p>需要先安装一下几个包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev eslint prettier eslint-config-prettier eslint-plugin-prettier prettier-eslint-cli</div></pre></td></tr></table></figure>
<p><code>eslint-config-prettier</code>是用来将prettier的格式化规则作为eslint的检查规则，<code>eslint-plugin-prettier</code>则是用来对比prettier格式化前后，代码中出现的错误。<code>prettier-eslint-cli</code>是用来依次执行prettier和<code>eslint --fix</code>，自动格式化代码。</p>
<p><code>.eslintrc</code>的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;env&quot;: &#123;</div><div class="line">    &quot;browser&quot;: true,</div><div class="line">    &quot;es6&quot;: true</div><div class="line">  &#125;,</div><div class="line">  &quot;parserOptions&quot;: &#123;</div><div class="line">    &quot;sourceType&quot;: &quot;module&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;extends&quot;: [&quot;prettier&quot;],</div><div class="line">  &quot;plugins&quot;: [&quot;prettier&quot;],</div><div class="line">  &quot;rules&quot;: &#123; &quot;prettier/prettier&quot;: &quot;error&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>需要指出的是如果使用了ES6的<code>import</code>和<code>export</code>，则需要配置<code>&quot;sourceType&quot;: &quot;module&quot;</code>。</p>
<p>我是无分号党，<code>.prettierrc</code>配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;singleQuote&quot;: true,</div><div class="line">  &quot;semi&quot;: false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置-gitignore"><a href="#配置-gitignore" class="headerlink" title="配置.gitignore"></a>配置.gitignore</h1><p><code>.gitignore</code>用来排除不需要git管理的文件，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.DS_Store</div><div class="line">node_modules/</div><div class="line">dist/</div><div class="line">npm-debug.log*</div><div class="line">yarn-debug.log*</div><div class="line">yarn-error.log*</div><div class="line"></div><div class="line"># Editor directories and files</div><div class="line">.idea</div><div class="line">.vscode</div><div class="line">*.suo</div><div class="line">*.ntvs*</div><div class="line">*.njsproj</div><div class="line">*.sln</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>配置一个Library开发环境，分为生成package.json、规划目录结构、配置webpack、配置babel、配置eslint和prettier、配置.gitignore几个步骤。本文仅仅是流水账记录，深度不够，写到后面我都觉得乏味了，以后不写这种水文章了，匿了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;知乎上有个提问，叫“如何成为高级Webpack配置工程师”，戏谑Webpack已经复杂到成为一门专业学问了。但Webpack确实是非常复杂的，一般人只能做到入门而无法精通。Webpack的复杂性在于要完成各种各样的功能，即不仅要处理js、css、html、图片、字体等各种格
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用pkg打包Node.js应用</title>
    <link href="https://jingsam.github.io/2018/03/02/pkg.html"/>
    <id>https://jingsam.github.io/2018/03/02/pkg.html</id>
    <published>2018-03-02T03:23:39.000Z</published>
    <updated>2018-03-07T04:04:59.529Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js应用不需要经过编译过程，可以直接把源代码拷贝到部署机上执行，确实比C++、Java这类编译型应用部署方便。然而，Node.js应用执行需要有运行环境，意味着你需要先在部署机器上安装Node.js。虽说没有麻烦到哪里去，但毕竟多了一个步骤，特别是对于离线环境下的部署机，麻烦程度还要上升一级。假设你用Node.js写一些小的桌面级工具软件，部署到客户机上还要先安装Node.js，有点“大炮打蚊子”的感觉。更严重的是，如果部署机器上游多个Node.js应用，而且这些应用要依赖于不同的Node.js版本，那就更难部署了。</p>
<p>理想的情况是将Node.js打包为一个单独的可执行文件，部署的时候直接拷贝过去就行了。除了部署方便外，因为不需要再拷贝源代码了，还有利于保护知识产权。</p>
<p>将Node.js打包为可执行文件的工具有pkg、nexe、node-packer、enclose等，从打包速度、使用便捷程度、功能完整性来说，pkg是最优秀的。这篇文章就来讲一讲半年来我使用pkg打包Node.js应用的一些经验。</p>
<p>pkg的打包原理简单来说，就是将js代码以及相关的资源文件打包到可执行文件中，然后劫持<code>fs</code>里面的一些函数，使它能够读到可执行文件中的代码和资源文件。例如，原来的<code>require(&#39;./a.js&#39;)</code>会被劫持到一个虚拟目录<code>require(&#39;/snapshot/a.js&#39;)</code>。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>pkg既可以全局安装也可以局部安装，推荐采用局部安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install pkg --save-dev</div></pre></td></tr></table></figure>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>pkg使用比较简单，执行下<code>pkg -h</code>就可以基本了解用法，基本语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pkg [options] &lt;input&gt;</div></pre></td></tr></table></figure>
<p><code>&lt;input&gt;</code>可以通过三种方式指定：</p>
<p>1.一个脚本文件，例如<code>pkg index.js</code>;<br>2.<code>package.json</code>，例如<code>pkg package.json</code>，这时会使用<code>package.json</code>中的<code>bin</code>字段作为入口文件；<br>3.一个目录，例如<code>pkg .</code>，这时会寻找指定目录下的<code>package.json</code>文件，然后在找<code>bin</code>字段作为入口文件。</p>
<p><code>[options]</code>中可以指定打包的参数：<br>1.<code>-t</code>指定打包的目标平台和Node版本，如<code>-t node6-win-x64,node6-linux-x64,node6-macos-x64</code>可以同时打包3个平台的可执行程序；<br>2.<code>-o</code>指定输出可执行文件的名称，但如果用<code>-t</code>指定了多个目标，那么就要用<code>--out-path</code>指定输出的目录；<br>3.<code>-c</code>指定一个JSON配置文件，用来指定需要额外打包脚本和资源文件，通常使用<code>package.json</code>配置。</p>
<p>使用pkg的最佳实践是：在<code>package.json</code>中的<code>pkg</code>字段中指定打包参数，使用<code>npm scripts</code>来执行打包过程，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  &quot;bin&quot;: &quot;./bin/www&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;pkg&quot;: &quot;pkg . --out-path=dist/&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;pkg&quot;: &#123;</div><div class="line">    &quot;scripts&quot;: [...]</div><div class="line">    &quot;assets&quot;: [...],</div><div class="line">    &quot;targets&quot;: [...]</div><div class="line">  &#125;,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>scripts</code>和<code>assets</code>用来配置未打包进可执行文件的脚本和资源文件，文件路径可以使用glob通配符。这里就浮现出一个问题：为什么有的脚本和资源文件打包不进去呢？</p>
<p>要回答这个问题，就涉及到pkg打包文件的机制。按照pkg文档的说法，pkg只会自动地打包相对于<code>__dirname</code>、<code>__filename</code>的文件，例如<code>path.join(__dirname, &#39;../path/to/asset&#39;)</code>。至于<code>require()</code>，因为require本身就是相对于<code>__dirname</code>的，所以能够自动打包。假设文件中有以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">require(&apos;./build/&apos; + cmd + &apos;.js&apos;)</div><div class="line">path.join(__dirname, &apos;views/&apos; + viewName)</div></pre></td></tr></table></figure>
<p>这些路径都不是常量，pkg没办法帮你自动识别要打包哪个文件，所以文件就丢失了，所以这时候就使用<code>scripts</code>和<code>assets</code>来告诉pkg，这些文件要打包进去。那么我们怎么知道哪些文件没有被打包呢？难倒要一行行地去翻源代码吗？其实很简单，只需要把打包好的文件运行下，报错信息一般就会告诉你缺失哪些文件，并且pkg在打包过程中也会提示一些它不能自动打包的文件。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>如果说pkg还有哪儿还可以改进的地方，那就是无法自动打包二进制模块<code>*.node</code>文件。如果你的项目中引用了二进制模块，如sqlite3，那么你需要手动地将<code>*.node</code>文件复制到可执行文件同一目录，我通常使用命令<code>cp node_modules/**/*.node .</code>一键完成。但是，如果你要跨平台打包，例如在windows上打包linux版本，相应的二进制模块也要换成linux版本，通常需要你手动的下载或者编译。</p>
<p>那为什么pkg不能将二进制模块打包进去呢？我猜想是require载入一个js文件和node文件，它们的机制是不一样的。另外从设计来说，不自动打包二进制模块也是合理的，因为二进制模块都是平台相关的。如果我在windows上生成一个linux文件，那么就需要拉取linux版本的<code>.node</code>文件，这是比较困难的。并且有些二进制模块不提供预编译版本，需要安装的时候编译，pkg再牛也不可能模拟一个其他平台的编译环境吧。nexe可以自动打包二进制模块，但是只能打包当前平台和当前版本的可执行文件。这意味着如果Node.js应用引用了二进制包，那么这个应用就不能跨平台打包了，所以我认为这方面，nexe不能算是一个好的设计。</p>
<p>还有一点就是关于项目中的配置文件处理，比如数据库连接参数、环境变量等。因为这些配置文件会跟着不同的部署环境进行更改，所以为了方便更改，一般不希望把配置文件打包到exe。为了避免pkg自动地将配置文件打包到exe中，代码中不要采用以下方式读取配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.readFile(path.join(__dirname, &apos;./config.json&apos;)), callback)</div></pre></td></tr></table></figure>
<p>而是采用相对于<code>process.CWD()</code>的方法读取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.readFile(path.join(process.CWD(), &apos;./config.json&apos;), callback)</div><div class="line"></div><div class="line">// 或者</div><div class="line">fs.readFile(&apos;./config.json&apos;, callback)</div></pre></td></tr></table></figure>
<p>如果配置文件是js格式的，那么不要直接<code>require(&#39;./config&#39;)</code>，而是采用动态require：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const config = require(process.CWD() + &apos;./config&apos;)</div></pre></td></tr></table></figure>
<p>另外要提及的是pkg打包之后动态载入js文件会有安全性问题，即用户可以在js文件写任何处理逻辑，注入到打包后的exe中。例如，可以读取exe里面的虚拟文件系统，把源代码导出来。所以，尽量不要采用JS作为配置文件，也不要动态载入js模块。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js应用不需要经过编译过程，可以直接把源代码拷贝到部署机上执行，确实比C++、Java这类编译型应用部署方便。然而，Node.js应用执行需要有运行环境，意味着你需要先在部署机器上安装Node.js。虽说没有麻烦到哪里去，但毕竟多了一个步骤，特别是对于离线环境下的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《ThinkPad之道》书评</title>
    <link href="https://jingsam.github.io/2018/02/27/thinkpad.html"/>
    <id>https://jingsam.github.io/2018/02/27/thinkpad.html</id>
    <published>2018-02-27T03:27:47.000Z</published>
    <updated>2018-02-27T08:46:47.770Z</updated>
    
    <content type="html"><![CDATA[<p>最近在西西弗书店断断续续地读完了《ThinkPad之道》这本书，本书讲的是“Thinkpad之父”内藤在正和他所领导的大和实验室，在研发ThinkPad系列笔记本电脑的过程所面临的种种困难和压力，最终成就了一款经典产品。</p>
<p>本人大学期间拆装过无数笔记本电脑，自认为笔记本电脑没什么技术含量，无非就是几个零件组装起来。记得有一次拆装一个ThinkPad电脑，每次复原后总是会多出来几个螺丝，神奇的是每次电脑都能正常开机。心中不免有些疑惑，明明可以用更少的螺丝，为什么还要用那么多螺丝呢？看了这本书之后，明白了这些多余的螺丝，是为了保证ThinkPad在任何环境下都能正常使用。</p>
<p>ThinkPad起初是给哈佛商学院的学生使用的，后来才逐步拓展到其他大学和商务市场。刚开始时，ThinkPad在大学的故障率非常高，甚至需要专门在大学建立售后服务中心，应对大学生笔记本返修问题。内藤在正通过在大学中实地调研，发现大学生对ThinkPad的折磨程度超过了他的想象。例如，大学生会把装着ThinkPad的书包垫在台阶上，直接坐上去，由于小红点和屏幕只有2毫米的间隙，过重的压力会导致屏幕破裂；也会将ThinkPad放入装有十几公斤书本的书包中，骑着单车，让ThinkPad随意地翻滚；甚至在嬉戏玩耍的时候，将装有ThinkPad的书包扔来扔去。</p>
<p>为了让ThinkPad能够承受住大学生的“折磨”，大和实验室专门成立了测试ThinkPad承受能力的“酷刑室”。例如，有将笔记本开合一万次的仪器，用来测试笔记本铰链的质量；有将笔记本放在一个满是灰尘的空间中，看能不能正常使用；有将各种牛奶、果汁泼溅到笔记本键盘上，模拟使用时有液体溅入的场景。</p>
<p>最终，他们克服了种种困难，让ThinkPad成为了“稳定、可靠、质量”的代名词。靠着优秀的品质，ThinkPad进入过太空，深入过雨林，攀登过珠峰，游历过纳米比亚沙漠。</p>
<p>内藤在正和他的团队持续不断地对ThinkPad的改进，是一个典型的工匠精神的体现。然而，这么优秀的ThinkPad，为什么会被IBM卖给联想呢？因为IBM的PC部门一直在亏损。而且，生产核心器件如CPU、硬盘存储、屏幕的部门早已变卖，所以IBM认为PC这条产品线已经没有了核心竞争力，利润提不上去，卖给联想是明智的选择。</p>
<p>ThinkPad转手给联想之后，联想保留了日本大和实验室和美国罗利实验室，可以说保存了ThinkPad的核心团队。从我的观察来看，联想接手ThinkPad之后，一个主要的贡献是让人人都能用得起“小黑”（ThinkPad）。曾几何时，“小黑”是和“小白”（MacBook）一级的高端电脑，动辄几万块，一般人用不起。ThinkPad的质量确实好，大和实验室想尽千万种方法，提高ThinkPad的可靠性。这种不断进取的工匠精神从一些方面是好的，然而也带来了一些弊端。内藤在正也承认，他们可以在某一方面的技术做好精益求精，但是缺少宏观的视野，即所谓的“见木不见林”。不断地提高ThinkPad的可靠性，一方面这些可靠性需要有额外的零部件和加工方法支撑，因而增加了成本，导致ThinkPad的售价居高不下；另一方面，这些可靠性有些过度了，毕竟不是每台ThinkPad都是要“上刀山下火海”的。联想接手后，降低ThinkPad的成本，扩宽ThinkPad的价格范围，进军个人和家庭消费市场。现在，一个普通大学生拿4000块钱也可以买得到ThinkPad，真正让人人都用得起ThinkPad。</p>
<p>有段时间，ThinkPad的老用户抱怨，现在的“小黑”已经不是原来的“小黑”，话语中透露出失望的语气。但是，我认为“小黑”的精神没有丢，高端的ThinkPad产品仍然可靠，而中低端的ThinkPad产品也有着“小黑”的影子。现在无处不在的ThinkPad表明，ThinkPad在联想的经营下，焕发了新的活力。</p>
<p>ThinkPad的经历，不禁让我思考，到底什么才是好的产品？IBM时代的ThinkPad，可靠耐用，从技术上说是好的产品，但从商业角度和消费者的角度来说，不是好的产品，因为价格太贵了。联想时代的ThinkPad，牺牲了一些可靠性，换来了价格的降低，个人消费得起，可靠性方面也能满足日常使用，这时候ThinkPad才成为了好的产品。</p>
<p>本人同为技术人员，遇到挑战往往有一股狠劲，不解决不罢休，但容易钻牛角尖，缺乏大局观。现实世界的问题，不是都能靠技术来解决的。一款好的产品，不见得需要技术上先进，关键是要让消费者以可接受的价格满足他们的需求。所以，不能埋头只做技术，要倾听消费者的意见、进行商业上的考量、做技术上的取舍，这样才能做出好的产品。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在西西弗书店断断续续地读完了《ThinkPad之道》这本书，本书讲的是“Thinkpad之父”内藤在正和他所领导的大和实验室，在研发ThinkPad系列笔记本电脑的过程所面临的种种困难和压力，最终成就了一款经典产品。&lt;/p&gt;
&lt;p&gt;本人大学期间拆装过无数笔记本电脑，自认
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2018计划</title>
    <link href="https://jingsam.github.io/2018/02/26/2018-plan.html"/>
    <id>https://jingsam.github.io/2018/02/26/2018-plan.html</id>
    <published>2018-02-26T02:10:28.000Z</published>
    <updated>2018-02-26T03:38:18.416Z</updated>
    
    <content type="html"><![CDATA[<p>过去一年，发现自己越来越难以下笔写东西，原因是身体和思想上的双重懒惰。常常是心中拟定了很多写作的题目，而到要下笔写的时候，总是觉得我对这个主题研究还不够深入全面，然后就默默地为自己找到一个借口：“等我把这个研究透之后再下笔写”，最终就不了了之了。</p>
<p>博文对于我而言，是一种对技术的总结和沉淀。回望2017，自己的博文写得很少，心中很是失落。失落在于自己的心太浮躁，对技术没有进行总结和沉淀。</p>
<p>我下决心在2018年要多写文章，在此立下flag：“2018年每月要产出4篇文章，全年要有48篇文章上线”。要实现这个目标，首先“等我把这个研究透之后再下笔写”这种借口就不成立了，想到某个主题直接写就是了，深度不够？再来一篇。其二，时间上要保障，自己要把逛社交网站、看新闻的时间，抽出来作为写作的时间。三是注意力要集中，不能什么技术研究到一半，注意力又转移到其他技术上了。</p>
<p>关于写作的主题范围，主要还是矢量瓦片方面的技术，包括mapbox-gl-js、矢量切片工具、矢量瓦片服务以及矢量瓦片在时空大数据可视化方面的应用。</p>
<p>关于个人的技术成长，总来的说，要强核心、补短板、宽视野。“强核心”是要强化自己在在线制图和大数据可视化方面的积累，这是自己的核心竞争力，看家老本不能丢。“补短板”是补全自己在Web开发方面的不足，主要是CSS、WebGL以及对MVVM模式的认识，这方面需要自己系统地阅读书籍以及流行库的源代码。“宽视野”是要扩大自己的技术范围，自己不能局限于某一项技术上，要广泛涉猎，知道各项技术的原理，能够敏锐地察觉到某项技在地理信息中的应用前景。</p>
<p>最后，以上的目标要实现的前提是，自己要加强时间的管理。过去的一年，自己没闲着，一直在忙项目上的事情。但从心底来说，对于去年自己的成果，不甚满意，我认为本来还可以完成更多事情。究其原因，自己在时间的安排、任务优先级的把控方面很是不足。所以，今年迫切要改掉坏习惯，把自己的时间规划好。具体做法还是多动笔杆子，把自己的计划事项写下来，这样自己才能不断地排优先级、做计划、实施以及最后的回顾。</p>
<p>总而言之，“凡事预则立，不预则废”。2018，我要做一个有计划的人。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过去一年，发现自己越来越难以下笔写东西，原因是身体和思想上的双重懒惰。常常是心中拟定了很多写作的题目，而到要下笔写的时候，总是觉得我对这个主题研究还不够深入全面，然后就默默地为自己找到一个借口：“等我把这个研究透之后再下笔写”，最终就不了了之了。&lt;/p&gt;
&lt;p&gt;博文对于我而
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mapbox-gl-js接入GeoJSON大文件的优化策略</title>
    <link href="https://jingsam.github.io/2017/10/23/large-geojson-with-mapbox-gl-js.html"/>
    <id>https://jingsam.github.io/2017/10/23/large-geojson-with-mapbox-gl-js.html</id>
    <published>2017-10-23T01:35:06.000Z</published>
    <updated>2017-11-02T02:33:34.105Z</updated>
    
    <content type="html"><![CDATA[<p>mapbox-gl-js可以接受GeoJSON数据，在前端动态地绘制GeoJSON数据。需要说明的是，mapbox-gl-js并不能直接渲染GeoJSON数据，而是通过<code>geojson-vt</code>这个库，在前端动态地将GeoJSON数据转换为矢量瓦片后渲染。至于为什么不支持直接渲染GeoJSON数据，我猜想是因为mapbox-gl-js对于点、线、面、符号、注记等要素的绘制规则都是基于矢量瓦片的，为GeoJSON另外实现一套绘制规则，不仅增大了实现成本，而且两套规则可能会出现冲突。</p>
<p>传统的矢量数据需要预先切片、存储、发布服务，并且当数据更新时又得重新切片，对于小项目来说有点大炮打蚊子的感觉。GeoJSON数据源的好处是接入容易、更新方便，并且市面上有很多工具可以将各种矢量数据转换为GeoJSON格式。</p>
<p>通常来说，GeoJSON数据源适合于少量的矢量数据，大批量的矢量数据最好还是预先切片。但多少数据算是”少量数据呢“？从经验上讲，应该将GeoJSON数据控制在20M以下。需要说明的是，之所以提出”20M“这个经验值，并不是因为mapbox-gl-js对于渲染超过20M的GeoJOSN数据有困难，而是综合考虑网络请求时间和解析数据的时间。实际上，mapbox-gl-js处理100M的GeoJSON数据都没有什么问题，但是把大量的GeoJSON数据整体请求过来所产生的耗时，会严重影响用户体验。所以对于大量的GeoJSON数据，最好预先切片，这样前端可以分块请求，减少网络请求时间和解析数据的时间。</p>
<p>虽然使用GeoJSON大文件作为数据源不是最佳选择，但有些情况下我们不得不使用GeoJSON作为数据源，例如数据是由第三方通过API提供的、数据是实时更新的。当接入大GeoJSON数据时，我们可以通过以下几种优化策略，提高地图绘制的效率。</p>
<h1 id="使用cluster选项"><a href="#使用cluster选项" class="headerlink" title="使用cluster选项"></a>使用cluster选项</h1><p>如果需要接入的数据是点数据，并且十分密集，这时应该对点进行聚合。特别密集的点在小缩放级别会重叠在一起，造成注记压盖叠加，可视化效果不好。使用聚合后，小的缩放级别显示聚合数据，大的缩放级别显示原始数据，兼顾了综合和细节。并且，聚合减少了单张瓦片的数据量，使得引擎绘制更快，交互更流畅。</p>
<p>mapbox-gl-js是通过<code>supercluster</code>这个库对GeoJSON数据进行聚合。其原理是两个点的显示距离小于聚合半径时，聚合为一个点要素，这个点会有一个<code>point_count</code>字段记录聚合的点的数目。需要注意的是，并不是每个层级上所有的点都被聚合，有些孤立的点会保留原位。那么如何区分聚合的和未聚合的点要素呢？可以使用有没有<code>point_cluster</code>进行判断，即使用<code>&quot;filter&quot;: [&quot;has&quot;, &quot;point_count&quot;]</code>过滤出聚合的点要素，使用<code>&quot;filter&quot;: [&quot;!has&quot;, &quot;point_count&quot;]</code>过滤出未聚合的点要素。</p>
<p>mapbox-gl-js通过<code>cluster</code>、<code>clusterRadius</code>、<code>clusterMaxZoom</code>三个参数控制点聚合的效果，并且是要在<code>source</code>里面配置。从逻辑上讲，这三个是控制聚合的效果的，应该放到<code>layer</code>上更符合直觉。然而，mapbox-gl-js的聚合过程并不是在渲染层实现的，而是在数据层实现的，即在动态切片的时候对数据做了聚合操作。所以，从实现角度来讲，将聚合控制参数放在<code>source</code>是合情合理的。以下是这三个参数的说明：</p>
<ul>
<li><code>cluster</code>：设为<code>true</code>开启GeoJSON数据聚合，只对点数据有效；</li>
<li><code>clusterRaius</code>：聚合半径，默认为50像素。当你发现有很多点没有被聚合时，可以适当调大这个参数；</li>
<li><code>clusterMaxZoom</code>：聚合的最大层级，大于这个层级的数据不再聚合，默认值是<code>maxzoom - 1</code>。</li>
</ul>
<h1 id="减小buffer"><a href="#减小buffer" class="headerlink" title="减小buffer"></a>减小buffer</h1><p>矢量瓦片一般会向边界外围扩张一定距离，作为缓冲区，以免边界上的接边要素出现断开的现象。缓冲区越大，出现断裂的可能性越小，但同时导致每张瓦片的尺寸变大，渲染的效率也更低。可以适当减小缓冲区的大小，减小瓦片的额体积，提高渲染效率。</p>
<p><code>buffer</code>的默认值是128像素，能够应付大部分情况。当GeoJSON是点数据，并且用来渲染点要素的符号和注记文本宽度比较小时，可以尝试将<code>buffer</code>设置为0或者稍大的值。</p>
<h1 id="减小maxzoom"><a href="#减小maxzoom" class="headerlink" title="减小maxzoom"></a>减小maxzoom</h1><p><code>maxzoom</code>用来控制将GeoJSON数据切割成矢量瓦片的最大级别，默认值是18级。减小<code>maxzoom</code>，可以加快切片的速度。一般来说，切割到12级，可以保证一定的精度和速度，满足大部分应用需求。</p>
<h1 id="对数据进行minify"><a href="#对数据进行minify" class="headerlink" title="对数据进行minify"></a>对数据进行minify</h1><p>对GeoJSON数据进行minify，即移除JSON中多余的空格、换行符、注释，以及减少坐标点的小数位，可以减小GeoJSON的体积，减小加载时间。</p>
<h1 id="使用URL加载数据"><a href="#使用URL加载数据" class="headerlink" title="使用URL加载数据"></a>使用URL加载数据</h1><p>使用GeoJSON作为数据源，既可以将GeoJSON数据内联到样式文件中，也可以通过URL引用。从直觉上讲，使用内联的GeoJSON不需要网络请求，应该比URL方式更快，然而并不是这样的。使用内联的方式加载大量GeoJSON数据，有以下几个弊端：</p>
<ol>
<li>使样式文件变大，增加了解析的时间；</li>
<li>内联的GeoJSON数据解析后无法释放，将会一直占用内存。</li>
</ol>
<p>因此，对于大GeoJSON数据，尽量以URL的方式加载，可以减少客户端的内存占用。</p>
<h1 id="渲染时增大minzoom"><a href="#渲染时增大minzoom" class="headerlink" title="渲染时增大minzoom"></a>渲染时增大minzoom</h1><p>在配置GeoJSON渲染图层时，默认的<code>minzoom</code>是0，可以适当增大<code>minzoom</code>。<code>geojson-vt</code>在动态切片时，默认小于5级的瓦片是按需生成，大于或等于5级是预先生成。所以，但渲染图层的<code>minzoom</code>大于等于5时，小层级的瓦片不会生成，减少了计算负担。另外，增大<code>minzoom</code>，可以在小层级不需要加载、解析、渲染瓦片，所以渲染更为流畅。</p>
<h1 id="渲染时允许符号重叠"><a href="#渲染时允许符号重叠" class="headerlink" title="渲染时允许符号重叠"></a>渲染时允许符号重叠</h1><p>在配置GeoJSON渲染图层时，可以设置允许注记符号重叠，即设置<code>icon-allow-overlap: true</code>，提高渲染的效率。</p>
<p>mapbox-gl-js在渲染注记符号和文本时，会有一个碰撞检测的过程，即当两个注记有重叠，则隐藏一个。常规条件下，这个碰撞检测很快，耗时可以忽略不计。但是，如果数据中的点非常密集，这部分耗时还是比较客观的。所以，设置<code>icon-allow-overlap: true</code>关闭这个检测过程，可以提高渲染效率。</p>
<p>当然，可以进一步设置允许注记文本也可以重叠，即设置<code>text-allow-overlap: true</code>，继续提高渲染效率。然而，从用户的角度来说，地图上出现符号重叠可以忍受，文本重叠就比较难看了。所以，一般不推荐设置允许注记文本重叠。</p>
<h1 id="对数据进行切分"><a href="#对数据进行切分" class="headerlink" title="对数据进行切分"></a>对数据进行切分</h1><p>如果GeoJSON数据实在很大，可以将GeoJSON数据切分为几块，分别加载。比如，原来是一个GeoJSON大文件，现在把它切分为两个比较小的GeoJSON文件，可以提高处理的效率，原因在于：</p>
<ol>
<li>切分的数据可以并行请求。例如，请求两个5M的数据，比单独请求一个10M的数据要快；</li>
<li><code>geojson-vt</code>处理小文件比处理大文件快。</li>
</ol>
<h1 id="预先切片"><a href="#预先切片" class="headerlink" title="预先切片"></a>预先切片</h1><p>如果GeoJSON数据太大了，比如100M，以上的种种优化方法都不可行。GeoJSON没办法增量加载，必须将完整的GeoJSON数据请求过来，才能开始处理。大的GeoJSON数据，光网络请求就会占用大量时间，所以必须预先切片，分块加载。</p>
<p>预先切片有诸多好处，如减少网络请求时间、渲染效率高。但是，预先切片需要工具切片、瓦片服务器发布服务，而且数据更新有点麻烦。到底切不切片，是动态切片还是预先切片，需要根据数据的情况来确定。</p>
<p>你可以将数据上传到Mapbox Studio进行自动切片，也可以使用开源工具<a href="https://github.com/mapbox/tippecanoe" target="_blank" rel="external">tippecanoe</a>对GeoJSON数据自行切片。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.mapbox.com/rendering-big-geodata-on-the-fly-with-geojson-vt-4e4d2a5dd1f2" target="_blank" rel="external">https://blog.mapbox.com/rendering-big-geodata-on-the-fly-with-geojson-vt-4e4d2a5dd1f2</a></li>
<li><a href="https://blog.mapbox.com/clustering-millions-of-points-on-a-map-with-supercluster-272046ec5c97" target="_blank" rel="external">https://blog.mapbox.com/clustering-millions-of-points-on-a-map-with-supercluster-272046ec5c97</a></li>
<li><a href="https://gist.github.com/ryanbaumann/2d5c851aebf46e4ef5702ee29ead6bdb" target="_blank" rel="external">https://gist.github.com/ryanbaumann/2d5c851aebf46e4ef5702ee29ead6bdb</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mapbox-gl-js可以接受GeoJSON数据，在前端动态地绘制GeoJSON数据。需要说明的是，mapbox-gl-js并不能直接渲染GeoJSON数据，而是通过&lt;code&gt;geojson-vt&lt;/code&gt;这个库，在前端动态地将GeoJSON数据转换为矢量瓦片后渲染
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mapbox-gl如何高效地高亮要素</title>
    <link href="https://jingsam.github.io/2017/10/20/mapbox-gl-highlight.html"/>
    <id>https://jingsam.github.io/2017/10/20/mapbox-gl-highlight.html</id>
    <published>2017-10-20T00:42:01.000Z</published>
    <updated>2017-10-20T08:46:42.451Z</updated>
    
    <content type="html"><![CDATA[<p>mapbox-gl基于矢量瓦片的前端渲染技术，使得要素高亮变得简单。要素高亮具体如何实现，有如下三种方法：</p>
<h1 id="第一种：动态过滤"><a href="#第一种：动态过滤" class="headerlink" title="第一种：动态过滤"></a>第一种：动态过滤</h1><p>这种方法的基本思路是添加一个高亮图层，然后根据鼠标hover的要素id，动态地改变filter条件，实现要素的高亮。</p>
<p>使用到的主要接口是<code>map.on(&#39;mousemove&#39;, layer, e)</code>，其中<code>e</code>可以获取到当前鼠标位置的features，效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/f3au0qLo/4/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试中发现，在图斑比较密集的情况下，高亮非常卡，滞后严重，效率并不高。</p>
<h1 id="第二种：数据源镜像"><a href="#第二种：数据源镜像" class="headerlink" title="第二种：数据源镜像"></a>第二种：数据源镜像</h1><p>第二种方法是对第一种方法的改进，思路如下：对原始数据源做一个镜像，即添加一个新的数据源，名称不通但指向的是同一套数据,例如下面示例中的<code>source-mirror</code>，高亮图层的数据源指向<code>source-mirror</code>。改进后的效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/rj16bqa4/4/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试可以发现，稍微改进一下，高亮的效率提升很大。</p>
<p>但为什么做一个数据源镜像就可以显著地提高高亮的效率呢？我猜想是mapbox-gl在绘制时，会按照数据源对图层分组。指向同一个数据源的图层组中，任意一个图层的渲染条件改变，将会以整个图层组为粒度重新进行运算。在第一种方法中，高亮图层和其他图层都指向同一个数据源，动态地改变高亮图层的过滤条件，导致了很大的运算开销。而第二种方法，为高亮图层单独分配一个数据源，动态地改变高亮图层的过滤条件，也只会导致高亮图层的重绘。</p>
<h1 id="第三种：动态生成高亮数据源"><a href="#第三种：动态生成高亮数据源" class="headerlink" title="第三种：动态生成高亮数据源"></a>第三种：动态生成高亮数据源</h1><p>我们能不能再进一步提高高亮的效率呢？有。第三种方法的思路是：为高亮图层生成一个空的GeoJSON数据源，然后将鼠标hover到的要素动态地填充到数据源中。</p>
<p>使用的接口只要是<code>map.getSource(source).setData(geojson)</code>，其中<code>getSource</code>用于根据sourceId获取数据源，<code>setData</code>用于动态更新数据。效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/ykoyet0w/4/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试可以发现，这种方法甚至比第二种方法效率更高。原因在于要高亮的要素往往很小，前段切成瓦片可能就一两张，因此不用去整体从原始数据源的瓦片种过滤，效率会更高。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一种方法最常用，小批量数据效率还行，但涉及到大数据量情况下，效率就不太理想了。</p>
<p>第二种方法通过小小的改进，就可以极大地提高效率，实现起来也很简单。</p>
<p>第三种方法效率最高，但其中引入了<code>turf.union</code>去合并features，带来了额外的依赖。因此，从简单和优雅的角度来说，我更推荐使用第二种方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mapbox-gl基于矢量瓦片的前端渲染技术，使得要素高亮变得简单。要素高亮具体如何实现，有如下三种方法：&lt;/p&gt;
&lt;h1 id=&quot;第一种：动态过滤&quot;&gt;&lt;a href=&quot;#第一种：动态过滤&quot; class=&quot;headerlink&quot; title=&quot;第一种：动态过滤&quot;&gt;&lt;/a&gt;第
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker save与docker export的区别</title>
    <link href="https://jingsam.github.io/2017/08/26/docker-save-and-docker-export.html"/>
    <id>https://jingsam.github.io/2017/08/26/docker-save-and-docker-export.html</id>
    <published>2017-08-26T06:24:00.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有写博客了，坟头草都长了老高了。写博客要靠惯性，一旦停下来时间长了，就很难再坚持下去。今天艰难地捡起来，以后每周至少写一篇。</p>
<p>这篇文章讲一讲docker save和docker export的区别。</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>docker save和docker export都能导出镜像包，咋看起来区别似乎不大。本文就针对这个问题，试图搞清楚docker save和docker export的功能是什么？适用于什么应用场景？</p>
<p>本文的测试的Docker版本如下，不保证所有版本的docker都能重现本文的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;docker version</div><div class="line"></div><div class="line">Client:</div><div class="line"> Version:      17.07.0-ce-rc1</div><div class="line"> API version:  1.31</div><div class="line"> Go version:   go1.8.3</div><div class="line"> Git commit:   8c4be39</div><div class="line"> Built:        Wed Jul 26 05:19:44 2017</div><div class="line"> OS/Arch:      windows/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line"> Version:      17.07.0-ce-rc1</div><div class="line"> API version:  1.31 (minimum version 1.12)</div><div class="line"> Go version:   go1.8.3</div><div class="line"> Git commit:   8c4be39</div><div class="line"> Built:        Wed Jul 26 05:25:01 2017</div><div class="line"> OS/Arch:      linux/amd64</div><div class="line"> Experimental: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>另外我是在Windows on bash里面操作docker，有些命令如<code>ls</code>并不是windows命令，如果想要复现我的试验，请换成相应的windows命令。</p>
<h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p>docker的命令行接口设计得很优雅，很多命令的帮助直接在后面加<code>--help</code>就可以查看。</p>
<p>docker save的帮助如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker save --<span class="built_in">help</span></div><div class="line"></div><div class="line">Usage:  docker save [OPTIONS] IMAGE [IMAGE...]</div><div class="line"></div><div class="line">Save one or more images to a tar archive (streamed to STDOUT by default)</div><div class="line"></div><div class="line">Options:</div><div class="line">      --<span class="built_in">help</span>            Print usage</div><div class="line">  -o, --output string   Write to a file, instead of STDOUT</div></pre></td></tr></table></figure></p>
<p>从命令行帮助可以看出，docker save是用来将一个或多个image打包保存的工具。</p>
<p>例如我们想将镜像库中的postgres和mongo打包，那么可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save -o images.tar postgres:9.6 mongo:3.4</div></pre></td></tr></table></figure></p>
<p>打包之后的<code>images.tar</code>包含<code>postgres:9.6</code>和<code>mongo:3.4</code>这两个镜像。</p>
<p>虽然命令行参数要求指定image，实际上也可以对container进行打包，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</div><div class="line">3623943d369f        postgres:9.6        <span class="string">"docker-entrypoint..."</span>   3 hours ago         Up 3 hours          5432/tcp            postgres</div><div class="line"></div><div class="line">&gt;docker save -o b.tar postgres</div><div class="line">&gt;docker save -o c.tar postgres:9.6</div><div class="line">&gt;ls -al</div><div class="line">-rwxrwxrwx 1 root root 277886464 8月  26 14:40 b.tar</div><div class="line">-rwxrwxrwx 1 root root 277886464 8月  26 14:41 c.tar</div></pre></td></tr></table></figure></p>
<p>通过以上命令可以看到，<code>b.tar</code>和<code>c.tar</code>是完全一模一样的。这说明，docker save如果指定的是container，docker save将保存的是容器背后的image。</p>
<p>将打包后的镜像载入进来使用docker load，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker load -i images.tar</div></pre></td></tr></table></figure></p>
<p>上述命令将会把<code>postgres:9.6</code>和<code>mongo:3.4</code>载入进来，如果本地镜像库已经存在这两个镜像，将会被覆盖。</p>
<p>docker save的应用场景是，如果你的应用是使用docker-compose.yml编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用docker save将用到的镜像打个包，然后拷贝到客户服务器上使用docker load载入。</p>
<h2 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export"></a>docker export</h2><p>照例查看下docker export的帮助：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker export --help</div><div class="line"></div><div class="line">Usage:  docker export [OPTIONS] CONTAINER</div><div class="line"></div><div class="line">Export a container&apos;s filesystem as a tar archive</div><div class="line"></div><div class="line">Options:</div><div class="line">      --help            Print usage</div><div class="line">  -o, --output string   Write to a file, instead of STDOUT</div></pre></td></tr></table></figure></p>
<p>从帮助可以看出，docker export是用来将container的文件系统进行打包的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export -o postgres-export.tar postgres</div></pre></td></tr></table></figure></p>
<p>docker export需要指定container，不能像docker save那样指定image或container都可以。</p>
<p>将打包的container载入进来使用docker import，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import postgres-export.tar postgres:latest</div></pre></td></tr></table></figure></p>
<p>从上面的命令可以看出，docker import将container导入后会成为一个image，而不是恢复为一个container。</p>
<p>另外一点是，docker import可以指定IMAGE[:TAG]，说明我们可以为镜像指定新名称。如果本地镜像库中已经存在同名的镜像，则原有镜像的名称将会被剥夺，赋给新的镜像。原有镜像将成为孤魂野鬼，只能通过IMAGE ID进行操作。</p>
<p>docker export的应用场景主要用来制作基础镜像，比如你从一个ubuntu镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p>
<h2 id="docker-save和docker-export的区别"><a href="#docker-save和docker-export的区别" class="headerlink" title="docker save和docker export的区别"></a>docker save和docker export的区别</h2><p>总结一下docker save和docker export的区别：</p>
<ol>
<li>docker save保存的是镜像（image），docker export保存的是容器（container）；</li>
<li>docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；</li>
<li>docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。</li>
</ol>
<h2 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h2><p>前面所讲的内容都是些基础知识，相信各位读者只要仔细看下官方文档就能知晓。这一节我来讲讲文档上没有的东西。</p>
<p>docker load和docker import都可以将tar包导入为镜像，我不禁脑洞一下，docker load能不能导入docker export的容器包，docker import能不能导入docker save的镜像包呢？</p>
<p>以下开始试验，准备以下两个文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;ls -al</div><div class="line">-rwxrwxrwx 1 root root 271760384 8月  26 12:15 postgres-export.tar</div><div class="line">-rwxrwxrwx 1 root root 398292480 8月  26 12:13 postgres-save.tar</div></pre></td></tr></table></figure></p>
<p>其中<code>postgres-export.tar</code>是通过docker export导出的容器包，<code>postgres-save.tar</code>是通过docker save保存的镜像包，两者都是基于<code>postgres:9.6</code>镜像。从文件大小可以直观的发现，<code>postgres-export.tar</code>显然要比<code>postgres-save.tar</code>小100多M。</p>
<p>现在试试docker load容器包<code>postgres-export.tar</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;docker load -i postgres-export.tar</div><div class="line">open /var/lib/docker/tmp/docker-import-082344818/bin/json: no such file or directory</div></pre></td></tr></table></figure></p>
<p>显然，docker load不能载入容器包。</p>
<p>那么，反过来，docker import载入镜像包可不可以呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;docker import postgres-save.tar postgres</div><div class="line">sha256:8910feec1ee2fac8c152dbdd0aaab360ba0b833af5c3ad59fcd648b9a24d4838</div><div class="line">&gt;docker image ls</div><div class="line">REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">postgres                                        latest              8910feec1ee2        2 minutes ago       398MB</div></pre></td></tr></table></figure></p>
<p>WTF，竟然成功了！！！</p>
<p>莫慌，再试试启动一个postgres容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;docker run postgres</div><div class="line">C:\Program Files\Docker\Docker\resources\bin\docker.exe: Error response from daemon: No command specified.</div><div class="line">See &apos;C:\Program Files\Docker\Docker\resources\bin\docker.exe run --help&apos;.</div></pre></td></tr></table></figure></p>
<p>虽然能够成功地导入为一个镜像，然而这个镜像并不能使用。</p>
<p>要搞清楚到底是怎么回事，我们先看看镜像包和容器包由什么区别：</p>
<p><img src="/assets/docker-save-vs-docker-export.png" alt="docker save vs docker export"></p>
<p>从上面可以看出右边的<code>postgres-export.tar</code>的内容是一个linux系统的文件目录，猜测就是一个linux镜像。而<code>postgres-save.tar</code>里面到底是什么内容呢？点开一个文件夹看看：</p>
<p><img src="/assets/postgres-save.png" alt="postgres-save.tar"></p>
<p>其实就是一个分层的文件系统。Docker镜像实际上就是由这样的一层层文件进行叠加起来的，上层的文件会覆盖下层的同名文件。如果将<code>postgres-save.tar</code>中的各层文件合并到一起，基本就是<code>postgres-export.tar</code>的内容。由于<code>postgres-save.tar</code>里面的各层文件会存在很多重复的文件，这也解释了为什么<code>postgres-save.tar</code>会比<code>postgres-export.tar</code>大100多M。</p>
<p>docker load必须要载入的是一个分层文件系统，而<code>postgres-export.tar</code>并不具有这样的结构，因此无法载入。</p>
<p>而docker import仅仅是将tar包里面的文件复制进来，所以不管tar包里面的文件结构是怎样的，都可以载入进来，所以能够载入<code>postgres-save.tar</code>。但<code>postgres-save.tar</code>并不是一个有效的操作系统镜像，因此当我试图以改镜像启动容器时，容器并不能启动。</p>
<p>我们再来看看docker import的帮助：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Usage:  docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</div><div class="line"></div><div class="line">Import the contents from a tarball to create a filesystem image</div><div class="line"></div><div class="line">Options:</div><div class="line">  -c, --change list      Apply Dockerfile instruction to the created image</div><div class="line">      --<span class="built_in">help</span>             Print usage</div><div class="line">  -m, --message string   Set commit message <span class="keyword">for</span> imported image</div></pre></td></tr></table></figure></p>
<p>似乎和docker commit很像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</div><div class="line"></div><div class="line">Create a new image from a container<span class="string">'s changes</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">Options:</span></div><div class="line"><span class="string">  -a, --author string    Author (e.g., "John Hannibal Smith</span></div><div class="line"><span class="string">                         &lt;hannibal@a-team.com&gt;")</span></div><div class="line"><span class="string">  -c, --change list      Apply Dockerfile instruction to the created image</span></div><div class="line"><span class="string">      --help             Print usage</span></div><div class="line"><span class="string">  -m, --message string   Commit message</span></div><div class="line"><span class="string">  -p, --pause            Pause container during commit (default true)</span></div></pre></td></tr></table></figure></p>
<p>发现docker import和docker commit都有<code>--change</code>和<code>--message</code>选项。我们可以将docker import理解为将外部文件复制进来形成只有一层文件系统的镜像，而docker commit则是将当前的改动提交为一层文件系统，然后叠加到原有镜像之上。</p>
<p>关于docker save和docker export的区别讲得差不多，拜了个拜。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://docs.docker.com/engine/reference/commandline/save/" target="_blank" rel="external">docker save帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/load/" target="_blank" rel="external">docker load帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/export/" target="_blank" rel="external">docker export帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/import/" target="_blank" rel="external">docker import帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/commit/" target="_blank" rel="external">docker commit帮助文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没有写博客了，坟头草都长了老高了。写博客要靠惯性，一旦停下来时间长了，就很难再坚持下去。今天艰难地捡起来，以后每周至少写一篇。&lt;/p&gt;
&lt;p&gt;这篇文章讲一讲docker save和docker export的区别。&lt;/p&gt;
&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue之slot深度复制</title>
    <link href="https://jingsam.github.io/2017/03/08/vnode-deep-clone.html"/>
    <id>https://jingsam.github.io/2017/03/08/vnode-deep-clone.html</id>
    <published>2017-03-08T11:41:02.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>在Vue中，<code>slot</code>是一个很有用的特性，可以用来向组件内部插入一些内容。<code>slot</code>就是“插槽”的意思，用大白话说就是：定义组件的时候留几个口子，由用户来决定插入的内容。</p>
<p>例如我们定义一个组件<code>MyComponent</code>，其包含一个<code>slot</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当调用<code>&lt;MyComponent&gt;123&lt;/MyComponent&gt;</code>时，会渲染为如下DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  123</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>现在又有新需求了，我们希望调用<code>&lt;MyComponent&gt;123&lt;/MyComponent&gt;</code>时，渲染出这样的DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  123</div><div class="line">  123</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>看起来很容易实现，即再为<code>MyComponent</code>添加一个<code>slot</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>渲染出的结构也确实如你所愿，唯一美中不足的是控制台有一个小小的Warning：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Duplicate presence of slot &quot;default&quot; found in the same render tree</div></pre></td></tr></table></figure></p>
<p>如果你不是强迫症患者，这时候你可以收工安心回家睡觉了。直到有一天你的同事向你抱怨，为什么向<code>MyComponent</code>插入一个自定义组件会渲染不出来？</p>
<p>例如有一自定义组件<code>MyComponent2</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent2&apos;, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div&gt;456&lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当调用<code>&lt;MyComponent&gt;&lt;MyComponent2&gt;&lt;/MyComponent2&gt;&lt;/MyComponent&gt;</code>时，预期渲染为如下DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;div&gt;456&lt;/div&gt;</div><div class="line">  &lt;div&gt;456&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>为什么不能正常工作呢？估计是前面的那个Warning搞得鬼，通过查询发现在Vue 2.0中不允许有重名的<code>slot</code>:</p>
<blockquote>
<p>重名的 Slots 移除<br>同一模板中的重名 <slot> 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用 prop 来传递。</slot></p>
</blockquote>
<p>文档中提示可以用<code>props</code>来实现，然而在我的用例中显然是不合适的。经过搜索后，最靠谱的方法是手写render函数，将<code>slot</code>中的内容复制到其他的位置。</p>
<p>将之前的<code>MyComponent</code>改为render函数的方式定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  render (createElement) &#123;</div><div class="line">    return createElement(&apos;div&apos;, [</div><div class="line">      ...this.$slots.default,</div><div class="line">      ...this.$slots.default</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在上面的定义中我们插入了两个<code>this.$slots.default</code>，测试下能不能正常工作。然而并没有什么卵用，Vue文档在render函数这一章有以下说明：</p>
<blockquote>
<p>VNodes 必须唯一<br>所有组件树中的 VNodes 必须唯一</p>
</blockquote>
<p>这意味着我们不能简单地在不同位置引用<code>this.$slots.default</code>，必须对<code>slot</code>进行深度复制。深度复制的函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function deepClone(vnodes, createElement) &#123;</div><div class="line"></div><div class="line">  function cloneVNode (vnode) &#123;</div><div class="line">    const clonedChildren = vnode.children &amp;&amp; vnode.children.map(vnode =&gt; cloneVNode(vnode));</div><div class="line">    const cloned = createElement(vnode.tag, vnode.data, clonedChildren);</div><div class="line">    cloned.text = vnode.text;</div><div class="line">    cloned.isComment = vnode.isComment;</div><div class="line">    cloned.componentOptions = vnode.componentOptions;</div><div class="line">    cloned.elm = vnode.elm;</div><div class="line">    cloned.context = vnode.context;</div><div class="line">    cloned.ns = vnode.ns;</div><div class="line">    cloned.isStatic = vnode.isStatic;</div><div class="line">    cloned.key = vnode.key;</div><div class="line"></div><div class="line">    return cloned;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  const clonedVNodes = vnodes.map(vnode =&gt; cloneVNode(vnode))</div><div class="line">  return clonedVNodes;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的核心函数就是<code>cloneVNode()</code>，它递归地创建VNode，实现深度复制。VNode的属性很多，我并不了解哪些是关键属性，只是参照着Vue的源码一并地复制过来。</p>
<p>基于以上函数，我们更改<code>MyComponent</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  render (createElement) &#123;</div><div class="line">    return createElement(&apos;div&apos;, [</div><div class="line">      ...this.$slots.default,</div><div class="line">      ...deepClone(this.$slots.default, createElement)</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>经测试，一切正常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Vue 1.0中重名的slots并不会出现什么问题，不知道为什么在2.0中取消了这个功能。我听说React提供了复制Element的标准函数，希望Vue也能提供这个函数，免得大家踩坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Vue中，&lt;code&gt;slot&lt;/code&gt;是一个很有用的特性，可以用来向组件内部插入一些内容。&lt;code&gt;slot&lt;/code&gt;就是“插槽”的意思，用大白话说就是：定义组件的时候留几个口子，由用户来决定插入的内容。&lt;/p&gt;
&lt;p&gt;例如我们定义一个组件&lt;code&gt;MyCo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手机上也可以愉快地搞nodejs开发</title>
    <link href="https://jingsam.github.io/2017/02/07/nodejs-on-android.html"/>
    <id>https://jingsam.github.io/2017/02/07/nodejs-on-android.html</id>
    <published>2017-02-07T09:18:58.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在微博上看到尤雨溪的这么一则微博：<br><img src="/assets/2017-02-07-1.png" alt=""></p>
<p>嗬！在手机上也能跑nodejs，有点儿意思哈。顺手查了查nodejs官网，发现nodejs是支持ARM处理器的，有了这个先决条件，手机上跑nodejs应该没什么大障碍了。本文就来分享一下我在手机上跑nodejs的一点经验。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你得有一部Android手机，iPhone的硬件条件有，但是由于IOS是一个封闭的系统，实际操作起来会很困难。</p>
<p>软件方面需要安装<a href="1">Termux</a>，这是Android平台下的一个开源的终端模拟器。</p>
<p>另外，我建议安装一个编程键盘<a href="2">Hacker’s Keyboard</a>，因为一般的输入法没有Ctrl、Alt、Tab、Esc这些常用控制键，到时候会很麻烦。安装Hacker’s Keyboard，设置为全键盘模式。</p>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>首先得把nodejs安装到手机上。Termux强大的地方在于它带有一个包管理器<code>apt</code>，使用<code>apt</code>可以直接安装nodejs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt update</div><div class="line">apt install nodejs</div></pre></td></tr></table></figure></p>
<p>这样node和npm都安装好了，node的版本是v6.9.4，版本还比较新。</p>
<p>搞开发嘛，做好把git和vim也安装上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install git vim</div></pre></td></tr></table></figure></p>
<p>有了npm之后，我们就可以随意安装需要的包了，这里以vue-cli为例，来跑一个vuejs工程。过程与在电脑上是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm i vue-cli -g</div><div class="line">vue init webpack vue-test</div><div class="line">cd vue-test</div><div class="line">npm i</div><div class="line">npm run dev</div></pre></td></tr></table></figure></p>
<p>浏览器打开localhost:8080，你就可以看到vuejs的欢迎页面了。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>由于Android权限管理的原因，你并不能随意地在任何位置写入文件。你的活动范围必须在Termux的权限之内，即<code>data/data/com.termux/files</code>目录下。虽然你可以写文件到SD卡，但是有些包symbolink的时候会失败，所以保险的做法是所有的操作都在HOME目录下进行，即<code>data/data/com.termux/files/home</code>目录。</p>
<p>在HOME目录下操作的坏处是，但你卸载Termux时，HOME下的所有文件也会删除。所以玩玩而已，不要当真，哈哈！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实话讲，在手机上不长不方便，我想有一下3点：</p>
<ol>
<li>屏幕太小。本来屏幕空间就有限，输入法还要占一半，估计可以通过投屏解决；</li>
<li>没有好的编辑器。本来就没人会在手机上搞正经开发嘛，所以不会有好的编辑器，还好Vim可以凑合着用；</li>
<li>输入不方便。这个也是最大的问题，手机键盘真的太不方便了，有点想念诺基亚N97了。</li>
</ol>
<p><img src="/assets/2017-02-07-2.jpg" alt=""></p>
<p>关于手机键盘，最好能携带方便，搜了下淘宝，下面两款似乎不错哦：<br><img src="/assets/2017-02-07-3.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在微博上看到尤雨溪的这么一则微博：&lt;br&gt;&lt;img src=&quot;/assets/2017-02-07-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用travis-ci持续部署nodejs应用</title>
    <link href="https://jingsam.github.io/2017/01/23/deploy-nodejs-with-travis-ci.html"/>
    <id>https://jingsam.github.io/2017/01/23/deploy-nodejs-with-travis-ci.html</id>
    <published>2017-01-23T03:26:23.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>Travis-ci是一款持续集成（Continuous Integration）服务，它能够很好地与Github结合，每当代码更新时自动地触发集成过程。</p>
<p>Travis-ci配置简单，很多nodejs项目都用它做自动测试。然而，对于持续集成，仅做到自动测试是不够的，还要有后续的自动部署，才能完成“提交代码 =&gt; 自动测试 =&gt; 自动部署”的集成链条。</p>
<p>本文以nodejs应用为例，来谈谈如何利用travis-ci完成自动部署。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>从自动测试到自动部署的核心问题是测试机与生产服务器的信任问题，即如何安全地把程序包传输到生产服务器。市面上的部署工具如scp、ansible、chef，都绕不开这个核心问题。</p>
<p>以scp为例，测试机登录生产服务器的方式有两种：密码和秘钥。密码登录方式需要交互式地输入密码，总不能每次测试的时候，人为地输入密码吧，所以密码方式行不通。</p>
<p>秘钥的方式可以实现自动登录，但首次将测试机的公钥传输给生产服务器仍然需要密码。似乎走入了死胡同，但办法总是有的。我们知道开发机是可以登录到生产服务器的，那么我们就可以<strong>将开发机的公钥复制到生产服务器，将开发机的私钥复制到测试机，测试机通过私钥来伪装成开发机，自动地登录到生产服务器</strong>。</p>
<p>解决了自动登录的问题，另一个问题是怎么将开发机的私钥复制到测试机上。由于测试机每次都是新开的一个虚拟机，这个新开的虚拟机IP不固定，所以没办法直接登录上去。解决办法是将私钥文件作为代码库的一部分提交，这样测试机每次从代码库上拉取代码的同时也获取到了秘钥文件，通过这种方式就实现了私钥从开发机复制到测试机。</p>
<p>将私钥文件提交到代码库有一个很严重的安全性问题，即任何人只要得到了这个私钥文件，他就可以随心所欲的操纵生产服务器。幸好，travis-ci提供了加密方案，它能够将私钥文件加密，加密后的文件只在当前代码库有效。</p>
<p>总的来说，通过复制私钥完成自动登录以及对私钥加密来保障安全性，我们就可以建立起测试机与生产服务器的信任通道，测试机就可以安全地操作生产服务器完成自动部署。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>现在我以scp方式部署nodejs应用为例，来说明travis-ci做自动部署的配置。</p>
<p>首先，建立起开发机与生产服务器的信任关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id username@host</div></pre></td></tr></table></figure></p>
<p>然后，加密你的私钥，私钥文件通常在<code>~/.ssh/id_rsa</code>。加密私钥文件需要使用travis这个命令行工具，它是一个ruby包，使用gem安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gem install travis</div><div class="line">travis login</div></pre></td></tr></table></figure></p>
<p>输入账号密码登录成功后，使用<code>travis encrypt-file</code>加密：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt-file ~/.ssh/id_rsa --add</div></pre></td></tr></table></figure></p>
<p>上面命令执行完后，会生成一段解密命令并添加到<code>.travis.yml</code>中：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">~/.ssh/id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div></pre></td></tr></table></figure></p>
<p>接下来，把加密后的私钥文件（id_rsa.enc）复制到代码库中，千万要注意不要错把未加密的私钥文件（id_rsa）复制到你的代码库中。然后把上面的解密命令的<code>-in ~/.ssh/id_rsa.enc</code>改为<code>-in id_rsa.enc</code>。</p>
<p>通过上面的过程就基本建立测试机与生产服务器的信任关系，但还有一些小细节要处理。例如，降低<code>id_rsa</code>文件的权限，否则ssh处于安全方面的原因会拒绝读取秘钥；将生产服务器地址加入到测试机的信任列表中，否则连接时会询问是否信任服务器。更改后的配置如下:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div><div class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line"><span class="bullet">  -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"Host 102.201.64.94\n\tStrictHostKeyChecking no\n"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></div></pre></td></tr></table></figure></p>
<p>最后，测试机就可以愉快地操作生产服务器了，例如下面是一个nodejs应用的<code>.travis.yml</code>文件配置：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="attr">language:</span> <span class="string">node_js</span></div><div class="line"><span class="attr">node_js:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">'4.4.4'</span></div><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div><div class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line"><span class="bullet">  -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"Host 102.201.64.94\n\tStrictHostKeyChecking no\n"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></div><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">prune</span> <span class="bullet">--production</span>  <span class="comment"># 删除devDependencies</span></div><div class="line"><span class="bullet">  -</span> <span class="string">tar</span> <span class="bullet">-jcf</span> <span class="string">indoor-server.tar.bz2</span> <span class="string">*</span>    <span class="comment"># 打包并压缩代码</span></div><div class="line"><span class="bullet">  -</span> <span class="string">scp</span> <span class="string">indoor-server.tar.bz2</span> <span class="string">jingsam@102.201.64.94:~/</span>  <span class="comment"># 复制到生产服务器上</span></div><div class="line"><span class="bullet">  -</span> <span class="string">ssh</span> <span class="string">jingsam@102.201.64.94</span> <span class="string">'mkdir -p indoor-server &amp;&amp; tar -jxf indoor-server.tar.bz2 -C indoor-server'</span>   <span class="comment"># 解压</span></div><div class="line"><span class="bullet">  -</span> <span class="string">ssh</span> <span class="string">jingsam@102.201.64.94</span> <span class="string">'cd indoor-server &amp;&amp; pm2 startOrReload pm2.json'</span>  <span class="comment"># 重启pm2</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章讲的自动部署其实与nodejs关系不大，完全适用于各种语言的自动部署，其原理都是相通的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Travis-ci是一款持续集成（Continuous Integration）服务，它能够很好地与Github结合，每当代码更新时自动地触发集成过程。&lt;/p&gt;
&lt;p&gt;Travis-ci配置简单，很多nodejs项目都用它做自动测试。然而，对于持续集成，仅做到自动测试是不够
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用node-pre-gyp加速二进制包安装</title>
    <link href="https://jingsam.github.io/2017/01/12/node-pre-gyp-mirror.html"/>
    <id>https://jingsam.github.io/2017/01/12/node-pre-gyp-mirror.html</id>
    <published>2017-01-12T02:36:34.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>node-pre-gyp是一个分发nodejs二进制程序包的工具，负责将预编译好的二进制程序直接下载到用户目录。它介于npm与node-gyp之间，只在相应平台二进制包不存在时才调用node-gyp编译。</p>
<p>node-pre-gyp存在的意义是什么呢？一些简单的nodejs C++扩展直接从源代码编译安装问题不大，但复杂的扩展编译环境难搭建、编译耗时长，因而从源代码安装非常麻烦。node-pre-gyp能够将预编译好的二进制包直接下载到用户目录，只在必要的时候才调用node-gyp从源代码编译，大大加快了nodejs C++扩展的安装速度。</p>
<p>node-pre-gyp需要开发者将各平台编译好的二进制包上传到网络上，并在package.json的<code>binary</code>字段指明二进制包的位置。然而，很多开发者选择将二进制包上传到aws上，导致国内无法正常下载（被墙）。幸好，可以在npm中设置<code>--{module_name}_binary_host_mirror</code>选项来指定二进制包的位置。例如，安装v8-profiler可以使用如下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install v8-profiler --profiler_binary_host_mirror=https://npm.taobao.org/mirrors/node-inspector/</div></pre></td></tr></table></figure></p>
<p>为了让国内开发者也能享受到node-pre-gyp带来的好处，我使用阿里云做了一个镜像，镜像的地址是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://foxgis.oss-cn-shanghai.aliyuncs.com</div></pre></td></tr></table></figure></p>
<p>如果要安装sqlite3，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install sqlite3 --sqlite3_binary_host_mirror=https://foxgis.oss-cn-shanghai.aliyuncs.com</div></pre></td></tr></table></figure></p>
<p>目前是放到阿里云OSS上的，速度还可以，镜像上面包有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mapnik mapbox-gl-native sqlite3 fontnik gdal osrm zipfile</div></pre></td></tr></table></figure></p>
<p>如果有其他包需要放到上面的，请给我留言或者发邮件（abc#whu.edu.cn）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;node-pre-gyp是一个分发nodejs二进制程序包的工具，负责将预编译好的二进制程序直接下载到用户目录。它介于npm与node-gyp之间，只在相应平台二进制包不存在时才调用node-gyp编译。&lt;/p&gt;
&lt;p&gt;node-pre-gyp存在的意义是什么呢？一些简单的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>少年，不要滥用箭头函数啊</title>
    <link href="https://jingsam.github.io/2016/12/08/things-you-should-know-about-arrow-functions.html"/>
    <id>https://jingsam.github.io/2016/12/08/things-you-should-know-about-arrow-functions.html</id>
    <published>2016-12-08T08:30:55.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<p>在ES6大行其道的今天，不应用点ES6特性似乎有些政治不正确。最近刚好有个Node的项目，最低要支持到nodejs 4.0，在<a href="1">node.green</a>看了下ES6的支持度，我想使用的特性基本都有支持，遂决定在新项目中采用ES6来写。</p>
<p>当然第一件事情就是毫不留情地消灭var，项目中能用const的地方不用let，能用let的地方不用var。</p>
<p>第二件事情就是使用劳动人民喜闻乐见的箭头函数替代function。当我心满意足地看到满屏的<code>=&gt;</code>时，现实给了我一记响亮的耳光——改过之后的程序错误百出！</p>
<p>所以，当我们使用箭头函数时，一定要搞清楚箭头函数是什么回事，适用于什么场景。本文就针对以上问题来讨论下箭头函数。</p>
<h2 id="箭头函数是什么？"><a href="#箭头函数是什么？" class="headerlink" title="箭头函数是什么？"></a>箭头函数是什么？</h2><p>箭头函数的语法我就不讲了，相信大家都见识过。跟我一样，大家喜欢箭头函数90%的原因是它好看。除了好看，它是不是与function等价呢？肯定不等价，因为TC39不可能仅因为好看而引入一个语法糖（class除外）。</p>
<p>箭头函数的渊源可以追溯到上古时期一个叫lambda演算的东西。lambda演算是数学家提出来的，有些数学家跟我们程序员一样也很懒，数学定理那么多，今天要证三角定律，明天要证勾股定律，累不累！那能不能将所有的证明问题用一个统一的体系进行形式化描述，然后由机器来完成自动推导呢？lambda演算就是干这个的，图灵也搞了一套体系叫图灵机，两者是等价的。</p>
<p>关于lambda演算说了这么多，好像跟今天要讲的箭头函数没什么关系？其实是有关系的，lambda演算深刻影响了箭头函数的设计。数学家们喜欢用纯函数式编程语言，纯函数的特点是没有副作用，给予特定的输入，总是产生确定的输出，甚至有些情况下通过输出能够反推输入。要实现纯函数，必须使函数的执行过程不依赖于任何外部状态，整个函数就像一个数学公式，给定一套输入参数，不管是在地球上还是火星上执行都是同一个结果。</p>
<p>箭头函数要实现类似纯函数的效果，必须剔除外部状态。所以当你定义一个箭头函数，在普通函数里常见的<code>this</code>、<code>arguments</code>、<code>caller</code>是统统没有的。</p>
<h2 id="箭头函数没有this"><a href="#箭头函数没有this" class="headerlink" title="箭头函数没有this"></a>箭头函数没有<code>this</code></h2><p>箭头函数没有<code>this</code>，那下面的代码明显可以取到<code>this</code>啊：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></div><div class="line">  <span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line"></div><div class="line">  b()</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>以上箭头函数中的<code>this</code>其实是父级作用域中的<code>this</code>，即函数<code>foo</code>的<code>this</code>。箭头函数引用了父级的变量，构成了一个闭包。以上代码等价于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></div><div class="line">  <span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(self.a)</div><div class="line"></div><div class="line">  b()</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>箭头函数不仅没有<code>this</code>，常用的<code>arguments</code>也没有。如果你能获取到<code>arguments</code>，那它一定是来自父作用域的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>])</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>上例中如果箭头函数有<code>arguments</code>，就应该输出的是3而不是1。</p>
<p>一个经常犯的错误是使用箭头函数定义对象的方法，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  foo: <span class="number">1</span>,</div><div class="line">  bar: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>以上代码中，箭头函数中的<code>this</code>并不是指向<code>a</code>这个对象。对象<code>a</code>并不能构成一个作用域，所以再往上到达全局作用域，<code>this</code>就指向全局作用域。如果我们使用普通函数的定义方法，输出结果就符合预期，这是因为<code>a.bar()</code>函数执行时作用域绑定到了<code>a</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  foo: <span class="number">1</span>,</div><div class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>另一个错误是在原型上使用箭头函数，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.foo = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">A.prototype.bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</div><div class="line">a.bar()  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>同样，箭头函数中的<code>this</code>不是指向<code>A</code>，而是根据变量查找规则回溯到了全局作用域。同样，使用普通函数就不存在问题。</p>
<p>通过以上说明，我们可以看出，箭头函数除了传入的参数之外，真的是什么都没有！如果你在箭头函数引用了<code>this</code>、<code>arguments</code>或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。</p>
<h2 id="什么情况下该使用箭头函数"><a href="#什么情况下该使用箭头函数" class="headerlink" title="什么情况下该使用箭头函数"></a>什么情况下该使用箭头函数</h2><p>到这里，我们可以发现箭头函数并不是万金油，稍不留神就会踩坑。</p>
<p>至于什么情况该使用箭头函数，《You Don’t Know About JS》给出了一个决策图：<br><img src="/assets/arrow-function.png" alt="arrow function"></p>
<p>以上决策图看起来有点复杂，我认为有三点比较重要：</p>
<ol>
<li>箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在<code>map</code>、<code>reduce</code>、<code>filter</code>的回调函数定义中；</li>
<li>不要在最外层定义箭头函数，因为在函数内部操作<code>this</code>会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将<code>this</code>控制在可见的范围内；</li>
<li>如开头所述，箭头函数最吸引人的地方是简洁。在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ES6大行其道的今天，不应用点ES6特性似乎有些政治不正确。最近刚好有个Node的项目，最低要支持到nodejs 4.0，在&lt;a href=&quot;1&quot;&gt;node.green&lt;/a&gt;看了下ES6的支持度，我想使用的特性基本都有支持，遂决定在新项目中采用ES6来写。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>打包 Vue 组件库的正确姿势</title>
    <link href="https://jingsam.github.io/2016/11/18/bundle-vue-components.html"/>
    <id>https://jingsam.github.io/2016/11/18/bundle-vue-components.html</id>
    <published>2016-11-17T16:15:28.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便其他开发者使用组件库，开发的 Vue 组件库在发布之前需要对其打包。本文基于 Webpack 讨论打包 Vue 组件库的正确方法。</p>
<h2 id="选择正确的打包格式"><a href="#选择正确的打包格式" class="headerlink" title="选择正确的打包格式"></a>选择正确的打包格式</h2><p>首先，我们必须明确组件库的使用场景。有些场景是直接使用 <code>&lt;script&gt;</code> 在 HTML 中引入，有些场景是使用打包工具在后台构建。作为组件库，应该兼容这些使用场景。组件库应该保持中立，不应该限定于某种使用方式或者打包工具。例如，虽然 Webpack 很流行，组件库不能声明只支持 Webpack 方式使用，忽略了其他选择。原因在于，打包工具并不只有 webpack，还有 browserify、rollup 等。另外，前端工具发展很快，今年流行的工具明年可能就没人用了，你肯定不希望你的组件库会随着某个工具不流行而消逝吧。回顾下曾经流行的 grunt、glup，一大堆基于它们的插件随着工具本身的不流行而被扔进了垃圾箱。</p>
<p>为了支持多种使用场景，我们需要选择合适的打包格式。常见的打包格式有 CMD、AMD、UMD，CMD只能在 Node 环境执行，AMD 只能在浏览器端执行，UMD 同时支持两种执行环境。显而易见，我们应该选择 UMD 格式。Webpack 中指定输出格式的设置项为 <code>output.libraryTarget</code>，其支持的格式有：</p>
<ul>
<li>“var” - 以一个变量形式输出： var Library = xxx (default)；</li>
<li>“this” - 以 this 的一个属性输出： this[“Library”] = xxx；</li>
<li>“commonjs” - 以 exports 的一个属性输出：exports[“Library”] = xxx；</li>
<li>“commonjs2” - 以 module.exports 形式输出：module.exports = xxx；</li>
<li>“amd” - 以 AMD 格式输出；</li>
<li>“umd” - 同时以 AMD、CommonJS2 和全局属性形式输出。</li>
</ul>
<p>以下是 <code>webpack.config.js</code> 中 <code>output</code> 设置的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">    publicPath: <span class="string">'/dist/'</span>,</div><div class="line">    filename: <span class="string">'iview.js'</span>,</div><div class="line">    library: <span class="string">'iview'</span>,       <span class="comment">// 模块名称</span></div><div class="line">    libraryTarget: <span class="string">'umd'</span>,   <span class="comment">// 输出格式</span></div><div class="line">    umdNamedDefine: <span class="literal">true</span>    <span class="comment">// 是否将模块名称作为 AMD 输出的命名空间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此，我们解决了组件库输出的问题。</p>
<h2 id="如何打包组件依赖"><a href="#如何打包组件依赖" class="headerlink" title="如何打包组件依赖"></a>如何打包组件依赖</h2><p>在<a href="/2016/11/01/peerDependencies-in-Vue-components.html">前一篇</a>文章中我们讨论了组件库实质上是 Vue 的插件，Vue 应该是组件库的外部依赖。组件库的使用者会自行导入 Vue，打包的时候，不应该将 Vue 打包进组件库。</p>
<p>在 webpack 中，我们可以将 Vue 设置为 <code>externals</code>，以避免将 Vue 打包进组件库，相应的设置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">externals: &#123;</div><div class="line">    vue: <span class="string">'vue'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>啊哈，我们搞定了组件依赖问题。至此，读者可能很皱起眉头开始埋怨我了：这么简单的问题，查下 webpack 文档不就得了，还用得着我啰里啰嗦地写这么多！</p>
<p>事实上，问题往往没有我们想得那么简单！如果你将打包后的组件库以 <code>&lt;script&gt;</code> 标签形式直接引入，你会发现并不能正常执行，提示 vue 未定义。</p>
<p>为了分析问题，我们将打包的代码前几行拿出来看看：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">webpackUniversalModuleDefinition</span>(<span class="params">root, factory</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span>)</div><div class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"vue"</span>));</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd)</div><div class="line">        define(<span class="string">"iview"</span>, [<span class="string">"vue"</span>], factory);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span>)</div><div class="line">        exports[<span class="string">"iview"</span>] = factory(<span class="built_in">require</span>(<span class="string">"vue"</span>));</div><div class="line">    <span class="keyword">else</span></div><div class="line">        root[<span class="string">"iview"</span>] = factory(root[<span class="string">"vue"</span>]);</div><div class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">__WEBPACK_EXTERNAL_MODULE_157__</span>) </span>&#123;</div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>我们可以看见，打包后的代码以 4 种形式声明了 Vue 依赖：</p>
<ol>
<li><code>module.exports = factory(require(&quot;vue&quot;))</code> - commonjs2 形式；</li>
<li><code>define(&quot;iview&quot;, [&quot;vue&quot;], factory)</code> - AMD 形式；</li>
<li><code>exports[&quot;iview&quot;] = factory(require(&quot;vue&quot;))</code> - commonjs 形式；</li>
<li><code>root[&quot;iview&quot;] = factory(root[&quot;vue&quot;])</code> - 全局变量形式。</li>
</ol>
<p>以 <code>&lt;script&gt;</code> 标签形式使用组件时，会同样使用 <code>&lt;script&gt;</code> 标签导入 Vue。Vue 导入的变量是 “window.Vue” 而不是 “window.vue”，因此会出现 vue 未定义的错误。</p>
<p>幸好，webpack 可以为各种导入形式设置不同名称，设置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">externals: &#123;</div><div class="line">    vue: &#123;</div><div class="line">        root: <span class="string">'Vue'</span>,</div><div class="line">        commonjs: <span class="string">'vue'</span>,</div><div class="line">        commonjs2: <span class="string">'vue'</span>,</div><div class="line">        amd: <span class="string">'vue'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次打包，你可以发现打包的组件库不管是 <code>&lt;script&gt;</code> 标签方式还是后端构建，都可以正常工作了。</p>
<p>最后，帖一个打包 iView 组件库的 webpack 配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        main: <span class="string">'./src/index.js'</span></div><div class="line">    &#125;,</div><div class="line">    output: &#123;</div><div class="line">        path: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">        publicPath: <span class="string">'/dist/'</span>,</div><div class="line">        filename: <span class="string">'iview.js'</span>,</div><div class="line">        library: <span class="string">'iview'</span>,</div><div class="line">        libraryTarget: <span class="string">'umd'</span>,</div><div class="line">        umdNamedDefine: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    externals: &#123;</div><div class="line">        vue: &#123;</div><div class="line">            root: <span class="string">'Vue'</span>,</div><div class="line">            commonjs: <span class="string">'vue'</span>,</div><div class="line">            commonjs2: <span class="string">'vue'</span>,</div><div class="line">            amd: <span class="string">'vue'</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    resolve: &#123;</div><div class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>]</div><div class="line">    &#125;,</div><div class="line">    <span class="built_in">module</span>: &#123;</div><div class="line">        loaders: [&#123;</div><div class="line">            test: <span class="regexp">/\.vue$/</span>,</div><div class="line">            loader: <span class="string">'vue'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.js$/</span>,</div><div class="line">            loader: <span class="string">'babel'</span>,</div><div class="line">            exclude: <span class="regexp">/node_modules/</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.css$/</span>,</div><div class="line">            loader: <span class="string">'style!css!autoprefixer'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.less$/</span>,</div><div class="line">            loader: <span class="string">'style!css!less'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.(gif|jpg|png|woff|svg|eot|ttf)\??.*$/</span>,</div><div class="line">            loader: <span class="string">'url?limit=8192'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.(html|tpl)$/</span>,</div><div class="line">            loader: <span class="string">'vue-html'</span></div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">            <span class="string">'process.env'</span>: &#123;</div><div class="line">                NODE_ENV: <span class="string">'"development"'</span></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便其他开发者使用组件库，开发的 Vue 组件库在发布之前需要对其打包。本文基于 Webpack 讨论打包 Vue 组件库的正确方法。&lt;/p&gt;
&lt;h2 id=&quot;选择正确的打包格式&quot;&gt;&lt;a href=&quot;#选择正确的打包格式&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开发组件库时 Vue 应该放哪儿：devDependencies or peerDependencies？</title>
    <link href="https://jingsam.github.io/2016/11/01/peerDependencies-in-Vue-components.html"/>
    <id>https://jingsam.github.io/2016/11/01/peerDependencies-in-Vue-components.html</id>
    <published>2016-11-01T11:16:58.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<p>最近在和 Aresn 开发 iView 组件库的时候，关于依赖包 Vue 到底是放在 devDependencies 还是 peerDependencies 有些争论。本着打破砂锅问到底的精神，这篇文章讨论下 package.json 里面的各种 depedencies 字段到底是干嘛的。</p>
<p>npm 的 package.json 包括 5 种 dependencies：</p>
<ol>
<li><code>dependencies</code>：应用能够正常运行所依赖的包。这种 dependencies 是最常见的，用户在使用 <code>npm install</code> 安装你的包时会自动安装这些依赖。</li>
<li><code>devDependencies</code>：开发应用时所依赖的工具包。通常是一些开发、测试、打包工具，例如 webpack、ESLint、Mocha。应用正常运行并不依赖于这些包，用户在使用 <code>npm install</code> 安装你的包时也不会安装这些依赖。</li>
<li><code>peerDependencies</code>：应用运行依赖的宿主包。最典型的就是插件，例如各种 jQuery 插件，这些插件本身不包含 jQeury，需要外部提供。用户使用 npm 1 或 2 时会自动安装这种依赖，npm 3 不会自动安装，会提示用户安装。</li>
<li><code>bundledDependencies</code>：发布包时需要打包的依赖，似乎很少见。</li>
<li><code>optionalDependencies</code>：可选的依赖包。此种依赖不是程序运行所必须的，但是安装后可能会有新功能，例如一个图片解码库，安装了 <code>optionalDependencies</code> 后会支持更多的格式。</li>
</ol>
<p>从以上的定义可以看出，<code>dependencies</code> 是程序运行依赖，<code>devDependencies</code> 一般是一些开发工具，<code>peerDependencies</code> 一般用于插件。</p>
<p>下表是我在 awesome-vue 中找到的 28 个 Vue 组件库，统计了 Vue 在这些库中的位置。其中，11 个库选择放到 <code>dependencies</code>，10 个库选择放到 <code>devDependencies</code>，4 个库选择放到 <code>peerDependencies</code>，2 个库选择不放 Vue 依赖，最后还有 1 个库选择在 <code>devDependencies</code> 和 <code>peerDependencies</code> 同时加上 Vue 依赖。</p>
<table>
<thead>
<tr>
<th>UI</th>
<th>dependencies</th>
<th>devDependencies</th>
<th>peerDependencies</th>
<th>none</th>
</tr>
</thead>
<tbody>
<tr>
<td>vue-strap</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>gritcode-components</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Keen-UI</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>material-ui-vue</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-admin</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-carbon</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-impression</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vuikit</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-material</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-kit</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-material-design</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vuestrap-base-components</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vux</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-materialize</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mint-ui</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>N3-components</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-desktop</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-beauty</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>radon-ui</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-antd</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bootstrap-vue</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>iview</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>wovue</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>vue-bulma</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>quasar</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>vueboot</td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>material-components</td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>element</td>
<td></td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>
<p>下面分析下各种选择的优劣：</p>
<ul>
<li><code>dependencies</code>：放到 <code>dependencies</code> 的好处是安装组件库的时候 Vue 会自动安装。问题是已有的工程项目中往往已经安装了 Vue，会导致在 npm 1 或 2 中重复安装 Vue。虽然此问题在 npm 3 中可以规避，但是如果已安装的 Vue 版本与组件库所依赖的版本不兼容时，Vue 仍然会重复安装。</li>
<li><code>devDependencies</code>：由于组件库单元测试时会用到 Vue，所以严格来说 Vue 是属于开发工具包，放到 <code>devDependencies</code> 合情合理。但是，在 <code>devDependencies</code> 中的 Vue 依赖不会自动安装，所以需要用户去查文档来确定到底应该安装哪个版本的 Vue，对用户似乎不太友好。</li>
<li><code>peerDevDependencies</code>：Vue 组件库本质上是 Vue 的插件，依赖于外部提供的 Vue。把 Vue 放到这里，npm 能够提示用户需要安装哪个版本的 Vue，这点比 <code>devDependencies</code>  友好。问题在于，从 npm 3 开始，<code>peerDevDependencies</code> 中的依赖不会自动安装，会导致自动集成测试失败。</li>
<li>不添加依赖：这基本上是最差的选择了，用户甚至不能知道组件库到底依赖哪个版本的 Vue，只能靠猜。</li>
<li><code>devDependencies</code>、<code>peerDevDependencies</code> 同时添加：这是我和 Element UI 的开发者讨论后最优的做法。<code>peerDevDependencies</code> 中的 Vue 是组件库运行所依赖的 Vue 的最低版本，而 <code>devDependencies</code> 运行测试时需要的 Vue 版本，一般情况下 <code>devDependencies &gt;= peerDevDependencies</code>。这种做法保证了 npm 1、2、3 都不会出问题，并且当用户安装组件库时给予友好的提示信息。</li>
</ul>
<p>到这里，我们可以得出以下结论：<strong>在开发 Vue 组件库是，应当同时在 <code>devDependencies</code> 和 <code>peerDevDependencies</code> 添加 Vue 依赖。</strong></p>
<p>最后，可能有人会说：哥们，何必较真呢，能用不就行了吗？我的观点是，如果大家都按照规范来，会减少很多不必要的麻烦。想想看，如果大家在 npm 上发布包的时候不遵守 semver 规范，你还有信心说，你的程序只要 npm install 就能正常运行么？</p>
<p>按老罗的话说，我不是为了输赢，我就是认真！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在和 Aresn 开发 iView 组件库的时候，关于依赖包 Vue 到底是放在 devDependencies 还是 peerDependencies 有些争论。本着打破砂锅问到底的精神，这篇文章讨论下 package.json 里面的各种 depedencies 字
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊 Vue 组件命名那些事</title>
    <link href="https://jingsam.github.io/2016/10/30/vue-components-naming.html"/>
    <id>https://jingsam.github.io/2016/10/30/vue-components-naming.html</id>
    <published>2016-10-30T07:56:01.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>There are only two things in Computer Sciences: cache invalidation and naming things.<br>—— Phil Karlton</p>
</blockquote>
<p>诚如上述所言，编程中变量命名确实令人很头疼。我们模糊地知道，Vue 组件的名称最好不要和原生 HTML 标签相同。为了避免重名，通常会在组件名称前面加上一个前缀，如 <code>el-button</code>、<code>el-input</code>、<code>el-date-picker</code>。这通常不会有什么问题，但有时候你的模板中混杂了原生 HTML 标签和组件标签，要想区分它们并不是很容易。</p>
<p>当我看到 Ant.design 的 React 组件是下面这样的时候，我感觉到一种自由的味道。首先，组件名可以使用原生 HTML 标签名，意味着再也不用较劲脑汁去规避原生 HTML 标签了。另外，这些组件都使用了首字母大写标签名，使它们很容易地与原生小写的 HTML 标签区分。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;Button type=<span class="string">"primary"</span>&gt;Primary&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">    &lt;Input placeholder="Basic usage" /</span>&gt;</div><div class="line">    &lt;Select defaultValue=<span class="string">".com"</span> style=&#123;&#123; <span class="attr">width</span>: <span class="number">70</span> &#125;&#125;&gt;</div><div class="line">      &lt;Option value=<span class="string">".com"</span>&gt;.com&lt;<span class="regexp">/Option&gt;</span></div><div class="line"><span class="regexp">      &lt;Option value=".jp"&gt;.jp&lt;/</span>Option&gt;</div><div class="line">      &lt;Option value=<span class="string">".cn"</span>&gt;.cn&lt;<span class="regexp">/Option&gt;</span></div><div class="line"><span class="regexp">      &lt;Option value=".org"&gt;.org&lt;/</span>Option&gt;</div><div class="line">    &lt;<span class="regexp">/Select&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>div&gt;,</div><div class="line">  mountNode</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>受 Ant.design 的启发，我思考 Vue 组件命名能不能达到同样的效果呢？要找到答案，必须摸清楚 Vue 组件命名到底有什么限制。下面将分别从 Vue 1.0 和 Vue 2.0 来谈谈组件命名的机制：</p>
<h2 id="Vue-1-0-组件命名机制"><a href="#Vue-1-0-组件命名机制" class="headerlink" title="Vue 1.0 组件命名机制"></a>Vue 1.0 组件命名机制</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><p>我们以一个最简单的例子来研究 Vue 组件的注册过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>通过跟踪代码的执行过程，发现对组件的名称有两处检查。</p>
<ol>
<li><p>检查名称是否与 HTML 元素或者 Vue 保留标签重名，不区分大小写。可以发现，只检查了常用的 HTML 元素，还有很多元素没有检查，例如 <code>button</code>、<code>main</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; (commonTagRE.test(id) || reservedTagRE.test(id))) &#123;</div><div class="line">  warn(<span class="string">'Do not use built-in or reserved HTML elements as component '</span> + <span class="string">'id: '</span> + id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;</span></div><div class="line"><span class="comment">// var reservedTagRE = /^(slot|partial|component)$/i;</span></div></pre></td></tr></table></figure>
</li>
<li><p>检查组件名称是否以字母开头，后面跟字母、数值或下划线。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="regexp">/^[a-zA-Z][\w-]*$/</span>.test(name)) &#123;</div><div class="line">  warn(<span class="string">'Invalid component name: "'</span> + name + <span class="string">'". Component names '</span> + <span class="string">'can only contain alphanumeric characaters and the hyphen.'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>基于以上两点，可以总结出组件的命名规则为：组件名以字母开头，后面跟字母、数值或下划线，并且不与 HTML 元素或 Vue 保留标签重名。</p>
<p>然而我们注意到，在上面的检查中，不符合规则的组件名称是 warn 而不是 error，意味着检查并不是强制的。实际上，<strong>Vue 组件注册的名称是没有限制的</strong>。你可以用任何 JavaScript 能够表示的字符串，不管是数字、特殊符号、甚至汉字，都可以成功注册。</p>
<h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><p>虽然 Vue 组件没有命名限制，但是我们终究是要在模板中引用的，不合理的组件名可能会导致我们无法引用它。</p>
<p>为了弄清楚 Vue 是如何将模板中的标签对应到自定义组件的，我们以一段简单的代码说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;my-component&gt;&lt;/my-component&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>总体来说，模板解析分为两个过程：</p>
<p>首先，Vue 会将 <code>template</code> 中的内容插到 DOM 中，以方便解析标签。由于 HTML 标签不区分大小写，所以在生成的标签名都会转换为小写。例如，当你的 <code>template</code> 为 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 时，插入 DOM 后会被转换为 <code>&lt;mycomponent&gt;&lt;/mycomponent&gt;</code>。</p>
<p>然后，通过标签名寻找对应的自定义组件。<strong>匹配的优先顺序从高到低为：原标签名、camelCase化的标签名、PascalCase化的标签名。</strong>例如 <code>&lt;my-component&gt;</code> 会依次匹配 my-component、myComponent、MyComponent。camelCase 和 PascalCase 的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> camelizeRE = <span class="regexp">/-(\w)/g</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> str.replace(camelizeRE, toUpper);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUpper</span>(<span class="params">_, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pascalize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> camelCase = camelize(str);</div><div class="line">  <span class="keyword">return</span> camelCase.charAt(<span class="number">0</span>).toUpperCase() + camelCase.slice(<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于一个 Vue 新手，经常对以下示例代码不能正常运行感到非常疑惑：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;MyComponent&gt;&lt;/MyComponent&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>如果我们按照模板解析的过程推理，就很好解释了。模板 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 插入到 DOM 后会变成 <code>&lt;mycomponent&gt;&lt;/mycomponent&gt;</code>。标签 mycomponent 匹配的组件依次为 mycomponent（原标签名）、mycomponent（camelCase形式）、Mycomponent（PascalCase形式），并没有匹配到注册的组件名 MyComponent，所以会报找不到组件 <mycomponent> 的警告。</mycomponent></p>
<h3 id="命名限制"><a href="#命名限制" class="headerlink" title="命名限制"></a>命名限制</h3><p>通过分析组件注册和模板解析的过程，发现 Vue 组件命名限制并没有我们想象得多。大家可以尝试一下各种命名，我试过 <code>&lt;a_=-*%按钮&gt;&lt;/a_=-*%按钮&gt;</code> 都可正常运行。</p>
<p>但是，并不意味着完全没有限制。由于在模板需要插入到 DOM 中，所以模板中的标签名必须能够被 DOM 正确地解析。主要有三种情况：一是完全不合法的标签名，例如 &lt;/&gt;；二是与 HTML 元素重名会产生不确定的行为，例如使用 input 做组件名不会解析到自定义组件，使用 button 在 Chrome 上正常但在 IE 上不正常；三是与 Vue 保留的 slot、partial、component 重名，因为会优先以本身的意义解析，从而产生非预期的结果。</p>
<p>上述命名限制存在的根本原因，在于模板解析的过程依赖了 DOM。能不能对模板解析过程改进一下，使其不依赖于 DOM 呢？实际上，这正是 Vue 2.0 的主要改进，将模板解析过程使用 Virtual DOM 实现，使得组件命名更加灵活。</p>
<h2 id="Vue-2-0-组件命名机制"><a href="#Vue-2-0-组件命名机制" class="headerlink" title="Vue 2.0 组件命名机制"></a>Vue 2.0 组件命名机制</h2><h3 id="组件注册-1"><a href="#组件注册-1" class="headerlink" title="组件注册"></a>组件注册</h3><p>Vue 2.0 的组件注册过程与 Vue 1.0 基本相同，只是 HTML 标签和 Vue 保留标签范围有些不同：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 区分大小写</span></div><div class="line"><span class="keyword">var</span> isHTMLTag = makeMap(</div><div class="line">  <span class="string">'html,body,base,head,link,meta,style,title,'</span> +</div><div class="line">  <span class="string">'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,'</span> +</div><div class="line">  <span class="string">'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,'</span> +</div><div class="line">  <span class="string">'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,'</span> +</div><div class="line">  <span class="string">'s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,'</span> +</div><div class="line">  <span class="string">'embed,object,param,source,canvas,script,noscript,del,ins,'</span> +</div><div class="line">  <span class="string">'caption,col,colgroup,table,thead,tbody,td,th,tr,'</span> +</div><div class="line">  <span class="string">'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,'</span> +</div><div class="line">  <span class="string">'output,progress,select,textarea,'</span> +</div><div class="line">  <span class="string">'details,dialog,menu,menuitem,summary,'</span> +</div><div class="line">  <span class="string">'content,element,shadow,template'</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// 不区分大小写</span></div><div class="line"><span class="keyword">var</span> isSVG = makeMap(</div><div class="line">  <span class="string">'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,'</span> +</div><div class="line">  <span class="string">'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,'</span> +</div><div class="line">  <span class="string">'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view'</span>,</div><div class="line">  <span class="literal">true</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> isReservedTag = <span class="function"><span class="keyword">function</span> (<span class="params">tag</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> isHTMLTag(tag) || isSVG(tag)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 区分大小写</span></div><div class="line"><span class="keyword">var</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure></p>
<p>虽然 HTML 元素重名警告的标签数大大增加了，但重要的是重名区分大小写，所以我们可以愉快地使用 Input、Select、Option 等而不用担心重名。这个功劳属于 Vue 2.0 引入的 Virtual DOM。</p>
<h3 id="模板解析-1"><a href="#模板解析-1" class="headerlink" title="模板解析"></a>模板解析</h3><p>前面提到，Vue 2.0 相对于 1.0 的最大改进就是引入了 Virtual DOM，使模板的解析不依赖于 DOM。</p>
<p>使用 Virtual DOM 解析模板时，不必像 DOM 方式那样将模板中的标签名转成小写，而是原汁原味地保留原始标签名。然后，使用原始的标签名进行匹配组件。例如，<code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 不会转为为小写形式，直接以 MyComponent 为基础开始匹配。当然，匹配的规则与 1.0 是一样的，即依次匹配：原标签名、camelCase化的标签名、PascalCase化的标签名。</p>
<p>之前在 1.0 不能正常运行的示例代码，在 2.0 中可以正常运行了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;MyComponent&gt;&lt;/MyComponent&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在 Vue 1.0 和 2.0 中还有一种定义组件模板的方式，即使用 DOM 元素。在这种情况下，解析模板时仍然会将标签转为小写形式。所以下面的代码，在 1.0 和 2.0 均不能正常运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.html</span></div><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &lt;MyComponent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ main.js</span></div><div class="line"><span class="regexp">Vue.component('MyComponent', &#123;</span></div><div class="line"><span class="regexp">  template: '&lt;div&gt;hello, world&lt;/</span>div&gt;<span class="string">'</span></div><div class="line"><span class="string">&#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">new Vue(&#123;</span></div><div class="line">  el: '#app'</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="命名限制-1"><a href="#命名限制-1" class="headerlink" title="命名限制"></a>命名限制</h3><p>Vue 2.0 中组件的命名限制与 1.0 的最大区别在于区分了大小写。总结一下就是：一是不使用非法的标签字符；二是不与 HTML 元素（区分大小写）或 SVG 元素（不区分大小写）重名；三是不使用 Vue 保留的 slot 和 component（区分大小写）。</p>
<p>除了以上三条，由于 Vue 2.0 内置了 KeepAlive、Transition、TransitionGroup 三个组件，所以尽量避免与这三个组件重名。但从另一方面讲，你也可以故意重名来实现一些特殊的功能。例如，keep-alive 的匹配顺序为 keep-alive、keepAlive、KeepAlive，所以我们可以注册一个 keep-alive 组件来拦截 KeepAlive 匹配。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我们可以知道 Vue 2.0 完全可以像 React 那样使用 PascalCase 形式的组件标签。对于 Vue 1.0，想以 PascalCase 形态写模板，尽量以全小写或者仅首字母大写形式注册组件，例如 <code>&lt;InputNumber&gt;</code> 组件，可以注册为 inputnumber 或者 Inputnumber。但是，如果你想在 1.0 中使用 Input、Select 这类与 HTML 元素重名的标签名，基本上是无解的，所以是时候尝试下 Vue 2.0 了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;There are only two things in Computer Sciences: cache invalidation and naming things.&lt;br&gt;—— Phil Karlton&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue.js 2.0 独立构建和运行时构建的区别</title>
    <link href="https://jingsam.github.io/2016/10/23/standalone-vs-runtime-only-build-in-vuejs2.html"/>
    <id>https://jingsam.github.io/2016/10/23/standalone-vs-runtime-only-build-in-vuejs2.html</id>
    <published>2016-10-23T04:54:52.000Z</published>
    <updated>2017-10-19T23:34:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Vue.js 2.0 时，有独立构建（standalone）和运行时构建（runtime-only）两种版本可供选择。而在 Vue.js 1.0 中，却没有这种版本区别。到底该使用哪一个版本？这让我有点懵逼的感觉。本着知其然还要知其所以然的精神，我决定好好研究下两者间的区别。</p>
<p>Vue.js 的官方教程上是这么说的：</p>
<blockquote>
<ul>
<li>独立构建包括编译和支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。</li>
<li>运行时构建不包括模板编译，不支持 template 选项。运行时构建，可以用 render 选项，但它只在单文件组件中起作用，因为单文件组件的模板是在构建时预编译到 render 函数中，运行时构建只有独立构建大小的 30%，只有 16Kb min+gzip 大小。</li>
</ul>
</blockquote>
<p>看了半天，实在没搞清两者之间的区别。经过一番搜索，终于搞清楚了问题的本源，且听我娓娓道来。</p>
<p>Vue.js 的运行过程实际上包含两步。第一步，编译器将字符串模板（template）编译为渲染函数（render），称之为编译过程；第二步，运行时实际调用编译的渲染函数，称之为运行过程。</p>
<p>由于 Vue.js 1.0 的编译过程需要依赖浏览器的 DOM，所以无法（或者说没有意义）将编译器和运行时分开。因此在 Vue.js 1.0 分发包中，编译器和运行时是打包在一起，都在浏览器端执行。</p>
<p>然而到了 Vue.js 2.0，为了支持服务端渲染（server-side rendering），编译器不能依赖于 DOM，所以必须将编译器和运行时分开。这就形成了独立构建（编译器 + 运行时）和运行时构建（仅运行时）。显而易见，运行时构建要小于独立构建。</p>
<p>在现代前端工程构建中，通常会使用 vue-loader 和 vueify 预编译模板。在这种情况下，只需要打包运行时，而不需要打包编译器，运行时构建即可满足所需。当然，如果你需要在前端使用 <code>template</code> 选项实时编译模板，那么还是需要使用独立构建将编译器发送到浏览器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Vue.js 2.0 时，有独立构建（standalone）和运行时构建（runtime-only）两种版本可供选择。而在 Vue.js 1.0 中，却没有这种版本区别。到底该使用哪一个版本？这让我有点懵逼的感觉。本着知其然还要知其所以然的精神，我决定好好研究下两者
    
    </summary>
    
    
  </entry>
  
</feed>
