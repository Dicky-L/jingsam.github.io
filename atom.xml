<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jingsam</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jingsam.github.io/"/>
  <updated>2017-10-20T02:43:33.042Z</updated>
  <id>https://jingsam.github.io/</id>
  
  <author>
    <name>jingsam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mapbox-gl如何高效地高亮要素</title>
    <link href="https://jingsam.github.io/2017/10/20/mapbox-gl-highlight.html"/>
    <id>https://jingsam.github.io/2017/10/20/mapbox-gl-highlight.html</id>
    <published>2017-10-20T00:42:01.000Z</published>
    <updated>2017-10-20T02:43:33.042Z</updated>
    
    <content type="html"><![CDATA[<p>mapbox-gl基于矢量瓦片的前端渲染技术，使得要素高亮变得简单。要素高亮具体如何实现，有如下三种方法：</p>
<h1 id="第一种：动态过滤"><a href="#第一种：动态过滤" class="headerlink" title="第一种：动态过滤"></a>第一种：动态过滤</h1><p>这种方法的基本思路是添加一个高亮图层，然后根据鼠标hover的要素id，动态地改变filter条件，实现要素的高亮。</p>
<p>使用到的主要接口是<code>map.on(&#39;mousemove&#39;, layer, e)</code>，其中<code>e</code>可以获取到当前鼠标位置的features，效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/f3au0qLo/2/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试中发现，在图斑比较密集的情况下，高亮非常卡，滞后严重，效率并不高。</p>
<h1 id="第二种：数据源镜像"><a href="#第二种：数据源镜像" class="headerlink" title="第二种：数据源镜像"></a>第二种：数据源镜像</h1><p>第二种方法是对第一种方法的改进，思路如下：对原始数据源做一个镜像，即添加一个新的数据源，名称不通但指向的是同一套数据,例如下面示例中的<code>source-mirror</code>，高亮图层的数据源指向<code>source-mirror</code>。改进后的效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/rj16bqa4/1/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试可以发现，稍微改进一下，高亮的效率提升很大。</p>
<p>但为什么做一个数据源镜像就可以显著地提高高亮的效率呢？我猜想是mapbox-gl在绘制时，会按照数据源对图层分组。指向同一个数据源的图层组中，任意一个图层的渲染条件改变，将会以整个图层组为粒度重新进行运算。在第一种方法中，高亮图层和其他图层都指向同一个数据源，动态地改变高亮图层的过滤条件，导致了很大的运算开销。而第二种方法，为高亮图层单独分配一个数据源，动态地改变高亮图层的过滤条件，也只会导致高亮图层的重绘。</p>
<h1 id="第三种：动态生成高亮数据源"><a href="#第三种：动态生成高亮数据源" class="headerlink" title="第三种：动态生成高亮数据源"></a>第三种：动态生成高亮数据源</h1><p>我们能不能再进一步提高高亮的效率呢？有。第三种方法的思路是：为高亮图层生成一个空的GeoJSON数据源，然后将鼠标hover到的要素动态地填充到数据源中。</p>
<p>使用的接口只要是<code>map.getSource(source).setData(geojson)</code>，其中<code>getSource</code>用于根据sourceId获取数据源，<code>setData</code>用于动态更新数据。效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/ykoyet0w/3/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试可以发现，这种方法甚至比第二种方法效率更高。原因在于要高亮的要素往往很小，前段切成瓦片可能就一两张，因此不用去整体从原始数据源的瓦片种过滤，效率会更高。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一种方法最常用，小批量数据效率还行，但涉及到大数据量情况下，效率就不太理想了。</p>
<p>第二种方法通过小小的改进，就可以极大地提高效率，实现起来也很简单。</p>
<p>第三种方法效率最高，但其中引入了<code>turf.union</code>去合并features，带来了额外的依赖。因此，从简单和优雅的角度来说，我更推荐使用第二种方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mapbox-gl基于矢量瓦片的前端渲染技术，使得要素高亮变得简单。要素高亮具体如何实现，有如下三种方法：&lt;/p&gt;
&lt;h1 id=&quot;第一种：动态过滤&quot;&gt;&lt;a href=&quot;#第一种：动态过滤&quot; class=&quot;headerlink&quot; title=&quot;第一种：动态过滤&quot;&gt;&lt;/a&gt;第
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker save与docker export的区别</title>
    <link href="https://jingsam.github.io/2017/08/26/docker-save-and-docker-export.html"/>
    <id>https://jingsam.github.io/2017/08/26/docker-save-and-docker-export.html</id>
    <published>2017-08-26T06:24:00.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>很久没有写博客了，坟头草都长了老高了。写博客要靠惯性，一旦停下来时间长了，就很难再坚持下去。今天艰难地捡起来，以后每周至少写一篇。</p>
<p>这篇文章讲一讲docker save和docker export的区别。</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>docker save和docker export都能导出镜像包，咋看起来区别似乎不大。本文就针对这个问题，试图搞清楚docker save和docker export的功能是什么？适用于什么应用场景？</p>
<p>本文的测试的Docker版本如下，不保证所有版本的docker都能重现本文的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;docker version</div><div class="line"></div><div class="line">Client:</div><div class="line"> Version:      17.07.0-ce-rc1</div><div class="line"> API version:  1.31</div><div class="line"> Go version:   go1.8.3</div><div class="line"> Git commit:   8c4be39</div><div class="line"> Built:        Wed Jul 26 05:19:44 2017</div><div class="line"> OS/Arch:      windows/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line"> Version:      17.07.0-ce-rc1</div><div class="line"> API version:  1.31 (minimum version 1.12)</div><div class="line"> Go version:   go1.8.3</div><div class="line"> Git commit:   8c4be39</div><div class="line"> Built:        Wed Jul 26 05:25:01 2017</div><div class="line"> OS/Arch:      linux/amd64</div><div class="line"> Experimental: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>另外我是在Windows on bash里面操作docker，有些命令如<code>ls</code>并不是windows命令，如果想要复现我的试验，请换成相应的windows命令。</p>
<h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p>docker的命令行接口设计得很优雅，很多命令的帮助直接在后面加<code>--help</code>就可以查看。</p>
<p>docker save的帮助如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker save --<span class="built_in">help</span></div><div class="line"></div><div class="line">Usage:  docker save [OPTIONS] IMAGE [IMAGE...]</div><div class="line"></div><div class="line">Save one or more images to a tar archive (streamed to STDOUT by default)</div><div class="line"></div><div class="line">Options:</div><div class="line">      --<span class="built_in">help</span>            Print usage</div><div class="line">  -o, --output string   Write to a file, instead of STDOUT</div></pre></td></tr></table></figure></p>
<p>从命令行帮助可以看出，docker save是用来将一个或多个image打包保存的工具。</p>
<p>例如我们想将镜像库中的postgres和mongo打包，那么可以执行：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">docker</span> <span class="selector-tag">save</span> <span class="selector-tag">-o</span> <span class="selector-tag">images</span><span class="selector-class">.tar</span> <span class="selector-tag">postgres</span><span class="selector-pseudo">:9.6</span> <span class="selector-tag">mongo</span><span class="selector-pseudo">:3.4</span></div></pre></td></tr></table></figure></p>
<p>打包之后的<code>images.tar</code>包含<code>postgres:9.6</code>和<code>mongo:3.4</code>这两个镜像。</p>
<p>虽然命令行参数要求指定image，实际上也可以对container进行打包，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</div><div class="line">3623943d369f        postgres:9.6        <span class="string">"docker-entrypoint..."</span>   3 hours ago         Up 3 hours          5432/tcp            postgres</div><div class="line"></div><div class="line">&gt;docker save -o b.tar postgres</div><div class="line">&gt;docker save -o c.tar postgres:9.6</div><div class="line">&gt;ls -al</div><div class="line">-rwxrwxrwx 1 root root 277886464 8月  26 14:40 b.tar</div><div class="line">-rwxrwxrwx 1 root root 277886464 8月  26 14:41 c.tar</div></pre></td></tr></table></figure></p>
<p>通过以上命令可以看到，<code>b.tar</code>和<code>c.tar</code>是完全一模一样的。这说明，docker save如果指定的是container，docker save将保存的是容器背后的image。</p>
<p>将打包后的镜像载入进来使用docker load，例如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker load -<span class="selector-tag">i</span> images.tar</div></pre></td></tr></table></figure></p>
<p>上述命令将会把<code>postgres:9.6</code>和<code>mongo:3.4</code>载入进来，如果本地镜像库已经存在这两个镜像，将会被覆盖。</p>
<p>docker save的应用场景是，如果你的应用是使用docker-compose.yml编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用docker save将用到的镜像打个包，然后拷贝到客户服务器上使用docker load载入。</p>
<h2 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export"></a>docker export</h2><p>照例查看下docker export的帮助：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker <span class="keyword">export</span> <span class="comment">--help</span></div><div class="line"></div><div class="line"><span class="type">Usage</span>:  docker <span class="keyword">export</span> [<span class="type">OPTIONS</span>] <span class="type">CONTAINER</span></div><div class="line"></div><div class="line"><span class="type">Export</span> a container's filesystem <span class="keyword">as</span> a tar archive</div><div class="line"></div><div class="line"><span class="type">Options</span>:</div><div class="line">      <span class="comment">--help            Print usage</span></div><div class="line">  -o, <span class="comment">--output string   Write to a file, instead of STDOUT</span></div></pre></td></tr></table></figure></p>
<p>从帮助可以看出，docker export是用来将container的文件系统进行打包的。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">export</span> -o postgres-<span class="keyword">export</span>.tar postgres</div></pre></td></tr></table></figure></p>
<p>docker export需要指定container，不能像docker save那样指定image或container都可以。</p>
<p>将打包的container载入进来使用docker import，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="keyword">import</span> postgres-<span class="keyword">export</span>.tar postgres:latest</div></pre></td></tr></table></figure></p>
<p>从上面的命令可以看出，docker import将container导入后会成为一个image，而不是恢复为一个container。</p>
<p>另外一点是，docker import可以指定IMAGE[:TAG]，说明我们可以为镜像指定新名称。如果本地镜像库中已经存在同名的镜像，则原有镜像的名称将会被剥夺，赋给新的镜像。原有镜像将成为孤魂野鬼，只能通过IMAGE ID进行操作。</p>
<p>docker export的应用场景主要用来制作基础镜像，比如你从一个ubuntu镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p>
<h2 id="docker-save和docker-export的区别"><a href="#docker-save和docker-export的区别" class="headerlink" title="docker save和docker export的区别"></a>docker save和docker export的区别</h2><p>总结一下docker save和docker export的区别：</p>
<ol>
<li>docker save保存的是镜像（image），docker export保存的是容器（container）；</li>
<li>docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；</li>
<li>docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。</li>
</ol>
<h2 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h2><p>前面所讲的内容都是些基础知识，相信各位读者只要仔细看下官方文档就能知晓。这一节我来讲讲文档上没有的东西。</p>
<p>docker load和docker import都可以将tar包导入为镜像，我不禁脑洞一下，docker load能不能导入docker export的容器包，docker import能不能导入docker save的镜像包呢？</p>
<p>以下开始试验，准备以下两个文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;ls -al</div><div class="line">-rwxrwxrwx 1 root root 271760384 8月  26 12:15 postgres-export.tar</div><div class="line">-rwxrwxrwx 1 root root 398292480 8月  26 12:13 postgres-save.tar</div></pre></td></tr></table></figure></p>
<p>其中<code>postgres-export.tar</code>是通过docker export导出的容器包，<code>postgres-save.tar</code>是通过docker save保存的镜像包，两者都是基于<code>postgres:9.6</code>镜像。从文件大小可以直观的发现，<code>postgres-export.tar</code>显然要比<code>postgres-save.tar</code>小100多M。</p>
<p>现在试试docker load容器包<code>postgres-export.tar</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;docker load -i postgres-export.tar</div><div class="line">open /var/lib/docker/tmp/docker-import-082344818/bin/json: no such file or directory</div></pre></td></tr></table></figure></p>
<p>显然，docker load不能载入容器包。</p>
<p>那么，反过来，docker import载入镜像包可不可以呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;docker import postgres-save.tar postgres</div><div class="line">sha256:8910feec1ee2fac8c152dbdd0aaab360ba0b833af5c3ad59fcd648b9a24d4838</div><div class="line">&gt;docker image ls</div><div class="line">REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">postgres                                        latest              8910feec1ee2        2 minutes ago       398MB</div></pre></td></tr></table></figure></p>
<p>WTF，竟然成功了！！！</p>
<p>莫慌，再试试启动一个postgres容器：<br><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;docker run postgres</div><div class="line">C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\r</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker.exe: Error response from daemon: No command specified.</div><div class="line">See 'C:<span class="symbol">\P</span>rogram Files<span class="symbol">\D</span>ocker<span class="symbol">\D</span>ocker<span class="symbol">\r</span>esources<span class="symbol">\b</span>in<span class="symbol">\d</span>ocker.exe run --help'.</div></pre></td></tr></table></figure></p>
<p>虽然能够成功地导入为一个镜像，然而这个镜像并不能使用。</p>
<p>要搞清楚到底是怎么回事，我们先看看镜像包和容器包由什么区别：</p>
<p><img src="/assets/docker-save-vs-docker-export.png" alt="docker save vs docker export"></p>
<p>从上面可以看出右边的<code>postgres-export.tar</code>的内容是一个linux系统的文件目录，猜测就是一个linux镜像。而<code>postgres-save.tar</code>里面到底是什么内容呢？点开一个文件夹看看：</p>
<p><img src="/assets/postgres-save.png" alt="postgres-save.tar"></p>
<p>其实就是一个分层的文件系统。Docker镜像实际上就是由这样的一层层文件进行叠加起来的，上层的文件会覆盖下层的同名文件。如果将<code>postgres-save.tar</code>中的各层文件合并到一起，基本就是<code>postgres-export.tar</code>的内容。由于<code>postgres-save.tar</code>里面的各层文件会存在很多重复的文件，这也解释了为什么<code>postgres-save.tar</code>会比<code>postgres-export.tar</code>大100多M。</p>
<p>docker load必须要载入的是一个分层文件系统，而<code>postgres-export.tar</code>并不具有这样的结构，因此无法载入。</p>
<p>而docker import仅仅是将tar包里面的文件复制进来，所以不管tar包里面的文件结构是怎样的，都可以载入进来，所以能够载入<code>postgres-save.tar</code>。但<code>postgres-save.tar</code>并不是一个有效的操作系统镜像，因此当我试图以改镜像启动容器时，容器并不能启动。</p>
<p>我们再来看看docker import的帮助：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Usage:  docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</div><div class="line"></div><div class="line">Import the contents from a tarball to create a filesystem image</div><div class="line"></div><div class="line">Options:</div><div class="line">  -c, --change list      Apply Dockerfile instruction to the created image</div><div class="line">      --<span class="built_in">help</span>             Print usage</div><div class="line">  -m, --message string   Set commit message <span class="keyword">for</span> imported image</div></pre></td></tr></table></figure></p>
<p>似乎和docker commit很像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</div><div class="line"></div><div class="line">Create a new image from a container<span class="string">'s changes</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">Options:</span></div><div class="line"><span class="string">  -a, --author string    Author (e.g., "John Hannibal Smith</span></div><div class="line"><span class="string">                         &lt;hannibal@a-team.com&gt;")</span></div><div class="line"><span class="string">  -c, --change list      Apply Dockerfile instruction to the created image</span></div><div class="line"><span class="string">      --help             Print usage</span></div><div class="line"><span class="string">  -m, --message string   Commit message</span></div><div class="line"><span class="string">  -p, --pause            Pause container during commit (default true)</span></div></pre></td></tr></table></figure></p>
<p>发现docker import和docker commit都有<code>--change</code>和<code>--message</code>选项。我们可以将docker import理解为将外部文件复制进来形成只有一层文件系统的镜像，而docker commit则是将当前的改动提交为一层文件系统，然后叠加到原有镜像之上。</p>
<p>关于docker save和docker export的区别讲得差不多，拜了个拜。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://docs.docker.com/engine/reference/commandline/save/" target="_blank" rel="external">docker save帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/load/" target="_blank" rel="external">docker load帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/export/" target="_blank" rel="external">docker export帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/import/" target="_blank" rel="external">docker import帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/commit/" target="_blank" rel="external">docker commit帮助文档</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没有写博客了，坟头草都长了老高了。写博客要靠惯性，一旦停下来时间长了，就很难再坚持下去。今天艰难地捡起来，以后每周至少写一篇。&lt;/p&gt;
&lt;p&gt;这篇文章讲一讲docker save和docker export的区别。&lt;/p&gt;
&lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue之slot深度复制</title>
    <link href="https://jingsam.github.io/2017/03/08/vnode-deep-clone.html"/>
    <id>https://jingsam.github.io/2017/03/08/vnode-deep-clone.html</id>
    <published>2017-03-08T11:41:02.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>在Vue中，<code>slot</code>是一个很有用的特性，可以用来向组件内部插入一些内容。<code>slot</code>就是“插槽”的意思，用大白话说就是：定义组件的时候留几个口子，由用户来决定插入的内容。</p>
<p>例如我们定义一个组件<code>MyComponent</code>，其包含一个<code>slot</code>:<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: `<span class="javascript"></span></div><div class="line"><span class="javascript">    &lt;div&gt;</span></div><div class="line"><span class="javascript">      &lt;slot&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></div><div class="line"><span class="javascript">    &lt;<span class="regexp">/div&gt;</span></span></div><div class="line"><span class="javascript">  </span>`</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当调用<code>&lt;MyComponent&gt;123&lt;/MyComponent&gt;</code>时，会渲染为如下DOM结构：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">&lt;div&gt;</span></div><div class="line">  <span class="attribute">123</span></div><div class="line"><span class="section">&lt;/div&gt;</span></div></pre></td></tr></table></figure></p>
<p>现在又有新需求了，我们希望调用<code>&lt;MyComponent&gt;123&lt;/MyComponent&gt;</code>时，渲染出这样的DOM结构：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">&lt;div&gt;</span></div><div class="line">  <span class="attribute">123</span></div><div class="line">  <span class="attribute">123</span></div><div class="line"><span class="section">&lt;/div&gt;</span></div></pre></td></tr></table></figure></p>
<p>看起来很容易实现，即再为<code>MyComponent</code>添加一个<code>slot</code>:<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: `<span class="javascript"></span></div><div class="line"><span class="javascript">    &lt;div&gt;</span></div><div class="line"><span class="javascript">      &lt;slot&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></div><div class="line"><span class="javascript">      &lt;slot&gt;<span class="xml"><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span></div><div class="line"><span class="javascript">    &lt;<span class="regexp">/div&gt;</span></span></div><div class="line"><span class="javascript">  </span>`</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>渲染出的结构也确实如你所愿，唯一美中不足的是控制台有一个小小的Warning：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Duplicate presence <span class="keyword">of</span> slot <span class="string">"default"</span> found <span class="keyword">in</span> <span class="keyword">the</span> same render tree</div></pre></td></tr></table></figure></p>
<p>如果你不是强迫症患者，这时候你可以收工安心回家睡觉了。直到有一天你的同事向你抱怨，为什么向<code>MyComponent</code>插入一个自定义组件会渲染不出来？</p>
<p>例如有一自定义组件<code>MyComponent2</code>：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent2'</span>, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;<span class="keyword">div</span>&gt;<span class="number">456</span>&lt;/<span class="keyword">div</span>&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当调用<code>&lt;MyComponent&gt;&lt;MyComponent2&gt;&lt;/MyComponent2&gt;&lt;/MyComponent&gt;</code>时，预期渲染为如下DOM结构：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">div</span>&gt;</div><div class="line">  &lt;<span class="keyword">div</span>&gt;<span class="number">456</span>&lt;/<span class="keyword">div</span>&gt;</div><div class="line">  &lt;<span class="keyword">div</span>&gt;<span class="number">456</span>&lt;/<span class="keyword">div</span>&gt;</div><div class="line">&lt;/<span class="keyword">div</span>&gt;</div></pre></td></tr></table></figure></p>
<p>为什么不能正常工作呢？估计是前面的那个Warning搞得鬼，通过查询发现在Vue 2.0中不允许有重名的<code>slot</code>:</p>
<blockquote>
<p>重名的 Slots 移除<br>同一模板中的重名 <slot> 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用 prop 来传递。</slot></p>
</blockquote>
<p>文档中提示可以用<code>props</code>来实现，然而在我的用例中显然是不合适的。经过搜索后，最靠谱的方法是手写render函数，将<code>slot</code>中的内容复制到其他的位置。</p>
<p>将之前的<code>MyComponent</code>改为render函数的方式定义：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  render (createElement) &#123;</div><div class="line">    return createElement(<span class="string">'div'</span>, [</div><div class="line">      ..<span class="selector-class">.this</span>.<span class="variable">$slots</span><span class="selector-class">.default</span>,</div><div class="line">      ..<span class="selector-class">.this</span>.<span class="variable">$slots</span>.default</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在上面的定义中我们插入了两个<code>this.$slots.default</code>，测试下能不能正常工作。然而并没有什么卵用，Vue文档在render函数这一章有以下说明：</p>
<blockquote>
<p>VNodes 必须唯一<br>所有组件树中的 VNodes 必须唯一</p>
</blockquote>
<p>这意味着我们不能简单地在不同位置引用<code>this.$slots.default</code>，必须对<code>slot</code>进行深度复制。深度复制的函数如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function deepClone(vnodes, createElement) &#123;</div><div class="line"></div><div class="line">  function <span class="keyword">cloneVNode </span>(vnode) &#123;</div><div class="line">    const <span class="keyword">clonedChildren </span>= vnode.children &amp;&amp; vnode.children.map(vnode =&gt; <span class="keyword">cloneVNode(vnode));</span></div><div class="line"><span class="keyword"> </span>   const <span class="keyword">cloned </span>= createElement(vnode.tag, vnode<span class="meta">.data</span>, <span class="keyword">clonedChildren);</span></div><div class="line"><span class="keyword"> </span>   <span class="keyword">cloned.text </span>= vnode<span class="meta">.text</span><span class="comment">;</span></div><div class="line">    <span class="keyword">cloned.isComment </span>= vnode.isComment<span class="comment">;</span></div><div class="line">    <span class="keyword">cloned.componentOptions </span>= vnode.componentOptions<span class="comment">;</span></div><div class="line">    <span class="keyword">cloned.elm </span>= vnode.elm<span class="comment">;</span></div><div class="line">    <span class="keyword">cloned.context </span>= vnode.context<span class="comment">;</span></div><div class="line">    <span class="keyword">cloned.ns </span>= vnode.ns<span class="comment">;</span></div><div class="line">    <span class="keyword">cloned.isStatic </span>= vnode.isStatic<span class="comment">;</span></div><div class="line">    <span class="keyword">cloned.key </span>= vnode.key<span class="comment">;</span></div><div class="line"></div><div class="line">    return <span class="keyword">cloned;</span></div><div class="line"><span class="keyword"> </span> &#125;</div><div class="line"></div><div class="line">  const <span class="keyword">clonedVNodes </span>= vnodes.map(vnode =&gt; <span class="keyword">cloneVNode(vnode))</span></div><div class="line"><span class="keyword"> </span> return <span class="keyword">clonedVNodes;</span></div><div class="line"><span class="keyword">&#125;</span></div></pre></td></tr></table></figure></p>
<p>上面的核心函数就是<code>cloneVNode()</code>，它递归地创建VNode，实现深度复制。VNode的属性很多，我并不了解哪些是关键属性，只是参照着Vue的源码一并地复制过来。</p>
<p>基于以上函数，我们更改<code>MyComponent</code>的定义：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  render (createElement) &#123;</div><div class="line">    <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</div><div class="line">      ...<span class="keyword">this</span>.$slots.<span class="keyword">default</span>,</div><div class="line">      ...deepClone(<span class="keyword">this</span>.$slots.<span class="keyword">default</span>, createElement)</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>经测试，一切正常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Vue 1.0中重名的slots并不会出现什么问题，不知道为什么在2.0中取消了这个功能。我听说React提供了复制Element的标准函数，希望Vue也能提供这个函数，免得大家踩坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Vue中，&lt;code&gt;slot&lt;/code&gt;是一个很有用的特性，可以用来向组件内部插入一些内容。&lt;code&gt;slot&lt;/code&gt;就是“插槽”的意思，用大白话说就是：定义组件的时候留几个口子，由用户来决定插入的内容。&lt;/p&gt;
&lt;p&gt;例如我们定义一个组件&lt;code&gt;MyCo
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手机上也可以愉快地搞nodejs开发</title>
    <link href="https://jingsam.github.io/2017/02/07/nodejs-on-android.html"/>
    <id>https://jingsam.github.io/2017/02/07/nodejs-on-android.html</id>
    <published>2017-02-07T09:18:58.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在微博上看到尤雨溪的这么一则微博：<br><img src="/assets/2017-02-07-1.png" alt=""></p>
<p>嗬！在手机上也能跑nodejs，有点儿意思哈。顺手查了查nodejs官网，发现nodejs是支持ARM处理器的，有了这个先决条件，手机上跑nodejs应该没什么大障碍了。本文就来分享一下我在手机上跑nodejs的一点经验。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你得有一部Android手机，iPhone的硬件条件有，但是由于IOS是一个封闭的系统，实际操作起来会很困难。</p>
<p>软件方面需要安装<a href="1">Termux</a>，这是Android平台下的一个开源的终端模拟器。</p>
<p>另外，我建议安装一个编程键盘<a href="2">Hacker’s Keyboard</a>，因为一般的输入法没有Ctrl、Alt、Tab、Esc这些常用控制键，到时候会很麻烦。安装Hacker’s Keyboard，设置为全键盘模式。</p>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>首先得把nodejs安装到手机上。Termux强大的地方在于它带有一个包管理器<code>apt</code>，使用<code>apt</code>可以直接安装nodejs：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt <span class="keyword">update</span></div><div class="line">apt <span class="keyword">install</span> nodejs</div></pre></td></tr></table></figure></p>
<p>这样node和npm都安装好了，node的版本是v6.9.4，版本还比较新。</p>
<p>搞开发嘛，做好把git和vim也安装上：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt <span class="keyword">install</span> git vim</div></pre></td></tr></table></figure></p>
<p>有了npm之后，我们就可以随意安装需要的包了，这里以vue-cli为例，来跑一个vuejs工程。过程与在电脑上是一样的：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm i vue-<span class="keyword">cli</span> -<span class="keyword">g</span></div><div class="line">vue init webpack vue-<span class="keyword">test</span></div><div class="line"><span class="keyword">cd</span> vue-<span class="keyword">test</span></div><div class="line">npm <span class="built_in">i</span></div><div class="line">npm <span class="keyword">run</span> dev</div></pre></td></tr></table></figure></p>
<p>浏览器打开localhost:8080，你就可以看到vuejs的欢迎页面了。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>由于Android权限管理的原因，你并不能随意地在任何位置写入文件。你的活动范围必须在Termux的权限之内，即<code>data/data/com.termux/files</code>目录下。虽然你可以写文件到SD卡，但是有些包symbolink的时候会失败，所以保险的做法是所有的操作都在HOME目录下进行，即<code>data/data/com.termux/files/home</code>目录。</p>
<p>在HOME目录下操作的坏处是，但你卸载Termux时，HOME下的所有文件也会删除。所以玩玩而已，不要当真，哈哈！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实话讲，在手机上不长不方便，我想有一下3点：</p>
<ol>
<li>屏幕太小。本来屏幕空间就有限，输入法还要占一半，估计可以通过投屏解决；</li>
<li>没有好的编辑器。本来就没人会在手机上搞正经开发嘛，所以不会有好的编辑器，还好Vim可以凑合着用；</li>
<li>输入不方便。这个也是最大的问题，手机键盘真的太不方便了，有点想念诺基亚N97了。</li>
</ol>
<p><img src="/assets/2017-02-07-2.jpg" alt=""></p>
<p>关于手机键盘，最好能携带方便，搜了下淘宝，下面两款似乎不错哦：<br><img src="/assets/2017-02-07-3.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;在微博上看到尤雨溪的这么一则微博：&lt;br&gt;&lt;img src=&quot;/assets/2017-02-07-1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用travis-ci持续部署nodejs应用</title>
    <link href="https://jingsam.github.io/2017/01/23/deploy-nodejs-with-travis-ci.html"/>
    <id>https://jingsam.github.io/2017/01/23/deploy-nodejs-with-travis-ci.html</id>
    <published>2017-01-23T03:26:23.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>Travis-ci是一款持续集成（Continuous Integration）服务，它能够很好地与Github结合，每当代码更新时自动地触发集成过程。</p>
<p>Travis-ci配置简单，很多nodejs项目都用它做自动测试。然而，对于持续集成，仅做到自动测试是不够的，还要有后续的自动部署，才能完成“提交代码 =&gt; 自动测试 =&gt; 自动部署”的集成链条。</p>
<p>本文以nodejs应用为例，来谈谈如何利用travis-ci完成自动部署。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>从自动测试到自动部署的核心问题是测试机与生产服务器的信任问题，即如何安全地把程序包传输到生产服务器。市面上的部署工具如scp、ansible、chef，都绕不开这个核心问题。</p>
<p>以scp为例，测试机登录生产服务器的方式有两种：密码和秘钥。密码登录方式需要交互式地输入密码，总不能每次测试的时候，人为地输入密码吧，所以密码方式行不通。</p>
<p>秘钥的方式可以实现自动登录，但首次将测试机的公钥传输给生产服务器仍然需要密码。似乎走入了死胡同，但办法总是有的。我们知道开发机是可以登录到生产服务器的，那么我们就可以<strong>将开发机的公钥复制到生产服务器，将开发机的私钥复制到测试机，测试机通过私钥来伪装成开发机，自动地登录到生产服务器</strong>。</p>
<p>解决了自动登录的问题，另一个问题是怎么将开发机的私钥复制到测试机上。由于测试机每次都是新开的一个虚拟机，这个新开的虚拟机IP不固定，所以没办法直接登录上去。解决办法是将私钥文件作为代码库的一部分提交，这样测试机每次从代码库上拉取代码的同时也获取到了秘钥文件，通过这种方式就实现了私钥从开发机复制到测试机。</p>
<p>将私钥文件提交到代码库有一个很严重的安全性问题，即任何人只要得到了这个私钥文件，他就可以随心所欲的操纵生产服务器。幸好，travis-ci提供了加密方案，它能够将私钥文件加密，加密后的文件只在当前代码库有效。</p>
<p>总的来说，通过复制私钥完成自动登录以及对私钥加密来保障安全性，我们就可以建立起测试机与生产服务器的信任通道，测试机就可以安全地操作生产服务器完成自动部署。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>现在我以scp方式部署nodejs应用为例，来说明travis-ci做自动部署的配置。</p>
<p>首先，建立起开发机与生产服务器的信任关系：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-<span class="keyword">copy</span>-<span class="built_in">id</span> username@host</div></pre></td></tr></table></figure></p>
<p>然后，加密你的私钥，私钥文件通常在<code>~/.ssh/id_rsa</code>。加密私钥文件需要使用travis这个命令行工具，它是一个ruby包，使用gem安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gem install travis</div><div class="line">travis login</div></pre></td></tr></table></figure></p>
<p>输入账号密码登录成功后，使用<code>travis encrypt-file</code>加密：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis <span class="built_in">encrypt</span>-<span class="built_in">file</span> ~/.ssh/id_rsa <span class="comment">--add</span></div></pre></td></tr></table></figure></p>
<p>上面命令执行完后，会生成一段解密命令并添加到<code>.travis.yml</code>中：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">~/.ssh/id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div></pre></td></tr></table></figure></p>
<p>接下来，把加密后的私钥文件（id_rsa.enc）复制到代码库中，千万要注意不要错把未加密的私钥文件（id_rsa）复制到你的代码库中。然后把上面的解密命令的<code>-in ~/.ssh/id_rsa.enc</code>改为<code>-in id_rsa.enc</code>。</p>
<p>通过上面的过程就基本建立测试机与生产服务器的信任关系，但还有一些小细节要处理。例如，降低<code>id_rsa</code>文件的权限，否则ssh处于安全方面的原因会拒绝读取秘钥；将生产服务器地址加入到测试机的信任列表中，否则连接时会询问是否信任服务器。更改后的配置如下:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div><div class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line"><span class="bullet">  -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"Host 102.201.64.94\n\tStrictHostKeyChecking no\n"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></div></pre></td></tr></table></figure></p>
<p>最后，测试机就可以愉快地操作生产服务器了，例如下面是一个nodejs应用的<code>.travis.yml</code>文件配置：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="attr">language:</span> <span class="string">node_js</span></div><div class="line"><span class="attr">node_js:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">'4.4.4'</span></div><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div><div class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line"><span class="bullet">  -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"Host 102.201.64.94\n\tStrictHostKeyChecking no\n"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></div><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">prune</span> <span class="bullet">--production</span>  <span class="comment"># 删除devDependencies</span></div><div class="line"><span class="bullet">  -</span> <span class="string">tar</span> <span class="bullet">-jcf</span> <span class="string">indoor-server.tar.bz2</span> <span class="string">*</span>    <span class="comment"># 打包并压缩代码</span></div><div class="line"><span class="bullet">  -</span> <span class="string">scp</span> <span class="string">indoor-server.tar.bz2</span> <span class="string">jingsam@102.201.64.94:~/</span>  <span class="comment"># 复制到生产服务器上</span></div><div class="line"><span class="bullet">  -</span> <span class="string">ssh</span> <span class="string">jingsam@102.201.64.94</span> <span class="string">'mkdir -p indoor-server &amp;&amp; tar -jxf indoor-server.tar.bz2 -C indoor-server'</span>   <span class="comment"># 解压</span></div><div class="line"><span class="bullet">  -</span> <span class="string">ssh</span> <span class="string">jingsam@102.201.64.94</span> <span class="string">'cd indoor-server &amp;&amp; pm2 startOrReload pm2.json'</span>  <span class="comment"># 重启pm2</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章讲的自动部署其实与nodejs关系不大，完全适用于各种语言的自动部署，其原理都是相通的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Travis-ci是一款持续集成（Continuous Integration）服务，它能够很好地与Github结合，每当代码更新时自动地触发集成过程。&lt;/p&gt;
&lt;p&gt;Travis-ci配置简单，很多nodejs项目都用它做自动测试。然而，对于持续集成，仅做到自动测试是不够
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用node-pre-gyp加速二进制包安装</title>
    <link href="https://jingsam.github.io/2017/01/12/node-pre-gyp-mirror.html"/>
    <id>https://jingsam.github.io/2017/01/12/node-pre-gyp-mirror.html</id>
    <published>2017-01-12T02:36:34.000Z</published>
    <updated>2017-10-19T23:34:16.173Z</updated>
    
    <content type="html"><![CDATA[<p>node-pre-gyp是一个分发nodejs二进制程序包的工具，负责将预编译好的二进制程序直接下载到用户目录。它介于npm与node-gyp之间，只在相应平台二进制包不存在时才调用node-gyp编译。</p>
<p>node-pre-gyp存在的意义是什么呢？一些简单的nodejs C++扩展直接从源代码编译安装问题不大，但复杂的扩展编译环境难搭建、编译耗时长，因而从源代码安装非常麻烦。node-pre-gyp能够将预编译好的二进制包直接下载到用户目录，只在必要的时候才调用node-gyp从源代码编译，大大加快了nodejs C++扩展的安装速度。</p>
<p>node-pre-gyp需要开发者将各平台编译好的二进制包上传到网络上，并在package.json的<code>binary</code>字段指明二进制包的位置。然而，很多开发者选择将二进制包上传到aws上，导致国内无法正常下载（被墙）。幸好，可以在npm中设置<code>--{module_name}_binary_host_mirror</code>选项来指定二进制包的位置。例如，安装v8-profiler可以使用如下命令安装：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install v8-profiler --<span class="attr">profiler_binary_host_mirror=</span>https://npm.taobao.org/mirrors/<span class="keyword">node</span><span class="title">-inspector</span>/</div></pre></td></tr></table></figure></p>
<p>为了让国内开发者也能享受到node-pre-gyp带来的好处，我使用阿里云做了一个镜像，镜像的地址是：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http<span class="variable">s:</span>//foxgis.oss-<span class="keyword">cn</span>-shanghai.aliyuncs.<span class="keyword">com</span></div></pre></td></tr></table></figure></p>
<p>如果要安装sqlite3，执行以下命令：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install sqlite3 --sqlite3_binary_host_mirror=http<span class="variable">s:</span>//foxgis.oss-<span class="keyword">cn</span>-shanghai.aliyuncs.<span class="keyword">com</span></div></pre></td></tr></table></figure></p>
<p>目前是放到阿里云OSS上的，速度还可以，镜像上面包有：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mapnik mapbox-gl-<span class="keyword">native</span> sqlite3 fontnik gdal osrm zipfile</div></pre></td></tr></table></figure></p>
<p>如果有其他包需要放到上面的，请给我留言或者发邮件（abc#whu.edu.cn）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;node-pre-gyp是一个分发nodejs二进制程序包的工具，负责将预编译好的二进制程序直接下载到用户目录。它介于npm与node-gyp之间，只在相应平台二进制包不存在时才调用node-gyp编译。&lt;/p&gt;
&lt;p&gt;node-pre-gyp存在的意义是什么呢？一些简单的
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>少年，不要滥用箭头函数啊</title>
    <link href="https://jingsam.github.io/2016/12/08/things-you-should-know-about-arrow-functions.html"/>
    <id>https://jingsam.github.io/2016/12/08/things-you-should-know-about-arrow-functions.html</id>
    <published>2016-12-08T08:30:55.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<p>在ES6大行其道的今天，不应用点ES6特性似乎有些政治不正确。最近刚好有个Node的项目，最低要支持到nodejs 4.0，在<a href="1">node.green</a>看了下ES6的支持度，我想使用的特性基本都有支持，遂决定在新项目中采用ES6来写。</p>
<p>当然第一件事情就是毫不留情地消灭var，项目中能用const的地方不用let，能用let的地方不用var。</p>
<p>第二件事情就是使用劳动人民喜闻乐见的箭头函数替代function。当我心满意足地看到满屏的<code>=&gt;</code>时，现实给了我一记响亮的耳光——改过之后的程序错误百出！</p>
<p>所以，当我们使用箭头函数时，一定要搞清楚箭头函数是什么回事，适用于什么场景。本文就针对以上问题来讨论下箭头函数。</p>
<h2 id="箭头函数是什么？"><a href="#箭头函数是什么？" class="headerlink" title="箭头函数是什么？"></a>箭头函数是什么？</h2><p>箭头函数的语法我就不讲了，相信大家都见识过。跟我一样，大家喜欢箭头函数90%的原因是它好看。除了好看，它是不是与function等价呢？肯定不等价，因为TC39不可能仅因为好看而引入一个语法糖（class除外）。</p>
<p>箭头函数的渊源可以追溯到上古时期一个叫lambda演算的东西。lambda演算是数学家提出来的，有些数学家跟我们程序员一样也很懒，数学定理那么多，今天要证三角定律，明天要证勾股定律，累不累！那能不能将所有的证明问题用一个统一的体系进行形式化描述，然后由机器来完成自动推导呢？lambda演算就是干这个的，图灵也搞了一套体系叫图灵机，两者是等价的。</p>
<p>关于lambda演算说了这么多，好像跟今天要讲的箭头函数没什么关系？其实是有关系的，lambda演算深刻影响了箭头函数的设计。数学家们喜欢用纯函数式编程语言，纯函数的特点是没有副作用，给予特定的输入，总是产生确定的输出，甚至有些情况下通过输出能够反推输入。要实现纯函数，必须使函数的执行过程不依赖于任何外部状态，整个函数就像一个数学公式，给定一套输入参数，不管是在地球上还是火星上执行都是同一个结果。</p>
<p>箭头函数要实现类似纯函数的效果，必须剔除外部状态。所以当你定义一个箭头函数，在普通函数里常见的<code>this</code>、<code>arguments</code>、<code>caller</code>是统统没有的。</p>
<h2 id="箭头函数没有this"><a href="#箭头函数没有this" class="headerlink" title="箭头函数没有this"></a>箭头函数没有<code>this</code></h2><p>箭头函数没有<code>this</code>，那下面的代码明显可以取到<code>this</code>啊：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></div><div class="line">  <span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line"></div><div class="line">  b()</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>以上箭头函数中的<code>this</code>其实是父级作用域中的<code>this</code>，即函数<code>foo</code>的<code>this</code>。箭头函数引用了父级的变量，构成了一个闭包。以上代码等价于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></div><div class="line">  <span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(self.a)</div><div class="line"></div><div class="line">  b()</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>箭头函数不仅没有<code>this</code>，常用的<code>arguments</code>也没有。如果你能获取到<code>arguments</code>，那它一定是来自父作用域的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>])</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>上例中如果箭头函数有<code>arguments</code>，就应该输出的是3而不是1。</p>
<p>一个经常犯的错误是使用箭头函数定义对象的方法，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  foo: <span class="number">1</span>,</div><div class="line">  bar: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>以上代码中，箭头函数中的<code>this</code>并不是指向<code>a</code>这个对象。对象<code>a</code>并不能构成一个作用域，所以再往上到达全局作用域，<code>this</code>就指向全局作用域。如果我们使用普通函数的定义方法，输出结果就符合预期，这是因为<code>a.bar()</code>函数执行时作用域绑定到了<code>a</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  foo: <span class="number">1</span>,</div><div class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>另一个错误是在原型上使用箭头函数，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.foo = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">A.prototype.bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</div><div class="line">a.bar()  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>同样，箭头函数中的<code>this</code>不是指向<code>A</code>，而是根据变量查找规则回溯到了全局作用域。同样，使用普通函数就不存在问题。</p>
<p>通过以上说明，我们可以看出，箭头函数除了传入的参数之外，真的是什么都没有！如果你在箭头函数引用了<code>this</code>、<code>arguments</code>或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。</p>
<h2 id="什么情况下该使用箭头函数"><a href="#什么情况下该使用箭头函数" class="headerlink" title="什么情况下该使用箭头函数"></a>什么情况下该使用箭头函数</h2><p>到这里，我们可以发现箭头函数并不是万金油，稍不留神就会踩坑。</p>
<p>至于什么情况该使用箭头函数，《You Don’t Know About JS》给出了一个决策图：<br><img src="/assets/arrow-function.png" alt="arrow function"></p>
<p>以上决策图看起来有点复杂，我认为有三点比较重要：</p>
<ol>
<li>箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在<code>map</code>、<code>reduce</code>、<code>filter</code>的回调函数定义中；</li>
<li>不要在最外层定义箭头函数，因为在函数内部操作<code>this</code>会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将<code>this</code>控制在可见的范围内；</li>
<li>如开头所述，箭头函数最吸引人的地方是简洁。在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ES6大行其道的今天，不应用点ES6特性似乎有些政治不正确。最近刚好有个Node的项目，最低要支持到nodejs 4.0，在&lt;a href=&quot;1&quot;&gt;node.green&lt;/a&gt;看了下ES6的支持度，我想使用的特性基本都有支持，遂决定在新项目中采用ES6来写。&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>打包 Vue 组件库的正确姿势</title>
    <link href="https://jingsam.github.io/2016/11/18/bundle-vue-components.html"/>
    <id>https://jingsam.github.io/2016/11/18/bundle-vue-components.html</id>
    <published>2016-11-17T16:15:28.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便其他开发者使用组件库，开发的 Vue 组件库在发布之前需要对其打包。本文基于 Webpack 讨论打包 Vue 组件库的正确方法。</p>
<h2 id="选择正确的打包格式"><a href="#选择正确的打包格式" class="headerlink" title="选择正确的打包格式"></a>选择正确的打包格式</h2><p>首先，我们必须明确组件库的使用场景。有些场景是直接使用 <code>&lt;script&gt;</code> 在 HTML 中引入，有些场景是使用打包工具在后台构建。作为组件库，应该兼容这些使用场景。组件库应该保持中立，不应该限定于某种使用方式或者打包工具。例如，虽然 Webpack 很流行，组件库不能声明只支持 Webpack 方式使用，忽略了其他选择。原因在于，打包工具并不只有 webpack，还有 browserify、rollup 等。另外，前端工具发展很快，今年流行的工具明年可能就没人用了，你肯定不希望你的组件库会随着某个工具不流行而消逝吧。回顾下曾经流行的 grunt、glup，一大堆基于它们的插件随着工具本身的不流行而被扔进了垃圾箱。</p>
<p>为了支持多种使用场景，我们需要选择合适的打包格式。常见的打包格式有 CMD、AMD、UMD，CMD只能在 Node 环境执行，AMD 只能在浏览器端执行，UMD 同时支持两种执行环境。显而易见，我们应该选择 UMD 格式。Webpack 中指定输出格式的设置项为 <code>output.libraryTarget</code>，其支持的格式有：</p>
<ul>
<li>“var” - 以一个变量形式输出： var Library = xxx (default)；</li>
<li>“this” - 以 this 的一个属性输出： this[“Library”] = xxx；</li>
<li>“commonjs” - 以 exports 的一个属性输出：exports[“Library”] = xxx；</li>
<li>“commonjs2” - 以 module.exports 形式输出：module.exports = xxx；</li>
<li>“amd” - 以 AMD 格式输出；</li>
<li>“umd” - 同时以 AMD、CommonJS2 和全局属性形式输出。</li>
</ul>
<p>以下是 <code>webpack.config.js</code> 中 <code>output</code> 设置的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">    publicPath: <span class="string">'/dist/'</span>,</div><div class="line">    filename: <span class="string">'iview.js'</span>,</div><div class="line">    library: <span class="string">'iview'</span>,       <span class="comment">// 模块名称</span></div><div class="line">    libraryTarget: <span class="string">'umd'</span>,   <span class="comment">// 输出格式</span></div><div class="line">    umdNamedDefine: <span class="literal">true</span>    <span class="comment">// 是否将模块名称作为 AMD 输出的命名空间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此，我们解决了组件库输出的问题。</p>
<h2 id="如何打包组件依赖"><a href="#如何打包组件依赖" class="headerlink" title="如何打包组件依赖"></a>如何打包组件依赖</h2><p>在<a href="/2016/11/01/peerDependencies-in-Vue-components.html">前一篇</a>文章中我们讨论了组件库实质上是 Vue 的插件，Vue 应该是组件库的外部依赖。组件库的使用者会自行导入 Vue，打包的时候，不应该将 Vue 打包进组件库。</p>
<p>在 webpack 中，我们可以将 Vue 设置为 <code>externals</code>，以避免将 Vue 打包进组件库，相应的设置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">externals: &#123;</div><div class="line">    vue: <span class="string">'vue'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>啊哈，我们搞定了组件依赖问题。至此，读者可能很皱起眉头开始埋怨我了：这么简单的问题，查下 webpack 文档不就得了，还用得着我啰里啰嗦地写这么多！</p>
<p>事实上，问题往往没有我们想得那么简单！如果你将打包后的组件库以 <code>&lt;script&gt;</code> 标签形式直接引入，你会发现并不能正常执行，提示 vue 未定义。</p>
<p>为了分析问题，我们将打包的代码前几行拿出来看看：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">webpackUniversalModuleDefinition</span>(<span class="params">root, factory</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span>)</div><div class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"vue"</span>));</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd)</div><div class="line">        define(<span class="string">"iview"</span>, [<span class="string">"vue"</span>], factory);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span>)</div><div class="line">        exports[<span class="string">"iview"</span>] = factory(<span class="built_in">require</span>(<span class="string">"vue"</span>));</div><div class="line">    <span class="keyword">else</span></div><div class="line">        root[<span class="string">"iview"</span>] = factory(root[<span class="string">"vue"</span>]);</div><div class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">__WEBPACK_EXTERNAL_MODULE_157__</span>) </span>&#123;</div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>我们可以看见，打包后的代码以 4 种形式声明了 Vue 依赖：</p>
<ol>
<li><code>module.exports = factory(require(&quot;vue&quot;))</code> - commonjs2 形式；</li>
<li><code>define(&quot;iview&quot;, [&quot;vue&quot;], factory)</code> - AMD 形式；</li>
<li><code>exports[&quot;iview&quot;] = factory(require(&quot;vue&quot;))</code> - commonjs 形式；</li>
<li><code>root[&quot;iview&quot;] = factory(root[&quot;vue&quot;])</code> - 全局变量形式。</li>
</ol>
<p>以 <code>&lt;script&gt;</code> 标签形式使用组件时，会同样使用 <code>&lt;script&gt;</code> 标签导入 Vue。Vue 导入的变量是 “window.Vue” 而不是 “window.vue”，因此会出现 vue 未定义的错误。</p>
<p>幸好，webpack 可以为各种导入形式设置不同名称，设置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">externals: &#123;</div><div class="line">    vue: &#123;</div><div class="line">        root: <span class="string">'Vue'</span>,</div><div class="line">        commonjs: <span class="string">'vue'</span>,</div><div class="line">        commonjs2: <span class="string">'vue'</span>,</div><div class="line">        amd: <span class="string">'vue'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次打包，你可以发现打包的组件库不管是 <code>&lt;script&gt;</code> 标签方式还是后端构建，都可以正常工作了。</p>
<p>最后，帖一个打包 iView 组件库的 webpack 配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        main: <span class="string">'./src/index.js'</span></div><div class="line">    &#125;,</div><div class="line">    output: &#123;</div><div class="line">        path: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">        publicPath: <span class="string">'/dist/'</span>,</div><div class="line">        filename: <span class="string">'iview.js'</span>,</div><div class="line">        library: <span class="string">'iview'</span>,</div><div class="line">        libraryTarget: <span class="string">'umd'</span>,</div><div class="line">        umdNamedDefine: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    externals: &#123;</div><div class="line">        vue: &#123;</div><div class="line">            root: <span class="string">'Vue'</span>,</div><div class="line">            commonjs: <span class="string">'vue'</span>,</div><div class="line">            commonjs2: <span class="string">'vue'</span>,</div><div class="line">            amd: <span class="string">'vue'</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    resolve: &#123;</div><div class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>]</div><div class="line">    &#125;,</div><div class="line">    <span class="built_in">module</span>: &#123;</div><div class="line">        loaders: [&#123;</div><div class="line">            test: <span class="regexp">/\.vue$/</span>,</div><div class="line">            loader: <span class="string">'vue'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.js$/</span>,</div><div class="line">            loader: <span class="string">'babel'</span>,</div><div class="line">            exclude: <span class="regexp">/node_modules/</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.css$/</span>,</div><div class="line">            loader: <span class="string">'style!css!autoprefixer'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.less$/</span>,</div><div class="line">            loader: <span class="string">'style!css!less'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.(gif|jpg|png|woff|svg|eot|ttf)\??.*$/</span>,</div><div class="line">            loader: <span class="string">'url?limit=8192'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.(html|tpl)$/</span>,</div><div class="line">            loader: <span class="string">'vue-html'</span></div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">            <span class="string">'process.env'</span>: &#123;</div><div class="line">                NODE_ENV: <span class="string">'"development"'</span></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便其他开发者使用组件库，开发的 Vue 组件库在发布之前需要对其打包。本文基于 Webpack 讨论打包 Vue 组件库的正确方法。&lt;/p&gt;
&lt;h2 id=&quot;选择正确的打包格式&quot;&gt;&lt;a href=&quot;#选择正确的打包格式&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>开发组件库时 Vue 应该放哪儿：devDependencies or peerDependencies？</title>
    <link href="https://jingsam.github.io/2016/11/01/peerDependencies-in-Vue-components.html"/>
    <id>https://jingsam.github.io/2016/11/01/peerDependencies-in-Vue-components.html</id>
    <published>2016-11-01T11:16:58.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<p>最近在和 Aresn 开发 iView 组件库的时候，关于依赖包 Vue 到底是放在 devDependencies 还是 peerDependencies 有些争论。本着打破砂锅问到底的精神，这篇文章讨论下 package.json 里面的各种 depedencies 字段到底是干嘛的。</p>
<p>npm 的 package.json 包括 5 种 dependencies：</p>
<ol>
<li><code>dependencies</code>：应用能够正常运行所依赖的包。这种 dependencies 是最常见的，用户在使用 <code>npm install</code> 安装你的包时会自动安装这些依赖。</li>
<li><code>devDependencies</code>：开发应用时所依赖的工具包。通常是一些开发、测试、打包工具，例如 webpack、ESLint、Mocha。应用正常运行并不依赖于这些包，用户在使用 <code>npm install</code> 安装你的包时也不会安装这些依赖。</li>
<li><code>peerDependencies</code>：应用运行依赖的宿主包。最典型的就是插件，例如各种 jQuery 插件，这些插件本身不包含 jQeury，需要外部提供。用户使用 npm 1 或 2 时会自动安装这种依赖，npm 3 不会自动安装，会提示用户安装。</li>
<li><code>bundledDependencies</code>：发布包时需要打包的依赖，似乎很少见。</li>
<li><code>optionalDependencies</code>：可选的依赖包。此种依赖不是程序运行所必须的，但是安装后可能会有新功能，例如一个图片解码库，安装了 <code>optionalDependencies</code> 后会支持更多的格式。</li>
</ol>
<p>从以上的定义可以看出，<code>dependencies</code> 是程序运行依赖，<code>devDependencies</code> 一般是一些开发工具，<code>peerDependencies</code> 一般用于插件。</p>
<p>下表是我在 awesome-vue 中找到的 28 个 Vue 组件库，统计了 Vue 在这些库中的位置。其中，11 个库选择放到 <code>dependencies</code>，10 个库选择放到 <code>devDependencies</code>，4 个库选择放到 <code>peerDependencies</code>，2 个库选择不放 Vue 依赖，最后还有 1 个库选择在 <code>devDependencies</code> 和 <code>peerDependencies</code> 同时加上 Vue 依赖。</p>
<table>
<thead>
<tr>
<th>UI</th>
<th>dependencies</th>
<th>devDependencies</th>
<th>peerDependencies</th>
<th>none</th>
</tr>
</thead>
<tbody>
<tr>
<td>vue-strap</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>gritcode-components</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Keen-UI</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>material-ui-vue</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-admin</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-carbon</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-impression</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vuikit</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-material</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-kit</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-material-design</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vuestrap-base-components</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vux</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-materialize</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mint-ui</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>N3-components</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-desktop</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-beauty</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>radon-ui</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-antd</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bootstrap-vue</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>iview</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>wovue</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>vue-bulma</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>quasar</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>vueboot</td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>material-components</td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>element</td>
<td></td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>
<p>下面分析下各种选择的优劣：</p>
<ul>
<li><code>dependencies</code>：放到 <code>dependencies</code> 的好处是安装组件库的时候 Vue 会自动安装。问题是已有的工程项目中往往已经安装了 Vue，会导致在 npm 1 或 2 中重复安装 Vue。虽然此问题在 npm 3 中可以规避，但是如果已安装的 Vue 版本与组件库所依赖的版本不兼容时，Vue 仍然会重复安装。</li>
<li><code>devDependencies</code>：由于组件库单元测试时会用到 Vue，所以严格来说 Vue 是属于开发工具包，放到 <code>devDependencies</code> 合情合理。但是，在 <code>devDependencies</code> 中的 Vue 依赖不会自动安装，所以需要用户去查文档来确定到底应该安装哪个版本的 Vue，对用户似乎不太友好。</li>
<li><code>peerDevDependencies</code>：Vue 组件库本质上是 Vue 的插件，依赖于外部提供的 Vue。把 Vue 放到这里，npm 能够提示用户需要安装哪个版本的 Vue，这点比 <code>devDependencies</code>  友好。问题在于，从 npm 3 开始，<code>peerDevDependencies</code> 中的依赖不会自动安装，会导致自动集成测试失败。</li>
<li>不添加依赖：这基本上是最差的选择了，用户甚至不能知道组件库到底依赖哪个版本的 Vue，只能靠猜。</li>
<li><code>devDependencies</code>、<code>peerDevDependencies</code> 同时添加：这是我和 Element UI 的开发者讨论后最优的做法。<code>peerDevDependencies</code> 中的 Vue 是组件库运行所依赖的 Vue 的最低版本，而 <code>devDependencies</code> 运行测试时需要的 Vue 版本，一般情况下 <code>devDependencies &gt;= peerDevDependencies</code>。这种做法保证了 npm 1、2、3 都不会出问题，并且当用户安装组件库时给予友好的提示信息。</li>
</ul>
<p>到这里，我们可以得出以下结论：<strong>在开发 Vue 组件库是，应当同时在 <code>devDependencies</code> 和 <code>peerDevDependencies</code> 添加 Vue 依赖。</strong></p>
<p>最后，可能有人会说：哥们，何必较真呢，能用不就行了吗？我的观点是，如果大家都按照规范来，会减少很多不必要的麻烦。想想看，如果大家在 npm 上发布包的时候不遵守 semver 规范，你还有信心说，你的程序只要 npm install 就能正常运行么？</p>
<p>按老罗的话说，我不是为了输赢，我就是认真！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在和 Aresn 开发 iView 组件库的时候，关于依赖包 Vue 到底是放在 devDependencies 还是 peerDependencies 有些争论。本着打破砂锅问到底的精神，这篇文章讨论下 package.json 里面的各种 depedencies 字
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>聊聊 Vue 组件命名那些事</title>
    <link href="https://jingsam.github.io/2016/10/30/vue-components-naming.html"/>
    <id>https://jingsam.github.io/2016/10/30/vue-components-naming.html</id>
    <published>2016-10-30T07:56:01.000Z</published>
    <updated>2017-10-19T23:34:16.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>There are only two things in Computer Sciences: cache invalidation and naming things.<br>—— Phil Karlton</p>
</blockquote>
<p>诚如上述所言，编程中变量命名确实令人很头疼。我们模糊地知道，Vue 组件的名称最好不要和原生 HTML 标签相同。为了避免重名，通常会在组件名称前面加上一个前缀，如 <code>el-button</code>、<code>el-input</code>、<code>el-date-picker</code>。这通常不会有什么问题，但有时候你的模板中混杂了原生 HTML 标签和组件标签，要想区分它们并不是很容易。</p>
<p>当我看到 Ant.design 的 React 组件是下面这样的时候，我感觉到一种自由的味道。首先，组件名可以使用原生 HTML 标签名，意味着再也不用较劲脑汁去规避原生 HTML 标签了。另外，这些组件都使用了首字母大写标签名，使它们很容易地与原生小写的 HTML 标签区分。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;Button type=<span class="string">"primary"</span>&gt;Primary&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">    &lt;Input placeholder="Basic usage" /</span>&gt;</div><div class="line">    &lt;Select defaultValue=<span class="string">".com"</span> style=&#123;&#123; <span class="attr">width</span>: <span class="number">70</span> &#125;&#125;&gt;</div><div class="line">      &lt;Option value=<span class="string">".com"</span>&gt;.com&lt;<span class="regexp">/Option&gt;</span></div><div class="line"><span class="regexp">      &lt;Option value=".jp"&gt;.jp&lt;/</span>Option&gt;</div><div class="line">      &lt;Option value=<span class="string">".cn"</span>&gt;.cn&lt;<span class="regexp">/Option&gt;</span></div><div class="line"><span class="regexp">      &lt;Option value=".org"&gt;.org&lt;/</span>Option&gt;</div><div class="line">    &lt;<span class="regexp">/Select&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>div&gt;,</div><div class="line">  mountNode</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>受 Ant.design 的启发，我思考 Vue 组件命名能不能达到同样的效果呢？要找到答案，必须摸清楚 Vue 组件命名到底有什么限制。下面将分别从 Vue 1.0 和 Vue 2.0 来谈谈组件命名的机制：</p>
<h2 id="Vue-1-0-组件命名机制"><a href="#Vue-1-0-组件命名机制" class="headerlink" title="Vue 1.0 组件命名机制"></a>Vue 1.0 组件命名机制</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><p>我们以一个最简单的例子来研究 Vue 组件的注册过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>通过跟踪代码的执行过程，发现对组件的名称有两处检查。</p>
<ol>
<li><p>检查名称是否与 HTML 元素或者 Vue 保留标签重名，不区分大小写。可以发现，只检查了常用的 HTML 元素，还有很多元素没有检查，例如 <code>button</code>、<code>main</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; (commonTagRE.test(id) || reservedTagRE.test(id))) &#123;</div><div class="line">  warn(<span class="string">'Do not use built-in or reserved HTML elements as component '</span> + <span class="string">'id: '</span> + id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;</span></div><div class="line"><span class="comment">// var reservedTagRE = /^(slot|partial|component)$/i;</span></div></pre></td></tr></table></figure>
</li>
<li><p>检查组件名称是否以字母开头，后面跟字母、数值或下划线。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="regexp">/^[a-zA-Z][\w-]*$/</span>.test(name)) &#123;</div><div class="line">  warn(<span class="string">'Invalid component name: "'</span> + name + <span class="string">'". Component names '</span> + <span class="string">'can only contain alphanumeric characaters and the hyphen.'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>基于以上两点，可以总结出组件的命名规则为：组件名以字母开头，后面跟字母、数值或下划线，并且不与 HTML 元素或 Vue 保留标签重名。</p>
<p>然而我们注意到，在上面的检查中，不符合规则的组件名称是 warn 而不是 error，意味着检查并不是强制的。实际上，<strong>Vue 组件注册的名称是没有限制的</strong>。你可以用任何 JavaScript 能够表示的字符串，不管是数字、特殊符号、甚至汉字，都可以成功注册。</p>
<h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><p>虽然 Vue 组件没有命名限制，但是我们终究是要在模板中引用的，不合理的组件名可能会导致我们无法引用它。</p>
<p>为了弄清楚 Vue 是如何将模板中的标签对应到自定义组件的，我们以一段简单的代码说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;my-component&gt;&lt;/my-component&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>总体来说，模板解析分为两个过程：</p>
<p>首先，Vue 会将 <code>template</code> 中的内容插到 DOM 中，以方便解析标签。由于 HTML 标签不区分大小写，所以在生成的标签名都会转换为小写。例如，当你的 <code>template</code> 为 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 时，插入 DOM 后会被转换为 <code>&lt;mycomponent&gt;&lt;/mycomponent&gt;</code>。</p>
<p>然后，通过标签名寻找对应的自定义组件。<strong>匹配的优先顺序从高到低为：原标签名、camelCase化的标签名、PascalCase化的标签名。</strong>例如 <code>&lt;my-component&gt;</code> 会依次匹配 my-component、myComponent、MyComponent。camelCase 和 PascalCase 的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> camelizeRE = <span class="regexp">/-(\w)/g</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> str.replace(camelizeRE, toUpper);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUpper</span>(<span class="params">_, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pascalize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> camelCase = camelize(str);</div><div class="line">  <span class="keyword">return</span> camelCase.charAt(<span class="number">0</span>).toUpperCase() + camelCase.slice(<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于一个 Vue 新手，经常对以下示例代码不能正常运行感到非常疑惑：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;MyComponent&gt;&lt;/MyComponent&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>如果我们按照模板解析的过程推理，就很好解释了。模板 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 插入到 DOM 后会变成 <code>&lt;mycomponent&gt;&lt;/mycomponent&gt;</code>。标签 mycomponent 匹配的组件依次为 mycomponent（原标签名）、mycomponent（camelCase形式）、Mycomponent（PascalCase形式），并没有匹配到注册的组件名 MyComponent，所以会报找不到组件 <mycomponent> 的警告。</mycomponent></p>
<h3 id="命名限制"><a href="#命名限制" class="headerlink" title="命名限制"></a>命名限制</h3><p>通过分析组件注册和模板解析的过程，发现 Vue 组件命名限制并没有我们想象得多。大家可以尝试一下各种命名，我试过 <code>&lt;a_=-*%按钮&gt;&lt;/a_=-*%按钮&gt;</code> 都可正常运行。</p>
<p>但是，并不意味着完全没有限制。由于在模板需要插入到 DOM 中，所以模板中的标签名必须能够被 DOM 正确地解析。主要有三种情况：一是完全不合法的标签名，例如 &lt;/&gt;；二是与 HTML 元素重名会产生不确定的行为，例如使用 input 做组件名不会解析到自定义组件，使用 button 在 Chrome 上正常但在 IE 上不正常；三是与 Vue 保留的 slot、partial、component 重名，因为会优先以本身的意义解析，从而产生非预期的结果。</p>
<p>上述命名限制存在的根本原因，在于模板解析的过程依赖了 DOM。能不能对模板解析过程改进一下，使其不依赖于 DOM 呢？实际上，这正是 Vue 2.0 的主要改进，将模板解析过程使用 Virtual DOM 实现，使得组件命名更加灵活。</p>
<h2 id="Vue-2-0-组件命名机制"><a href="#Vue-2-0-组件命名机制" class="headerlink" title="Vue 2.0 组件命名机制"></a>Vue 2.0 组件命名机制</h2><h3 id="组件注册-1"><a href="#组件注册-1" class="headerlink" title="组件注册"></a>组件注册</h3><p>Vue 2.0 的组件注册过程与 Vue 1.0 基本相同，只是 HTML 标签和 Vue 保留标签范围有些不同：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 区分大小写</span></div><div class="line"><span class="keyword">var</span> isHTMLTag = makeMap(</div><div class="line">  <span class="string">'html,body,base,head,link,meta,style,title,'</span> +</div><div class="line">  <span class="string">'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,'</span> +</div><div class="line">  <span class="string">'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,'</span> +</div><div class="line">  <span class="string">'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,'</span> +</div><div class="line">  <span class="string">'s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,'</span> +</div><div class="line">  <span class="string">'embed,object,param,source,canvas,script,noscript,del,ins,'</span> +</div><div class="line">  <span class="string">'caption,col,colgroup,table,thead,tbody,td,th,tr,'</span> +</div><div class="line">  <span class="string">'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,'</span> +</div><div class="line">  <span class="string">'output,progress,select,textarea,'</span> +</div><div class="line">  <span class="string">'details,dialog,menu,menuitem,summary,'</span> +</div><div class="line">  <span class="string">'content,element,shadow,template'</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// 不区分大小写</span></div><div class="line"><span class="keyword">var</span> isSVG = makeMap(</div><div class="line">  <span class="string">'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,'</span> +</div><div class="line">  <span class="string">'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,'</span> +</div><div class="line">  <span class="string">'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view'</span>,</div><div class="line">  <span class="literal">true</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> isReservedTag = <span class="function"><span class="keyword">function</span> (<span class="params">tag</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> isHTMLTag(tag) || isSVG(tag)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 区分大小写</span></div><div class="line"><span class="keyword">var</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure></p>
<p>虽然 HTML 元素重名警告的标签数大大增加了，但重要的是重名区分大小写，所以我们可以愉快地使用 Input、Select、Option 等而不用担心重名。这个功劳属于 Vue 2.0 引入的 Virtual DOM。</p>
<h3 id="模板解析-1"><a href="#模板解析-1" class="headerlink" title="模板解析"></a>模板解析</h3><p>前面提到，Vue 2.0 相对于 1.0 的最大改进就是引入了 Virtual DOM，使模板的解析不依赖于 DOM。</p>
<p>使用 Virtual DOM 解析模板时，不必像 DOM 方式那样将模板中的标签名转成小写，而是原汁原味地保留原始标签名。然后，使用原始的标签名进行匹配组件。例如，<code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 不会转为为小写形式，直接以 MyComponent 为基础开始匹配。当然，匹配的规则与 1.0 是一样的，即依次匹配：原标签名、camelCase化的标签名、PascalCase化的标签名。</p>
<p>之前在 1.0 不能正常运行的示例代码，在 2.0 中可以正常运行了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;MyComponent&gt;&lt;/MyComponent&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在 Vue 1.0 和 2.0 中还有一种定义组件模板的方式，即使用 DOM 元素。在这种情况下，解析模板时仍然会将标签转为小写形式。所以下面的代码，在 1.0 和 2.0 均不能正常运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.html</span></div><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &lt;MyComponent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ main.js</span></div><div class="line"><span class="regexp">Vue.component('MyComponent', &#123;</span></div><div class="line"><span class="regexp">  template: '&lt;div&gt;hello, world&lt;/</span>div&gt;<span class="string">'</span></div><div class="line"><span class="string">&#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">new Vue(&#123;</span></div><div class="line">  el: '#app'</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="命名限制-1"><a href="#命名限制-1" class="headerlink" title="命名限制"></a>命名限制</h3><p>Vue 2.0 中组件的命名限制与 1.0 的最大区别在于区分了大小写。总结一下就是：一是不使用非法的标签字符；二是不与 HTML 元素（区分大小写）或 SVG 元素（不区分大小写）重名；三是不使用 Vue 保留的 slot 和 component（区分大小写）。</p>
<p>除了以上三条，由于 Vue 2.0 内置了 KeepAlive、Transition、TransitionGroup 三个组件，所以尽量避免与这三个组件重名。但从另一方面讲，你也可以故意重名来实现一些特殊的功能。例如，keep-alive 的匹配顺序为 keep-alive、keepAlive、KeepAlive，所以我们可以注册一个 keep-alive 组件来拦截 KeepAlive 匹配。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我们可以知道 Vue 2.0 完全可以像 React 那样使用 PascalCase 形式的组件标签。对于 Vue 1.0，想以 PascalCase 形态写模板，尽量以全小写或者仅首字母大写形式注册组件，例如 <code>&lt;InputNumber&gt;</code> 组件，可以注册为 inputnumber 或者 Inputnumber。但是，如果你想在 1.0 中使用 Input、Select 这类与 HTML 元素重名的标签名，基本上是无解的，所以是时候尝试下 Vue 2.0 了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;There are only two things in Computer Sciences: cache invalidation and naming things.&lt;br&gt;—— Phil Karlton&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue.js 2.0 独立构建和运行时构建的区别</title>
    <link href="https://jingsam.github.io/2016/10/23/standalone-vs-runtime-only-build-in-vuejs2.html"/>
    <id>https://jingsam.github.io/2016/10/23/standalone-vs-runtime-only-build-in-vuejs2.html</id>
    <published>2016-10-23T04:54:52.000Z</published>
    <updated>2017-10-19T23:34:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 Vue.js 2.0 时，有独立构建（standalone）和运行时构建（runtime-only）两种版本可供选择。而在 Vue.js 1.0 中，却没有这种版本区别。到底该使用哪一个版本？这让我有点懵逼的感觉。本着知其然还要知其所以然的精神，我决定好好研究下两者间的区别。</p>
<p>Vue.js 的官方教程上是这么说的：</p>
<blockquote>
<ul>
<li>独立构建包括编译和支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。</li>
<li>运行时构建不包括模板编译，不支持 template 选项。运行时构建，可以用 render 选项，但它只在单文件组件中起作用，因为单文件组件的模板是在构建时预编译到 render 函数中，运行时构建只有独立构建大小的 30%，只有 16Kb min+gzip 大小。</li>
</ul>
</blockquote>
<p>看了半天，实在没搞清两者之间的区别。经过一番搜索，终于搞清楚了问题的本源，且听我娓娓道来。</p>
<p>Vue.js 的运行过程实际上包含两步。第一步，编译器将字符串模板（template）编译为渲染函数（render），称之为编译过程；第二步，运行时实际调用编译的渲染函数，称之为运行过程。</p>
<p>由于 Vue.js 1.0 的编译过程需要依赖浏览器的 DOM，所以无法（或者说没有意义）将编译器和运行时分开。因此在 Vue.js 1.0 分发包中，编译器和运行时是打包在一起，都在浏览器端执行。</p>
<p>然而到了 Vue.js 2.0，为了支持服务端渲染（server-side rendering），编译器不能依赖于 DOM，所以必须将编译器和运行时分开。这就形成了独立构建（编译器 + 运行时）和运行时构建（仅运行时）。显而易见，运行时构建要小于独立构建。</p>
<p>在现代前端工程构建中，通常会使用 vue-loader 和 vueify 预编译模板。在这种情况下，只需要打包运行时，而不需要打包编译器，运行时构建即可满足所需。当然，如果你需要在前端使用 <code>template</code> 选项实时编译模板，那么还是需要使用独立构建将编译器发送到浏览器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Vue.js 2.0 时，有独立构建（standalone）和运行时构建（runtime-only）两种版本可供选择。而在 Vue.js 1.0 中，却没有这种版本区别。到底该使用哪一个版本？这让我有点懵逼的感觉。本着知其然还要知其所以然的精神，我决定好好研究下两者
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Mapbox 地图样式规范》中文版上线啦</title>
    <link href="https://jingsam.github.io/2016/10/19/mapbox-gl-style-spec.html"/>
    <id>https://jingsam.github.io/2016/10/19/mapbox-gl-style-spec.html</id>
    <published>2016-10-19T04:29:01.000Z</published>
    <updated>2017-10-19T23:34:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>最近逮空翻译了下《Mapbox 地图样式规范》，对于英文不好或者懒得看英文的朋友们可能会有用。</p>
<p>页面托管到了 <a href="https://jingsam.github.io/mapbox-gl-style-spec">Github</a> 上，现在也正在和 Mapbox 沟通，看能不能发布到 <a href="http://www.mapbox.cn/" target="_blank" rel="external">mapbox.cn</a> 上，服务下广大中国 Mapboxer。</p>
<p>当然，如果有什么翻译不到位或者错误的地方，欢迎给我发 <a href="https://github.com/jingsam/mapbox-gl-style-spec/issues" target="_blank" rel="external">issue</a>。</p>
<p><img src="/assets/mapbox-gl-style-spec.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近逮空翻译了下《Mapbox 地图样式规范》，对于英文不好或者懒得看英文的朋友们可能会有用。&lt;/p&gt;
&lt;p&gt;页面托管到了 &lt;a href=&quot;https://jingsam.github.io/mapbox-gl-style-spec&quot;&gt;Github&lt;/a&gt; 上，现在也正在
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多边形centroid的计算方法</title>
    <link href="https://jingsam.github.io/2016/10/05/centroid.html"/>
    <id>https://jingsam.github.io/2016/10/05/centroid.html</id>
    <published>2016-10-05T04:53:50.000Z</published>
    <updated>2017-10-19T23:34:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2016/09/26/polylabel2.html">上一篇</a>计算多边形的最佳注记点的算法中，需要计算多边形的centroid。本文就来讲一讲多边形centroid的计算方法。</p>
<h2 id="Centroid的定义"><a href="#Centroid的定义" class="headerlink" title="Centroid的定义"></a>Centroid的定义</h2><p><a href="https://en.wikipedia.org/wiki/Centroid" target="_blank" rel="external">Centroid</a>是多边形的质量中心（Center of mass）。假设多边形是一块厚度均匀的薄板，当我们用一根绳子从一个平衡点吊起薄板时，薄板能够保持水平稳定，那么这个平衡点就是centroid。</p>
<p><img src="/assets/tilt-slab-construction.jpg" alt="tilt-slab-construction"></p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>我们先从1维直线说起，如下图，在原点的一端不同位置上分别挂着重10kg、5kg、7kg的砝码。如果我们将三个砝码当成一个整体，挂在同一个位置，使其产生的杠杆效应与之前相同，那么这个位置点就相当于质心。</p>
<p><img src="/assets/Image1203.gif" alt="Center of mass"></p>
<p>计算方法如下：</p>
<p>总惯性 = 10 × 2 + 5 × 4 + 7 × 5 = 75 kg.m<br>总质量 = 10 + 5 + 7 = 22 kg<br>假设质心距离原点为d，那么 22 x d = 75，得出 d = 75 / 22 ≈ 3.4 m</p>
<p><img src="/assets/Image1207.gif" alt="Center of mass 2"></p>
<p>上述计算1维直线上的质心很简单，那么现在扩展到2维平面。如下图，矩形的质心很容易求得为 (2，1)。</p>
<p><img src="/assets/Image1208.gif" alt="Center of mass 3"></p>
<p>如果更复杂的形状呢？</p>
<p><img src="/assets/Image1211.gif" alt="Center of mass 4"></p>
<p>计算方法是将多边形分解为多个容易求质心的规则矩形，过程如下：</p>
<p>首先将多边形分解为左右两个规则矩形，如下图：</p>
<p><img src="/assets/Image1212.gif" alt="Center of mass 5"></p>
<p>左矩形的面积为 3 x 2 = 6，质心为 (-0.5, 1)<br>左矩形的面积为 2 x 4 = 8，质心为 (2, 2)</p>
<p>我们假设多边形质量是均匀分布的，那么矩形的面积就可以代表它的质量，所以在x轴上：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span> x <span class="number">-0.5</span> + <span class="number">8</span> x <span class="number">2</span> = (<span class="number">6</span> + <span class="number">8</span>) x dx</div><div class="line"><span class="number">-3</span> + <span class="number">16</span> = <span class="number">14</span> x dx</div><div class="line"><span class="number">13</span> = <span class="number">14</span> x dx</div><div class="line">dx = <span class="number">13</span> / <span class="number">14</span></div></pre></td></tr></table></figure></p>
<p>同理，在y轴上：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span> x <span class="number">1</span> + <span class="number">8</span> x <span class="number">2</span> = (<span class="number">6</span> + <span class="number">8</span>) x dy</div><div class="line"><span class="number">6</span> + <span class="number">16</span> = <span class="number">14</span> x dy</div><div class="line"><span class="number">22</span> = <span class="number">14</span> x dy</div><div class="line">dy = <span class="number">11</span> / <span class="number">7</span></div></pre></td></tr></table></figure></p>
<p>最终求得多边形的质心为(13/14, 11/7)</p>
<p>由以上过程，我们可以得出一个更为普遍的结论：</p>
<p>质心 = 惯性 / 质量</p>
<p>用公式表达即为：<br><img src="/assets/eq1.png" alt="eq1"></p>
<p>对于任意不规则多边形，如何利用上述公式计算质心呢？其原理是将多边形剖分为三角形，然后分别计算每个三角形的面积和质心。</p>
<p><img src="/assets/PolygonArea1.png" alt="Polygon area"></p>
<p>对于三角形的面积，我们可以采用向量积公式计算:<br>$<br>signedArea(ABC)=\frac{1}{2}(x_1y_2 - x_2y_1)<br>$<br><img src="/assets/figure7.jpg" alt="Area of triangle"></p>
<p>对于三角形的质心，采用如下公式计算：<br>$<br>centroid(ABC)=(\frac{A_x + B_x + C_x}{3}, \frac{A_y + B_y + C_y}{3})<br>$<br><img src="/assets/figure8.jpg" alt="Centroid of triangle"></p>
<p>剩下的任务是选择一个剖分点P，将多边形剖分为多个三角形。由于我们在用向量积计算三角形面积时，其结果是有正负的。选择哪一个剖分点，并不影响最终加和后的总面积，<strong>前提是多边形的坐标点按逆时针排列</strong>。所以，为了简便期间，选取坐标原点作为剖分点。<br><img src="/assets/PolygonArea3.png" alt="Polygon area"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// polygon按顺时针排列顶点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCentroid</span>(<span class="params">polygon</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> totalArea = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> totalX = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> totalY = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> points = polygon[<span class="number">0</span>]</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length; ++i) &#123;</div><div class="line">    <span class="comment">// a、b以及原点构成一个三角形</span></div><div class="line">    <span class="keyword">var</span> a = points[i + <span class="number">1</span>]</div><div class="line">    <span class="keyword">var</span> b = points[i]</div><div class="line"></div><div class="line">    <span class="keyword">var</span> area = <span class="number">0.5</span> * (a[<span class="number">0</span>] * b[<span class="number">1</span>] - b[<span class="number">0</span>] * a[<span class="number">1</span>])  <span class="comment">// 计算面积</span></div><div class="line">    <span class="keyword">var</span> x = (a[<span class="number">0</span>] + b[<span class="number">0</span>]) / <span class="number">3</span>  <span class="comment">// 计算x方向质心</span></div><div class="line">    <span class="keyword">var</span> y = (a[<span class="number">1</span>] + b[<span class="number">1</span>]) / <span class="number">3</span>  <span class="comment">// 计算y方向质心</span></div><div class="line"></div><div class="line">    totalArea += area</div><div class="line">    totalX += area * x</div><div class="line">    totalY += area * y</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> [totalX / totalArea, totalY/ totalArea]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2016/09/26/polylabel2.html&quot;&gt;上一篇&lt;/a&gt;计算多边形的最佳注记点的算法中，需要计算多边形的centroid。本文就来讲一讲多边形centroid的计算方法。&lt;/p&gt;
&lt;h2 id=&quot;Centroid的定义&quot;&gt;&lt;a href=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>求点到多边形的距离的算法实现</title>
    <link href="https://jingsam.github.io/2016/09/26/polydist.html"/>
    <id>https://jingsam.github.io/2016/09/26/polydist.html</id>
    <published>2016-09-26T04:09:10.000Z</published>
    <updated>2017-10-19T23:34:16.170Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的<a href="/2016/09/26/polylabel2.html">博文</a>中，多边形注记点搜寻算法需要计算点到多边形的距离，本文就来讲一讲如何用JS实现点到多边形距离的计算。</p>
<h2 id="如何定义点到多边形的距离？"><a href="#如何定义点到多边形的距离？" class="headerlink" title="如何定义点到多边形的距离？"></a>如何定义点到多边形的距离？</h2><p>在本文中，点到多边形的距离定义如下：</p>
<ol>
<li>点到多边形边界的最短距离。</li>
<li>点在多边形内部，距离为正；在多边形外部，距离为负；在边上，距离为零。</li>
</ol>
<p>根据上面的定义，计算点到多边形的距离需要解决两个问题：</p>
<ol>
<li>点到多边形的最短距离如何计算？</li>
<li>如何判断点在多边形内部、外部、还是在边界上？</li>
</ol>
<h2 id="点到多边形最短距离的计算"><a href="#点到多边形最短距离的计算" class="headerlink" title="点到多边形最短距离的计算"></a>点到多边形最短距离的计算</h2><p>计算点到多边形最短距离的基本原理是：依次计算点到多边形每条边的距离，然后筛选出最短距离。</p>
<p><img src="/assets/min-dist.png" alt="min-dist"></p>
<p>如下图，假设<code>AB</code>为多边形的一条边，现在求点<code>P</code>到<code>AB</code>的距离。</p>
<p><img src="/assets/segment-dist.png" alt="segment-dist"></p>
<p>根据<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E9%87%8F%E7%A7%AF" target="_blank" rel="external">向量内集</a>的公式（$\vec{a} \cdot \vec{b} = |a||b|cosθ$）,我们可以推出：<br>$<br>\vec{AB} \cdot \vec{AP} = |AB||AP|cosθ = |AB||AD|<br>\ 设 |AD| = t|AB|<br>\ 则 t = \frac{\vec{AB} \cdot \vec{AP}}{|AB|^2}<br>$</p>
<p>根据以上公式，我们可以求出<code>t</code>，进而求出点<code>D</code>的坐标，最终<code>PD</code>的长度就很容易求得了。</p>
<p>但是还有一些边界条件需要注意，即最终<code>D</code>点不是落在<code>AB</code>上，有以下上中情况：</p>
<ol>
<li><code>t &lt; 0</code>，<code>D</code>在<code>BA</code>延长线上，此时最短距离取<code>PA</code>；</li>
<li><code>0 &lt;= t &lt;= 1</code>，<code>D</code>在<code>AB</code>上，此时最短距离取<code>PD</code>；</li>
<li><code>t &gt; 1</code>，<code>D</code>在<code>AB</code>延长线上，此时最短距离取<code>PB</code>；</li>
</ol>
<p><img src="/assets/t.png" alt="t"></p>
<p>JS实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointToSegmentDist</span>(<span class="params">p, a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> AB = [b[<span class="number">0</span>] - a[<span class="number">0</span>], b[<span class="number">1</span>] - a[<span class="number">1</span>]]</div><div class="line">  <span class="keyword">var</span> AP = [p[<span class="number">0</span>] - a[<span class="number">0</span>], p[<span class="number">1</span>] - a[<span class="number">1</span>]]</div><div class="line"></div><div class="line">  <span class="keyword">var</span> AB_AP = AB[<span class="number">0</span>] * AP[<span class="number">0</span>] + AB[<span class="number">1</span>] * AP[<span class="number">1</span>]</div><div class="line">  <span class="keyword">var</span> distAB2 = AB[<span class="number">0</span>] * AB[<span class="number">0</span>] + AB[<span class="number">1</span>] * AB[<span class="number">1</span>]</div><div class="line"></div><div class="line">  <span class="keyword">var</span> D = [a[<span class="number">0</span>], a[<span class="number">1</span>]]</div><div class="line">  <span class="keyword">if</span> (distAB2 != <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">var</span> t = AB_AP / distAB2</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (t &gt; <span class="number">1</span>) &#123;</div><div class="line">      D = [b[<span class="number">0</span>], b[<span class="number">1</span>]]</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</div><div class="line">      D = [a[<span class="number">0</span>] + AB[<span class="number">0</span>] * t, a[<span class="number">1</span>] + AB[<span class="number">1</span>] * t]</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      D = [a[<span class="number">0</span>], a[<span class="number">1</span>]]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> AD = [p[<span class="number">0</span>] - a[<span class="number">0</span>], p[<span class="number">1</span>] - a[<span class="number">1</span>]]</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(AD[<span class="number">0</span>] * AD[<span class="number">0</span>] + AD[<span class="number">1</span>] * AD[<span class="number">1</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="判断点与多边形的位置关系"><a href="#判断点与多边形的位置关系" class="headerlink" title="判断点与多边形的位置关系"></a>判断点与多边形的位置关系</h2><p>判断点与多边形的位置关系，常用的算法是射线法，即经过点沿水平方向做一条直线，观察点左边或右边交点的个数。如果交点个数为奇数，点在多变形内部；交点个数为偶数，点在多边形外部。</p>
<p><img src="/assets/ray.gif" alt="ray"></p>
<p>如下图，<code>ab</code>与过<code>p</code>点的水平线相交于c，则有：<br>$<br>\frac{x_2 - x_1}{y_2 - y_1} = \frac{x’ - x_1}{y - y_1}<br>\ 那么 x’ = \frac{(x_2 - x_1)(y - y_1)}{y_2 - y_1} + x_1<br>$</p>
<p><img src="/assets/ray2.png" alt="ray2"></p>
<p>JS 算法实现为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointInPolygon</span>(<span class="params">p, polygon</span>) </span>&#123;</div><div class="line">  <span class="comment">// 统计p点右边交点的个数</span></div><div class="line">  <span class="keyword">var</span> count = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; polygon.length; k++) &#123;</div><div class="line">    <span class="keyword">var</span> ring = polygon[k]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ring.length - <span class="number">1</span>; i++) &#123;</div><div class="line">      <span class="keyword">var</span> a = ring[i]</div><div class="line">      <span class="keyword">var</span> b = ring[j]</div><div class="line"></div><div class="line">      <span class="keyword">if</span> ((a[<span class="number">1</span>] &gt; y !== b[<span class="number">1</span>] &gt; y) &amp;&amp;</div><div class="line">        (x &lt; (b[<span class="number">0</span>] - a[<span class="number">0</span>]) * (y - a[<span class="number">1</span>]) / (b[<span class="number">1</span>] - a[<span class="number">1</span>]) + a[<span class="number">0</span>])) count++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> count % <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>解决了以上两个难题之后，下面给出完整实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointToPolygonDist</span>(<span class="params">p, polygon</span>) </span>&#123;</div><div class="line">  <span class="comment">// 统计p点右边交点的个数</span></div><div class="line">  <span class="keyword">var</span> count = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> minDist = <span class="literal">Infinity</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; polygon.length; k++) &#123;</div><div class="line">    <span class="keyword">var</span> ring = polygon[k]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ring.length - <span class="number">1</span>; i++) &#123;</div><div class="line">      <span class="keyword">var</span> a = ring[i]</div><div class="line">      <span class="keyword">var</span> b = ring[j]</div><div class="line"></div><div class="line">      <span class="keyword">if</span> ((a[<span class="number">1</span>] &gt; y !== b[<span class="number">1</span>] &gt; y) &amp;&amp;</div><div class="line">        (x &lt; (b[<span class="number">0</span>] - a[<span class="number">0</span>]) * (y - a[<span class="number">1</span>]) / (b[<span class="number">1</span>] - a[<span class="number">1</span>]) + a[<span class="number">0</span>])) count++;</div><div class="line"></div><div class="line">      minDist = <span class="built_in">Math</span>.min(minDist, pointToSegmentDist(p, a, b))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (count % <span class="number">2</span> === <span class="number">0</span>) minDist = -minDist</div><div class="line"></div><div class="line">  <span class="keyword">return</span> minDist</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的&lt;a href=&quot;/2016/09/26/polylabel2.html&quot;&gt;博文&lt;/a&gt;中，多边形注记点搜寻算法需要计算点到多边形的距离，本文就来讲一讲如何用JS实现点到多边形距离的计算。&lt;/p&gt;
&lt;h2 id=&quot;如何定义点到多边形的距离？&quot;&gt;&lt;a href=&quot;#如
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多边形注记点搜索算法实现</title>
    <link href="https://jingsam.github.io/2016/09/26/polylabel2.html"/>
    <id>https://jingsam.github.io/2016/09/26/polylabel2.html</id>
    <published>2016-09-26T03:52:27.000Z</published>
    <updated>2017-10-19T23:34:16.171Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2016/09/24/polylabel.html">上一篇</a>博文中，我讲了多边形注记点搜索算法的基本原理，本篇文章讲一讲如何用JS实现。</p>
<p>建议读者阅读本篇博文之前，一定要先了解<a href="/2016/09/24/polylabel.html">上一篇</a>博文中提到的算法原理。</p>
<h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>我们定义一个函数接口，接受一个多边形，计算其标注点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">polylabel</span>(<span class="params">polygon</span>) </span>&#123;</div><div class="line">  <span class="comment">// TODO</span></div><div class="line">  <span class="keyword">return</span> [x, y]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.export = polylabel</div></pre></td></tr></table></figure></p>
<p>使用时，我们可以这样调用：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var polylabel = require('polylabel')</div><div class="line"></div><div class="line">var polygon = [[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>]]]</div><div class="line">var point = polylabel(polygon)</div></pre></td></tr></table></figure></p>
<p>对于polygon，我们采用geojson对多边形的坐标定义格式，即多边形由多个环组成，其中第一个环是外环，其他的为内环。所以<code>polygon[0]</code>表示第一个环，<code>ploygon[0][0]</code>表示起点坐标。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始实现polylabel之前，需要一些辅助函数和库。</p>
<p>首先，我们定义网格对象<code>Cell</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cell</span>(<span class="params">x, y, h, polygon</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x  <span class="comment">// 中心点x</span></div><div class="line">  <span class="keyword">this</span>.y = y  <span class="comment">// 中心点y</span></div><div class="line">  <span class="keyword">this</span>.h = h  <span class="comment">// 中心点到网格的距离，相当于格网大小的1/2</span></div><div class="line">  <span class="keyword">this</span>.d = pointToPolygonDist(x, y, polygon)  <span class="comment">// 中心点到多边形的距离</span></div><div class="line">  <span class="keyword">this</span>.max = <span class="keyword">this</span>.d + <span class="keyword">this</span>.h * <span class="built_in">Math</span>.SQRT2     <span class="comment">// 网格内部区域到多边形的最大距离</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义网格对象的主要目的是方便求取最大距离<code>this.max</code>，有了网格对象<code>Cell</code>之后，每当我们实例化一个cell对象，我们就可以知道这个网格区域的最大距离以及它所代表的区域。</p>
<p><code>pointToPolygonDist</code>是计算点到多边形的距离的函数，其基本原理是计算点到多边形每条边的距离，取最短距离即为点到多边形的距离。详细的算法实现我考虑专门用一篇文章来讲。</p>
<p><code>this.d + this.h * Math.SQRT2</code>即为我们之前在算法原理中求得的最大距离<code>dist + radius</code>，由于格网是一个正方形，其外接圆形的半径即为中心点到任意一个顶点的距离，即<code>this.h * Math.SQRT2</code>。</p>
<p><img src="/assets/radius.png" alt="radius"></p>
<p>另一个需要准备的是一个<a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank" rel="external">优先级队列</a>的数据结构，它与一般的队列不同在于，优先级队列中的元素都是经过排序的。每当push一个元素，并不是简单地将该元素放入队列末尾，而是会将该元素与队列中的元素进行比较，放到一个合适的位置上。</p>
<p>我们可以定义一个优先级队列，队列里存储的是格网对象。每push入一个格网，根据最大距离<code>max</code>进行排序，大的在前，小的在后。由此，我们可以分裂格网时，只需从队首pop出一个格网进行操作。</p>
<p>优先级队列的一个JS实现是<a href="https://github.com/mourner/tinyqueue" target="_blank" rel="external">tinyqueue</a>，同样是Vladimir Agafonkin的作品。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Queue = <span class="built_in">require</span>(<span class="string">'tinyqueue'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">polylabel</span>(<span class="params">polygon</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 计算bbox，为切分网格做准备</span></div><div class="line">  <span class="keyword">var</span> minX, minY, maxX, maxY</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; polygon[<span class="number">0</span>].length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> p = polygon[<span class="number">0</span>][i]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">0</span>] &lt; minX) minX = p[<span class="number">0</span>]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">1</span>] &lt; minY) minY = p[<span class="number">1</span>]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">0</span>] &gt; maxX) maxX = p[<span class="number">0</span>]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">1</span>] &gt; maxY) maxY = p[<span class="number">1</span>]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 计算长和宽，初始格网大小和高度</span></div><div class="line">  <span class="keyword">var</span> width = maxX - minX</div><div class="line">  <span class="keyword">var</span> height = maxY - minY</div><div class="line">  <span class="keyword">var</span> cellSize = <span class="built_in">Math</span>.min(width, height)</div><div class="line">  <span class="keyword">var</span> h = cellSize / <span class="number">2</span></div><div class="line"></div><div class="line">  <span class="comment">// 初始化一个存储Cell的优先级队列，按距离从大到小排列</span></div><div class="line">  <span class="keyword">var</span> cellQueue = <span class="keyword">new</span> Queue(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> b.max - a.max</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 将多边形切分</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = minX; x &lt; maxX; x += cellSize) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> y = minY; y &lt; maxY; y += cellSize) &#123;</div><div class="line">      cellQueue.push(<span class="keyword">new</span> Cell(x + h, y + h, h, polygon));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 取对首为最优格网</span></div><div class="line">  <span class="keyword">var</span> bestCell = cellQueue.peek()</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (cellQueue.length) &#123;</div><div class="line">    <span class="keyword">var</span> cell = cellQueue.pop()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cell.d &gt; bestCell.d) bestCell = cell</div><div class="line"></div><div class="line">    <span class="comment">// 最大距离小于最优格网的距离，直接淘汰</span></div><div class="line">    <span class="keyword">if</span> (cell.max &lt;= bestCell.d) <span class="keyword">continue</span></div><div class="line"></div><div class="line">    <span class="comment">// 将格网裂为4个小格网</span></div><div class="line">    h = cell.h / <span class="number">2</span></div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x - h, cell.y - h, h, polygon))</div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x + h, cell.y - h, h, polygon))</div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x - h, cell.y + h, h, polygon))</div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x + h, cell.y + h, h, polygon))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> [bestCell.x, bestCell.y]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p>上一节描述了多边形注记点搜寻算法的基本实现，我们还需要对其进行优化，提升算法效率。</p>
<p>为了提升效率，我们可以增加一个容差参数，允许最后的注记点有一定的误差，以减少运算次数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if (cell.max &lt;= bestCell.d) continue</span></div><div class="line"><span class="keyword">if</span> (cell.max - bestCell.d &lt;= precision) <span class="keyword">continue</span></div></pre></td></tr></table></figure></p>
<p>另外，我们可以在初始时，用centroid作为初始最优点，因为大多数凸多边形的centroid就是最佳注记点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var bestCell = cellQueue.peek()</span></div><div class="line"><span class="keyword">var</span> bestCell = getCentroidCell(polygon)</div></pre></td></tr></table></figure></p>
<p>当然，多变形的centeroid怎么求，估计又得用一篇博文来说了。</p>
<p>感觉给自己挖了好多坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/2016/09/24/polylabel.html&quot;&gt;上一篇&lt;/a&gt;博文中，我讲了多边形注记点搜索算法的基本原理，本篇文章讲一讲如何用JS实现。&lt;/p&gt;
&lt;p&gt;建议读者阅读本篇博文之前，一定要先了解&lt;a href=&quot;/2016/09/24/polyla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多边形注记点搜索的算法原理</title>
    <link href="https://jingsam.github.io/2016/09/24/polylabel.html"/>
    <id>https://jingsam.github.io/2016/09/24/polylabel.html</id>
    <published>2016-09-23T17:34:18.000Z</published>
    <updated>2017-10-19T23:34:16.170Z</updated>
    
    <content type="html"><![CDATA[<p>在制图过程中，对多边形进行标注是一个常见的需求。然而如何快速找到一个合适的注记点，确不是一个很容易的事情。</p>
<p>最近，Leaflet的作者<a href="https://github.com/mourner" target="_blank" rel="external">Vladimir Agafonkin</a>大神发表了一篇<a href="https://www.mapbox.com/blog/polygon-center/" target="_blank" rel="external">博文</a>，描述了他如何用100多行JS代码，实现一个高效的多边形标注点搜寻<a href="https://github.com/mapbox/polylabel" target="_blank" rel="external">算法</a>。</p>
<p>虽然他在博文中描述了算法的原理，但是对于我这种数学不好的人，有些细节方面的东西还不甚了解。因此，此篇文章将以我这种小白角度，事无巨细地解释下他的算法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于一个多边形，哪一个点才适合做标注点呢？自然而然我们就会想到是重心，即<a href="https://en.wikipedia.org/wiki/Centroid" target="_blank" rel="external">centroid</a>。然而对于凹多边形或者环，它们的重心会出现在多边形外部，这明显不是我们想要的。</p>
<p><img src="/assets/centeroid.png" alt="centeroid"></p>
<p>一个合适的标注点，应该是多边形的视觉中心，即以该点为圆心在多边形内部画一个圆，该圆的面积是最大的。假如我们定义一个点到多边形的距离为该点到多边形各边的最短距离，并且规定点在多边形内部时距离为正，点在外部时距离为负。所以多边形标注问题就可以简化为寻找离多边形最远的点，即<a href="https://en.wikipedia.org/wiki/Pole_of_inaccessibility" target="_blank" rel="external">pole of inaccessibility</a>。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>理论上，只要知道多边形的各点坐标，必定能够用数学公式求出这个离多边形最远的点。然而，求解这个标注点的精确坐标必定非常耗时，实际上我们只需要一个近似解就足够了。</p>
<p>如何搜寻这个点呢？其实算法原理很简单，即利用分而治之的思想，先搜寻一小块区域，逐步淘汰差的区域，逐步缩小搜寻范围，最终找到最优点。具体步骤为：</p>
<ol>
<li>对多边形进行格网划分，求出格网内部的点到多边形的最大距离。</li>
<li>按最大距离对格网进行排序，淘汰距离小的格网，保留距离大的格网。</li>
<li>对剩下的格网再进行细分，重复步骤1和步骤2。</li>
</ol>
<p>在以上的步骤中，格网内部的点到多边形的最大距离如何计算是一个问题。如下图，格网中心点到多边形的距离为<code>dist</code>，到顶点的距为<code>radius</code>，那么格网到多边形的最大距离<code>maxd = dist + radius</code>。</p>
<p><img src="/assets/dist.jpg" alt="dist"></p>
<p>如何证明上述计算最大距离的公式呢？我几何学得不好，没办法给出严密的数学证明，但是我可以通过图示予以说明。</p>
<p>如下图，设多边形内部一点<code>O</code>，其距多边形的距离<code>OA</code>长度为<code>dist</code>。以<code>O</code>为圆心，以<code>radius</code>为半径作一个圆。延长AO，交圆于点<code>B</code>，那么<code>AB</code>的长度为<code>dist + radius</code>。在圆内部任意取一点<code>B&#39;</code>，显然<code>AB&#39; &lt;= AB = dist + radius</code>。假设点<code>B‘</code>到多边形的距离为<code>d</code>，那么<code>d &lt;= AB&#39; &lt;= AB = dist + radius</code>。所以对于圆内的任意一点，其到多边形的距离必定小于等于<code>dist + radius</code>。在圆内部取一个正方形区域，仍然符合<code>d &lt;= dist + radius</code>，这就证明格网区域的最大距离为<code>dist + radius</code>。</p>
<p><img src="/assets/proof.png" alt="proof"></p>
<p>如何对格网进行细分呢？我们可以用四叉树，将一个格网分割为4个小格网。</p>
<p><img src="/assets/quadtree.jpg" alt="quadtree"></p>
<p>搜寻标注点的算法原理是不是很简单？我将在下一篇博文中详细描述如何用JS实现该算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在制图过程中，对多边形进行标注是一个常见的需求。然而如何快速找到一个合适的注记点，确不是一个很容易的事情。&lt;/p&gt;
&lt;p&gt;最近，Leaflet的作者&lt;a href=&quot;https://github.com/mourner&quot; target=&quot;_blank&quot; rel=&quot;exter
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mongodb全文搜索实战</title>
    <link href="https://jingsam.github.io/2016/06/04/mongodb-text-search.html"/>
    <id>https://jingsam.github.io/2016/06/04/mongodb-text-search.html</id>
    <published>2016-06-04T13:10:56.000Z</published>
    <updated>2017-10-19T23:34:16.170Z</updated>
    
    <content type="html"><![CDATA[<p>在传统的关系型数据库中，我们通常将数据结构化，通过一系列表关联、聚合来查询我们所需的结果。而在非结构化的数据中，缺少这种预定义的结构，因而如何快速查询定位到我们所需要的结果，不是一件容易的事。</p>
<p>Mongodb作为一种NoSQL数据库，非常适合存储和管理非结构化数据，例如互联网上的各种文本数据。假如我们用Mongodb存储了很多博客文章，那么如何快速找到所有关于“nodejs”这个主题的文章呢？Mongodb内建的全文搜索可以帮助我们完成这个功能。</p>
<p>在本篇博文中，将要介绍的是我使用Mongdb text search的一些经验。</p>
<h3 id="Mongodb-text-search是什么？"><a href="#Mongodb-text-search是什么？" class="headerlink" title="Mongodb text search是什么？"></a>Mongodb text search是什么？</h3><p>Mongodb text search是Mongodb对数据库进行搜索的功能模块，类似于数据库内建的搜索引擎。有些人可能会疑问，查数据库为什么还需要搜索引擎？直接用条件查询不就得了。例如在前面的文章主题搜索中，我们不可能事先提取出每篇文章的主题，然后用专门的字段存储，因此没办法进行条件查询。并且同一个主题词，有多种不同的表达方式，例如”node”、”nodejs”可视为同一个主题。</p>
<p>Mongodb text search可以自动地对大段的文本数据进行分词处理、模糊匹配、同义词匹配，解决文本搜索的问题。</p>
<h3 id="建立文本索引"><a href="#建立文本索引" class="headerlink" title="建立文本索引"></a>建立文本索引</h3><p>要使Mongodb能够进行全文搜索，首先要对搜索的字段建立文本索引。建立文本索引的关键字是<code>text</code>，我们既可以建立单个字段的文本索引，也可以建立包含多个字段的复合文本索引。<strong>需要注意的是，每个collection只能建立一个文本索引，且只能对String或String数组的字段建立文本索引</strong>。</p>
<p>我们可以通过以下命令，建立一个文本索引：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">db</span><span class="selector-class">.collection</span><span class="selector-class">.createIndex</span>(&#123; <span class="attribute">subject</span>: <span class="string">"text"</span>, content: <span class="string">"text"</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>在mongoose中我们可以通过以下代码，创建文本索引：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">schema</span><span class="selector-class">.index</span>(&#123; <span class="attribute">subject</span>: <span class="string">"text"</span>, content: <span class="string">"text"</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>需要注意的是，由于每个collection只支持一个文本索引，所以当你需要在schema中添加或删除文本索引字段时，往往不起作用。这时候你需要到数据库中，手动删除已经建立的文本索引。</p>
<h3 id="文本搜索示例"><a href="#文本搜索示例" class="headerlink" title="文本搜索示例"></a>文本搜索示例</h3><p>文本搜索的语法为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  $text:</div><div class="line">    &#123;</div><div class="line">      $search: &lt;string&gt;,</div><div class="line">      $language: &lt;string&gt;,</div><div class="line">      $caseSensitive: &lt;boolean&gt;,</div><div class="line">      $diacriticSensitive: &lt;boolean&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在mongoose中，我们可以通过以下语句进行文本搜索：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var query = model.<span class="builtin-name">find</span>(&#123; <span class="variable">$text</span>: &#123; <span class="variable">$search</span>: <span class="string">"hello world"</span> &#125; &#125;)</div></pre></td></tr></table></figure></p>
<p><code>$search</code>后面的关键词可以有多个，关键词之间的分隔符可以是多种字符，例如空格、下划线、逗号、加号等，但不能是<code>-</code>和<code>\&quot;</code>，因为这两个符号会有其他用途。搜索的多个关键字是<code>or</code>的关系，除非你的关键字包含<code>-</code>。例如<code>hello world</code>会包含所有匹配<code>hello</code>或<code>world</code>的文本，而<code>hello -world</code>只会匹配包含<code>hello</code>且不包含<code>world</code>的文本。</p>
<p><code>$language</code>指示搜索的语言类型，在最新的Mongodb 3.2 enterprise版本中，已经增加了对中文文本的搜索。</p>
<p><code>$caseSensitive</code>设置是否区分大小写。</p>
<p><code>$diacriticSensitive</code>设置是否区别发音符号，<code>CAFÉ</code>于<code>Café</code>是同一语义，只是重音不一样。</p>
<p>我们还可以对搜索的结果按匹配度进行排序：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.posts.find(</div><div class="line">   &#123; $text: &#123; $search: <span class="string">"hello world"</span> &#125; &#125;,</div><div class="line">   &#123; score: &#123; $meta: <span class="string">"textScore"</span> &#125; &#125;</div><div class="line">).sort( &#123; score: &#123; $meta: <span class="string">"textScore"</span> &#125; &#125; )</div></pre></td></tr></table></figure></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Mongodb建立文本索引时，会对提取所有文本的关键字建立索引，因而会造成一定的性能问题。所以对于结构化的字段，建议用普通的关系查询，如果需要对大段的文本进行搜索，才考虑用全文搜索。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在传统的关系型数据库中，我们通常将数据结构化，通过一系列表关联、聚合来查询我们所需的结果。而在非结构化的数据中，缺少这种预定义的结构，因而如何快速查询定位到我们所需要的结果，不是一件容易的事。&lt;/p&gt;
&lt;p&gt;Mongodb作为一种NoSQL数据库，非常适合存储和管理非结构化
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu server命令行配置shadowsocks全局代理</title>
    <link href="https://jingsam.github.io/2016/05/08/setup-shadowsocks-http-proxy-on-ubuntu-server.html"/>
    <id>https://jingsam.github.io/2016/05/08/setup-shadowsocks-http-proxy-on-ubuntu-server.html</id>
    <published>2016-05-08T07:15:10.000Z</published>
    <updated>2017-10-19T23:34:16.170Z</updated>
    
    <content type="html"><![CDATA[<p>由于Ubuntu Server是不带用户界面的，所以要为Server配置Shadowsocks还是稍显麻烦。本文就是我配置Shadowsocks的一些经验，以待参考。</p>
<h3 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h3><p>由于shadowsocks是基于python开发的，所以必须安装python：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="builtin-name">get</span> install python</div></pre></td></tr></table></figure></p>
<p>接着安装python的包管理器pip：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="builtin-name">get</span> install python-pip</div></pre></td></tr></table></figure></p>
<p>安装完毕之后，通过pip直接安装shadowsocks：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip <span class="keyword">install</span> shadowsocks</div></pre></td></tr></table></figure></p>
<h3 id="配置shadowsocks"><a href="#配置shadowsocks" class="headerlink" title="配置shadowsocks"></a>配置shadowsocks</h3><p>新建一个配置文件<code>shawdowsocks.json</code>，然后配置相应的参数：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"server"</span>: <span class="string">"&#123;your-server&#125;"</span>,</div><div class="line">  <span class="attr">"server_port"</span>: <span class="number">40002</span>,</div><div class="line">  <span class="attr">"local_port"</span>: <span class="number">1080</span>,</div><div class="line">  <span class="attr">"password"</span>: <span class="string">"&#123;your-password&#125;"</span>,</div><div class="line">  <span class="attr">"timeout"</span>: <span class="number">600</span>,</div><div class="line">  <span class="attr">"method"</span>: <span class="string">"aes-256-cfb"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的参数需要你的shawdowsocks服务提供商为你提供，当然你也可以自己搭建一个。如何搭建个人的shawdowsocks不在本文讨论范围之内，请参阅其他教程。</p>
<p>配置完成后就可以启动shawdowsocks服务：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo sslocal -c shawdowsocks<span class="selector-class">.json</span> -d start</div></pre></td></tr></table></figure></p>
<h3 id="配置全局代理"><a href="#配置全局代理" class="headerlink" title="配置全局代理"></a>配置全局代理</h3><p>启动shawdowsocks服务后，发现并不能翻墙上网，这是因为shawdowsocks是socks 5代理，需要客户端配合才能翻墙。</p>
<p>为了让整个系统都走shawdowsocks通道，需要配置全局代理，可以通过polipo实现。</p>
<p>首先是安装polipo：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-<span class="builtin-name">get</span> install polipo</div></pre></td></tr></table></figure></p>
<p>接着修改polipo的配置文件<code>/etc/polipo/config</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">logSyslog = <span class="literal">true</span></div><div class="line">logFile = /var/<span class="built_in">log</span>/polipo/polipo.log</div><div class="line"></div><div class="line">proxyAddress = <span class="string">"0.0.0.0"</span></div><div class="line"></div><div class="line">socksParentProxy = <span class="string">"127.0.0.1:1080"</span></div><div class="line">socksProxyType = socks5</div><div class="line"></div><div class="line">chunkHighMark = 50331648</div><div class="line">objectHighMark = 16384</div><div class="line"></div><div class="line">serverMaxSlots = 64</div><div class="line">serverSlots = 16</div><div class="line">serverSlots1 = 32</div></pre></td></tr></table></figure></p>
<p>重启polipo服务：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/polipo restart</span></div></pre></td></tr></table></figure></p>
<p>为终端配置http代理：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=<span class="string">"http://127.0.0.1:8123/"</span></div></pre></td></tr></table></figure></p>
<p>接着测试下能否翻墙：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl www<span class="selector-class">.google</span><span class="selector-class">.com</span></div></pre></td></tr></table></figure></p>
<p>如果有响应，则全局代理配置成功。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>服务器重启后，下面两句需要重新执行：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo sslocal -c shawdowsocks.json -d start</div><div class="line"><span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=<span class="string">"http://127.0.0.1:8123/"</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于Ubuntu Server是不带用户界面的，所以要为Server配置Shadowsocks还是稍显麻烦。本文就是我配置Shadowsocks的一些经验，以待参考。&lt;/p&gt;
&lt;h3 id=&quot;安装shadowsocks&quot;&gt;&lt;a href=&quot;#安装shadowsocks&quot; c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nodejs网站部署到DigtialOcean</title>
    <link href="https://jingsam.github.io/2016/04/20/deploy-to-digitialocean.html"/>
    <id>https://jingsam.github.io/2016/04/20/deploy-to-digitialocean.html</id>
    <published>2016-04-20T09:27:21.000Z</published>
    <updated>2017-10-19T23:34:16.170Z</updated>
    
    <content type="html"><![CDATA[<p>最近基于Express + Mongodb开发了一个纯API服务，现在要部署到公网上。我选择的是DigitialOcean的主机，但整个部署过程不仅仅适用于DigitialOcean，其他VPS也可参考。</p>
<h2 id="创建主机"><a href="#创建主机" class="headerlink" title="创建主机"></a>创建主机</h2><p>假设我们现在已经注册了DigitialOcean账号，并且通过了邮箱验证和信用卡绑定。<br>首先创建一个主机，登录后点击<code>Create Droplets</code>，即可开始创建主机。Droplets的意思是小水滴，DigitialOcean是数字海洋，两者之间的关系还是蛮形象的。<br>在创建主机界面，我们可以选择主机的操作系统、服务器的位置、服务器的硬件配置等。我选择的是Ubuntu 15.10，San Franscisco的机房，以及最便宜5美元一个月的配置：1 CPU + 512M RAM + 20G SSD。<br>选择完配置之后，先别忙着点确定。里面有一项叫SSH key，可以将你的SSH的公钥填进去，这样我们稍后登录主机的时候就不需要填密码了。当然，如果你不知道怎么生成SSH key或者嫌麻烦，也可以通过密码登录，密码会在你创建完主机之后发到你的注册邮箱。</p>
<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>当主机创建完之后，我们可以通过SSH远程登录到主机上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh root@xxx.xxx.xxx.xxx</div></pre></td></tr></table></figure></p>
<p>这里有个问题就是，我们是以root身份登录到系统中，而我们网站不能在root权限下部署。否则，要是有黑客获取了网站控制权限，就掌握了主机的控制权限，这是很危险的。所以，我们需要创建一个普通权限的用户，以普通用户的身份部署网站。</p>
<p>使用下面的命令添加新用户和密码，其中<code>-m</code>表示在<code>/home</code>目录下创建用户文件夹。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add user -m judy</div><div class="line">passwd judy</div></pre></td></tr></table></figure></p>
<p>为了之后安装软件方便，我们将新用户添加到<code>sudo</code>组中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo adduser judy sudo</div></pre></td></tr></table></figure></p>
<p>现在我们完成了新用户的创建。有些人在使用SSH登录到DigitalOcean后会发现很卡，打个命令半天才回显，在这里我推荐一款很好用的SSH替代软件：mosh。SSH的机制是我们输入一个字符，这个字符会发送到远程服务器，然后远程服务器收到后再发送回终端显示。在这个传输过程中，如果网络条件不好，会产生明显地卡顿。而mosh在你输入一个字符时，立即在终端上显示，然后再后台自动地将命令发送到远程服务器。因此即使在较差的网络条件下，mosh也可以很流畅。</p>
<p>mosh需要在客户端和服务端同时安装，安装的的命令如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-<span class="builtin-name">get</span> install mosh</div></pre></td></tr></table></figure></p>
<p>退出root用户，然后用mosh重连，你将会发现比之前流畅多了，mosh连接的命令和SSH一样：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">mosh</span> <span class="selector-tag">judy</span>@<span class="keyword">xxx</span>.<span class="keyword">xxx</span>.<span class="keyword">xxx</span>.<span class="keyword">xxx</span></div></pre></td></tr></table></figure></p>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>由于我们的网站是基于Express的，因此需要安装nodejs。Ubuntu的官方源上没有nodejs，需要添加nodesource源，安装的命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install curl</div><div class="line">curl -sL https://deb.nodesource.com/setup_5.x | sudo -E bash -</div><div class="line">sudo apt-get install nodejs</div></pre></td></tr></table></figure></p>
<p><code>sudo</code>命令是临时借用root的权限去执行命令。</p>
<h2 id="安装mongodb和git"><a href="#安装mongodb和git" class="headerlink" title="安装mongodb和git"></a>安装mongodb和git</h2><p>网站的数据库采用的是mongodb，幸运的是Ubuntu的官方源收录了mongodb，所以我们可以直接用apt安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mongodb</div></pre></td></tr></table></figure></p>
<p>mongodb安装完之后会自动启动守护程序mongod，并设置了开机自启动。检查mongodb是否成功启动，可以运行<code>mongo</code>连接数据是否成功。</p>
<p>网站的源代码托管在GitHub上，所以要把代码下载下来，我们还需要安装git：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>通过git将网站源代码拉取下来，并安装相应的依赖：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/&#123;your_git_repo&#125; site</div><div class="line">cd site</div><div class="line">npm install</div></pre></td></tr></table></figure></p>
<p>网站的软件环境基本上准备好了，如果代码有测试的话，可以跑一遍测试看网站是否各项功能正常。</p>
<p>Express网站开发的时候，默认的服务端口是3000。由于服务是公开发布的，总不能让用户还在网址后面加个端口号吧。所以，我们将网站切换到80端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PORT=80 node ./bin/www</div></pre></td></tr></table></figure></p>
<p>不幸的是，你将马上看到出错信息，信息显示80端口只有root用户才能使用。实际上，任何小于1024的端口，都只能由root用户使用。所以我们用采取一定的措施，使得网站服务可以使用80端口。方法很简单，我们可以借助cap2实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libcap2-bin</div><div class="line">sudo <span class="built_in">setcap</span> cap_net_bind_service=+ep `<span class="built_in">which</span> nodejs`</div></pre></td></tr></table></figure></p>
<p>后一条命令中的<code>which nodejs</code>是找出nodejs可执行文件的路径，一定要是nodejs的实际路径，不能是符号链接。</p>
<p>执行以上命令后，再次测试就会发现能够使用80端口了。</p>
<h2 id="更改时区"><a href="#更改时区" class="headerlink" title="更改时区"></a>更改时区</h2><p>新建的主机默认的时区是0时区，更改为北京时间可用交互式的命令行工具<code>tzselect</code>:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tzselect</div><div class="line">sudo cp <span class="regexp">/usr/</span>share<span class="regexp">/zoneinfo/</span>Asia<span class="regexp">/Shanghai /</span>etc<span class="regexp">/localtime</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上过程，基本上完成了对服务器的配置。但是还有很多工作要做，例如nodejs进程自动重启、网站制动部署等，这将在以后的博文中逐步说明。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近基于Express + Mongodb开发了一个纯API服务，现在要部署到公网上。我选择的是DigitialOcean的主机，但整个部署过程不仅仅适用于DigitialOcean，其他VPS也可参考。&lt;/p&gt;
&lt;h2 id=&quot;创建主机&quot;&gt;&lt;a href=&quot;#创建主机&quot; 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TileJSON技术规范</title>
    <link href="https://jingsam.github.io/2016/04/18/tilejson-spec.html"/>
    <id>https://jingsam.github.io/2016/04/18/tilejson-spec.html</id>
    <published>2016-04-18T05:18:29.000Z</published>
    <updated>2017-10-19T23:34:16.169Z</updated>
    
    <content type="html"><![CDATA[<p>以下是<a href="https://github.com/mapbox/tilejson-spec/tree/master/2.1.0" target="_blank" rel="external">《TileJSON Specification》</a>最新的2.1.0版的中文翻译，以便查阅。</p>
<h1 id="TileJSON-2-1-0"><a href="#TileJSON-2-1-0" class="headerlink" title="TileJSON 2.1.0"></a>TileJSON 2.1.0</h1><p>本文档中的“<strong>必须</strong>”、“<strong>必须不</strong>”、“<strong>必备</strong>”、”<strong>应该</strong>“、“<strong>不应该</strong>”、“<strong>建议</strong>”、“<strong>可以</strong>”、“<strong>可选</strong>”的含义参照<a href="https://www.ietf.org/rfc/rfc2119.txt" target="_blank" rel="external">RFC 2119</a>。</p>
<h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h2><p>本规范提出一种技术标准，来描述多种类型的网络地图图层的元数据信息，以方便客户端进行配置和浏览。</p>
<h2 id="2-文件格式"><a href="#2-文件格式" class="headerlink" title="2. 文件格式"></a>2. 文件格式</h2><p>TileJSON描述文件采用JSON格式，参见RFC 4627。</p>
<p>本规范的实现<strong>必须</strong>忽略掉未知key。但是，实现<strong>必须</strong>在他们的API中暴露出<br>这些未知的key/values，使得API用户可以选择性地处理这些keys。<br>实现<strong>必须</strong>忽略keys的无效values。如果key是必选的，实现<strong>必须</strong>认为整个<br>TileJSON描述文件无效并且拒绝进一步处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// **必选**。表示语义化的版本号。描述本JSON对象所遵守的TileJSON版本。</span></div><div class="line">    <span class="string">"tilejson"</span>: <span class="string">"2.1.0"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。表示瓦片集的名称。名称可以是任何合法字符。</span></div><div class="line">    <span class="comment">// 实现**不应该**将此名称当做HTML来解析。</span></div><div class="line">    <span class="string">"name"</span>: <span class="string">"compositing"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。表示瓦片集的描述信息。描述可以是任何合法字符。</span></div><div class="line">    <span class="comment">// 实现**不应该**将此描述当做HTML来解析。</span></div><div class="line">    <span class="string">"description"</span>: <span class="string">"A simple, light grey world."</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值："1.0.0"。表示语义化的版本号。当瓦片发生更改时，次版本号</span></div><div class="line">    <span class="comment">// **必须**相应地更改。这可能导致标签的变化。因此，实现方能够在次版本号变化时</span></div><div class="line">    <span class="comment">// 清除缓存。更新级别的更改，**必须**限制在单块瓦片之内。</span></div><div class="line">    <span class="comment">// 当瓦片更改较大时，主版本号**必须**增加。</span></div><div class="line">    <span class="comment">// 实现**必须不**要使用不同主版本号的瓦片。</span></div><div class="line">    <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。包含地图的所有者信息。</span></div><div class="line">    <span class="comment">// 实现**可以**把这部分内容当做HTML或者纯文本。</span></div><div class="line">    <span class="comment">// 处于安全方面的原因，要绝对确保本字段的不会被用来进行XSS攻击或beacon跟踪。</span></div><div class="line">    <span class="string">"attribution"</span>: <span class="string">"&lt;a href='http://openstreetmap.org'&gt;OSM contributors&lt;/a&gt;"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。包含一个mustache模板，用来格式化grids数据来完成交互。</span></div><div class="line">    <span class="comment">// 参见https://github.com/mapbox/utfgrid-spec/tree/master/1.2的交互部分。</span></div><div class="line">    <span class="string">"template"</span>: <span class="string">"&#123;&#123;#__teaser__&#125;&#125;&#123;&#123;NAME&#125;&#125;&#123;&#123;/__teaser__&#125;&#125;"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。包含地图图例信息。</span></div><div class="line">    <span class="comment">// 实现**可以**把这部分内容当做HTML或者纯文本。</span></div><div class="line">    <span class="comment">// 处于安全方面的原因，要绝对确保本字段的不会被用来进行XSS攻击或beacon跟踪。</span></div><div class="line">    <span class="string">"legend"</span>: <span class="string">"Dangerous zones are red, safe zones are green"</span>,</div><div class="line">、</div><div class="line">    <span class="comment">// **可选**。默认值："xyz"。可以是"xyz"或"tms"。主要影响瓦片坐标的y轴方向。</span></div><div class="line">    <span class="comment">// 默认为global-mercator(Spherical Mercator)坐标系。</span></div><div class="line">    <span class="string">"scheme"</span>: <span class="string">"xyz"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **必选**。表示一组瓦片资源。</span></div><div class="line">    <span class="comment">// 如果存在&#123;z&#125;、&#123;x&#125;和&#123;y&#125;，它们将会被相应的整数替换。</span></div><div class="line">    <span class="comment">// 如果指定了多个资源，客户端可以使用任意的资源组合。</span></div><div class="line">    <span class="comment">// 所有的资源**必须**为相同的URL返回相同的内容。</span></div><div class="line">    <span class="comment">// 本数组**必须**至少包含一个资源。</span></div><div class="line">    <span class="string">"tiles"</span>: [</div><div class="line">        <span class="string">"http://localhost:8888/admin/1.0.0/world-light,broadband/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png"</span></div><div class="line">    ],</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：[]。表示一组交互资源。</span></div><div class="line">    <span class="comment">// 如果存在&#123;z&#125;、&#123;x&#125;和&#123;y&#125;，它们将会被相应的整数替换。</span></div><div class="line">    <span class="comment">// 如果指定了多个资源，客户端可以使用任意的资源组合。</span></div><div class="line">    <span class="comment">// 所有的资源**必须**为相同的URL返回相同的内容。</span></div><div class="line">    <span class="comment">// 如果本数组没有任何内容，那么说明本瓦片集不支持交互数据。</span></div><div class="line">    <span class="comment">// 参见https://github.com/mapbox/utfgrid-spec/tree/master/1.2的交互部分</span></div><div class="line">    <span class="string">"grids"</span>: [</div><div class="line">        <span class="string">"http://localhost:8888/admin/1.0.0/broadband/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.grid.json"</span></div><div class="line">    ],</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：[]。表示一组GeoJSON格式的数据文件。</span></div><div class="line">    <span class="comment">// 如果存在&#123;z&#125;、&#123;x&#125;和&#123;y&#125;，它们将会被相应的整数替换。</span></div><div class="line">    <span class="comment">// 如果指定了多个资源，客户端可以使用任意的资源组合。</span></div><div class="line">    <span class="comment">// 所有的资源**必须**为相同的URL返回相同的内容。</span></div><div class="line">    <span class="comment">// 如果本数组没有任何内容，那么地图上不会呈现数据内容。</span></div><div class="line">    <span class="string">"data"</span>: [</div><div class="line">        <span class="string">"http://localhost:8888/admin/data.geojson"</span></div><div class="line">    ],</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：0。值域范围[0, 22]。</span></div><div class="line">    <span class="comment">// 表示最小缩放级别的一个整数。</span></div><div class="line">    <span class="string">"minzoom"</span>: <span class="number">0</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：22。值域范围[0, 22]。</span></div><div class="line">    <span class="comment">// 表示最大缩放级别的一个整数。**必须**大于等于minzoom</span></div><div class="line">    <span class="string">"maxzoom"</span>: <span class="number">11</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 表示地图瓦片的最大范围。这个范围**必须**覆盖到所有的缩放级别。</span></div><div class="line">    <span class="comment">// 范围用WGS84坐标系下的经纬度来表示，顺序为左、下、右、上。</span></div><div class="line">    <span class="comment">// 范围值可能是整数或者浮点数。</span></div><div class="line">    <span class="string">"bounds"</span>: [ <span class="number">-180</span>, <span class="number">-85.05112877980659</span>, <span class="number">180</span>, <span class="number">85.0511287798066</span> ],</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。</span></div><div class="line">    <span class="comment">// 第一个值是经度，第二个是纬度（都为WGS84坐标系），第三个是表示缩放级别的整数。</span></div><div class="line">    <span class="comment">// 经度和纬度**必须**在bounds范围内。缩放级别**必须**在minzoom和maxzoom之间。</span></div><div class="line">    <span class="comment">// 实现可以根据这个值设置地图的默认显示位置。</span></div><div class="line">    <span class="comment">// 如果这个值为null，实现可以根据自己的算法自行决定默认位置。</span></div><div class="line">    <span class="string">"center"</span>: [ <span class="number">-76.275329586789</span>, <span class="number">39.153492567373</span>, <span class="number">8</span> ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3. 缓存"></a>3. 缓存</h2><p>客户端<strong>可以</strong>缓存从远程服务器获取的文件。当实现决定采用缓存措施时，<strong>必须</strong><br>遵从为瓦片数据和TileJSON描述文件定义的有效HTTP缓存控制头。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下是&lt;a href=&quot;https://github.com/mapbox/tilejson-spec/tree/master/2.1.0&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《TileJSON Specification》&lt;/a&gt;最新的2.1.
    
    </summary>
    
    
  </entry>
  
</feed>
