<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[2018计划]]></title>
      <url>https://jingsam.github.io/2018/02/26/2018-plan.html</url>
      <content type="html"><![CDATA[<p>过去一年，发现自己越来越难以下笔写东西，原因是身体和思想上的双重懒惰。常常是心中拟定了很多写作的题目，而到要下笔写的时候，总是觉得我对这个主题研究还不够深入全面，然后就默默地为自己找到一个借口：“等我把这个研究透之后再下笔写”，最终就不了了之了。</p>
<p>博文对于我而言，是一种对技术的总结和沉淀。回望2017，自己的博文写得很少，心中很是失落。失落在于自己的心太浮躁，对技术没有进行总结和沉淀。</p>
<p>我下决心在2018年要多写文章，在此立下flag：“2018年每月要产出4篇文章，全年要有48篇文章上线”。要实现这个目标，首先“等我把这个研究透之后再下笔写”这种借口就不成立了，想到某个主题直接写就是了，深度不够？再来一篇。其二，时间上要保障，自己要把逛社交网站、看新闻的时间，抽出来作为写作的时间。三是注意力要集中，不能什么技术研究到一半，注意力又转移到其他技术上了。</p>
<p>关于写作的主题范围，主要还是矢量瓦片方面的技术，包括mapbox-gl-js、矢量切片工具、矢量瓦片服务以及矢量瓦片在时空大数据可视化方面的应用。</p>
<p>关于个人的技术成长，总来的说，要强核心、补短板、宽视野。“强核心”是要强化自己在在线制图和大数据可视化方面的积累，这是自己的核心竞争力，看家老本不能丢。“补短板”是补全自己在Web开发方面的不足，主要是CSS、WebGL以及对MVVM模式的认识，这方面需要自己系统地阅读书籍以及流行库的源代码。“宽视野”是要扩大自己的技术范围，自己不能局限于某一项技术上，要广泛涉猎，知道各项技术的原理，能够敏锐地察觉到某项技在地理信息中的应用前景。</p>
<p>最后，以上的目标要实现的前提是，自己要加强时间的管理。过去的一年，自己没闲着，一直在忙项目上的事情。但从心底来说，对于去年自己的成果，不甚满意，我认为本来还可以完成更多事情。究其原因，自己在时间的安排、任务优先级的把控方面很是不足。所以，今年迫切要改掉坏习惯，把自己的时间规划好。具体做法还是多动笔杆子，把自己的计划事项写下来，这样自己才能不断地排优先级、做计划、实施以及最后的回顾。</p>
<p>总而言之，“凡事预则立，不预则废”。2018，我要做一个有计划的人。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mapbox-gl-js接入GeoJSON大文件的优化策略]]></title>
      <url>https://jingsam.github.io/2017/10/23/large-geojson-with-mapbox-gl-js.html</url>
      <content type="html"><![CDATA[<p>mapbox-gl-js可以接受GeoJSON数据，在前端动态地绘制GeoJSON数据。需要说明的是，mapbox-gl-js并不能直接渲染GeoJSON数据，而是通过<code>geojson-vt</code>这个库，在前端动态地将GeoJSON数据转换为矢量瓦片后渲染。至于为什么不支持直接渲染GeoJSON数据，我猜想是因为mapbox-gl-js对于点、线、面、符号、注记等要素的绘制规则都是基于矢量瓦片的，为GeoJSON另外实现一套绘制规则，不仅增大了实现成本，而且两套规则可能会出现冲突。</p>
<p>传统的矢量数据需要预先切片、存储、发布服务，并且当数据更新时又得重新切片，对于小项目来说有点大炮打蚊子的感觉。GeoJSON数据源的好处是接入容易、更新方便，并且市面上有很多工具可以将各种矢量数据转换为GeoJSON格式。</p>
<p>通常来说，GeoJSON数据源适合于少量的矢量数据，大批量的矢量数据最好还是预先切片。但多少数据算是”少量数据呢“？从经验上讲，应该将GeoJSON数据控制在20M以下。需要说明的是，之所以提出”20M“这个经验值，并不是因为mapbox-gl-js对于渲染超过20M的GeoJOSN数据有困难，而是综合考虑网络请求时间和解析数据的时间。实际上，mapbox-gl-js处理100M的GeoJSON数据都没有什么问题，但是把大量的GeoJSON数据整体请求过来所产生的耗时，会严重影响用户体验。所以对于大量的GeoJSON数据，最好预先切片，这样前端可以分块请求，减少网络请求时间和解析数据的时间。</p>
<p>虽然使用GeoJSON大文件作为数据源不是最佳选择，但有些情况下我们不得不使用GeoJSON作为数据源，例如数据是由第三方通过API提供的、数据是实时更新的。当接入大GeoJSON数据时，我们可以通过以下几种优化策略，提高地图绘制的效率。</p>
<h1 id="使用cluster选项"><a href="#使用cluster选项" class="headerlink" title="使用cluster选项"></a>使用cluster选项</h1><p>如果需要接入的数据是点数据，并且十分密集，这时应该对点进行聚合。特别密集的点在小缩放级别会重叠在一起，造成注记压盖叠加，可视化效果不好。使用聚合后，小的缩放级别显示聚合数据，大的缩放级别显示原始数据，兼顾了综合和细节。并且，聚合减少了单张瓦片的数据量，使得引擎绘制更快，交互更流畅。</p>
<p>mapbox-gl-js是通过<code>supercluster</code>这个库对GeoJSON数据进行聚合。其原理是两个点的显示距离小于聚合半径时，聚合为一个点要素，这个点会有一个<code>point_count</code>字段记录聚合的点的数目。需要注意的是，并不是每个层级上所有的点都被聚合，有些孤立的点会保留原位。那么如何区分聚合的和未聚合的点要素呢？可以使用有没有<code>point_cluster</code>进行判断，即使用<code>&quot;filter&quot;: [&quot;has&quot;, &quot;point_count&quot;]</code>过滤出聚合的点要素，使用<code>&quot;filter&quot;: [&quot;!has&quot;, &quot;point_count&quot;]</code>过滤出未聚合的点要素。</p>
<p>mapbox-gl-js通过<code>cluster</code>、<code>clusterRadius</code>、<code>clusterMaxZoom</code>三个参数控制点聚合的效果，并且是要在<code>source</code>里面配置。从逻辑上讲，这三个是控制聚合的效果的，应该放到<code>layer</code>上更符合直觉。然而，mapbox-gl-js的聚合过程并不是在渲染层实现的，而是在数据层实现的，即在动态切片的时候对数据做了聚合操作。所以，从实现角度来讲，将聚合控制参数放在<code>source</code>是合情合理的。以下是这三个参数的说明：</p>
<ul>
<li><code>cluster</code>：设为<code>true</code>开启GeoJSON数据聚合，只对点数据有效；</li>
<li><code>clusterRaius</code>：聚合半径，默认为50像素。当你发现有很多点没有被聚合时，可以适当调大这个参数；</li>
<li><code>clusterMaxZoom</code>：聚合的最大层级，大于这个层级的数据不再聚合，默认值是<code>maxzoom - 1</code>。</li>
</ul>
<h1 id="减小buffer"><a href="#减小buffer" class="headerlink" title="减小buffer"></a>减小buffer</h1><p>矢量瓦片一般会向边界外围扩张一定距离，作为缓冲区，以免边界上的接边要素出现断开的现象。缓冲区越大，出现断裂的可能性越小，但同时导致每张瓦片的尺寸变大，渲染的效率也更低。可以适当减小缓冲区的大小，减小瓦片的额体积，提高渲染效率。</p>
<p><code>buffer</code>的默认值是128像素，能够应付大部分情况。当GeoJSON是点数据，并且用来渲染点要素的符号和注记文本宽度比较小时，可以尝试将<code>buffer</code>设置为0或者稍大的值。</p>
<h1 id="减小maxzoom"><a href="#减小maxzoom" class="headerlink" title="减小maxzoom"></a>减小maxzoom</h1><p><code>maxzoom</code>用来控制将GeoJSON数据切割成矢量瓦片的最大级别，默认值是18级。减小<code>maxzoom</code>，可以加快切片的速度。一般来说，切割到12级，可以保证一定的精度和速度，满足大部分应用需求。</p>
<h1 id="对数据进行minify"><a href="#对数据进行minify" class="headerlink" title="对数据进行minify"></a>对数据进行minify</h1><p>对GeoJSON数据进行minify，即移除JSON中多余的空格、换行符、注释，以及减少坐标点的小数位，可以减小GeoJSON的体积，减小加载时间。</p>
<h1 id="使用URL加载数据"><a href="#使用URL加载数据" class="headerlink" title="使用URL加载数据"></a>使用URL加载数据</h1><p>使用GeoJSON作为数据源，既可以将GeoJSON数据内联到样式文件中，也可以通过URL引用。从直觉上讲，使用内联的GeoJSON不需要网络请求，应该比URL方式更快，然而并不是这样的。使用内联的方式加载大量GeoJSON数据，有以下几个弊端：</p>
<ol>
<li>使样式文件变大，增加了解析的时间；</li>
<li>内联的GeoJSON数据解析后无法释放，将会一直占用内存。</li>
</ol>
<p>因此，对于大GeoJSON数据，尽量以URL的方式加载，可以减少客户端的内存占用。</p>
<h1 id="渲染时增大minzoom"><a href="#渲染时增大minzoom" class="headerlink" title="渲染时增大minzoom"></a>渲染时增大minzoom</h1><p>在配置GeoJSON渲染图层时，默认的<code>minzoom</code>是0，可以适当增大<code>minzoom</code>。<code>geojson-vt</code>在动态切片时，默认小于5级的瓦片是按需生成，大于或等于5级是预先生成。所以，但渲染图层的<code>minzoom</code>大于等于5时，小层级的瓦片不会生成，减少了计算负担。另外，增大<code>minzoom</code>，可以在小层级不需要加载、解析、渲染瓦片，所以渲染更为流畅。</p>
<h1 id="渲染时允许符号重叠"><a href="#渲染时允许符号重叠" class="headerlink" title="渲染时允许符号重叠"></a>渲染时允许符号重叠</h1><p>在配置GeoJSON渲染图层时，可以设置允许注记符号重叠，即设置<code>icon-allow-overlap: true</code>，提高渲染的效率。</p>
<p>mapbox-gl-js在渲染注记符号和文本时，会有一个碰撞检测的过程，即当两个注记有重叠，则隐藏一个。常规条件下，这个碰撞检测很快，耗时可以忽略不计。但是，如果数据中的点非常密集，这部分耗时还是比较客观的。所以，设置<code>icon-allow-overlap: true</code>关闭这个检测过程，可以提高渲染效率。</p>
<p>当然，可以进一步设置允许注记文本也可以重叠，即设置<code>text-allow-overlap: true</code>，继续提高渲染效率。然而，从用户的角度来说，地图上出现符号重叠可以忍受，文本重叠就比较难看了。所以，一般不推荐设置允许注记文本重叠。</p>
<h1 id="对数据进行切分"><a href="#对数据进行切分" class="headerlink" title="对数据进行切分"></a>对数据进行切分</h1><p>如果GeoJSON数据实在很大，可以将GeoJSON数据切分为几块，分别加载。比如，原来是一个GeoJSON大文件，现在把它切分为两个比较小的GeoJSON文件，可以提高处理的效率，原因在于：</p>
<ol>
<li>切分的数据可以并行请求。例如，请求两个5M的数据，比单独请求一个10M的数据要快；</li>
<li><code>geojson-vt</code>处理小文件比处理大文件快。</li>
</ol>
<h1 id="预先切片"><a href="#预先切片" class="headerlink" title="预先切片"></a>预先切片</h1><p>如果GeoJSON数据太大了，比如100M，以上的种种优化方法都不可行。GeoJSON没办法增量加载，必须将完整的GeoJSON数据请求过来，才能开始处理。大的GeoJSON数据，光网络请求就会占用大量时间，所以必须预先切片，分块加载。</p>
<p>预先切片有诸多好处，如减少网络请求时间、渲染效率高。但是，预先切片需要工具切片、瓦片服务器发布服务，而且数据更新有点麻烦。到底切不切片，是动态切片还是预先切片，需要根据数据的情况来确定。</p>
<p>你可以将数据上传到Mapbox Studio进行自动切片，也可以使用开源工具<a href="https://github.com/mapbox/tippecanoe" target="_blank" rel="external">tippecanoe</a>对GeoJSON数据自行切片。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol>
<li><a href="https://blog.mapbox.com/rendering-big-geodata-on-the-fly-with-geojson-vt-4e4d2a5dd1f2" target="_blank" rel="external">https://blog.mapbox.com/rendering-big-geodata-on-the-fly-with-geojson-vt-4e4d2a5dd1f2</a></li>
<li><a href="https://blog.mapbox.com/clustering-millions-of-points-on-a-map-with-supercluster-272046ec5c97" target="_blank" rel="external">https://blog.mapbox.com/clustering-millions-of-points-on-a-map-with-supercluster-272046ec5c97</a></li>
<li><a href="https://gist.github.com/ryanbaumann/2d5c851aebf46e4ef5702ee29ead6bdb" target="_blank" rel="external">https://gist.github.com/ryanbaumann/2d5c851aebf46e4ef5702ee29ead6bdb</a></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[mapbox-gl如何高效地高亮要素]]></title>
      <url>https://jingsam.github.io/2017/10/20/mapbox-gl-highlight.html</url>
      <content type="html"><![CDATA[<p>mapbox-gl基于矢量瓦片的前端渲染技术，使得要素高亮变得简单。要素高亮具体如何实现，有如下三种方法：</p>
<h1 id="第一种：动态过滤"><a href="#第一种：动态过滤" class="headerlink" title="第一种：动态过滤"></a>第一种：动态过滤</h1><p>这种方法的基本思路是添加一个高亮图层，然后根据鼠标hover的要素id，动态地改变filter条件，实现要素的高亮。</p>
<p>使用到的主要接口是<code>map.on(&#39;mousemove&#39;, layer, e)</code>，其中<code>e</code>可以获取到当前鼠标位置的features，效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/f3au0qLo/4/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试中发现，在图斑比较密集的情况下，高亮非常卡，滞后严重，效率并不高。</p>
<h1 id="第二种：数据源镜像"><a href="#第二种：数据源镜像" class="headerlink" title="第二种：数据源镜像"></a>第二种：数据源镜像</h1><p>第二种方法是对第一种方法的改进，思路如下：对原始数据源做一个镜像，即添加一个新的数据源，名称不通但指向的是同一套数据,例如下面示例中的<code>source-mirror</code>，高亮图层的数据源指向<code>source-mirror</code>。改进后的效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/rj16bqa4/4/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试可以发现，稍微改进一下，高亮的效率提升很大。</p>
<p>但为什么做一个数据源镜像就可以显著地提高高亮的效率呢？我猜想是mapbox-gl在绘制时，会按照数据源对图层分组。指向同一个数据源的图层组中，任意一个图层的渲染条件改变，将会以整个图层组为粒度重新进行运算。在第一种方法中，高亮图层和其他图层都指向同一个数据源，动态地改变高亮图层的过滤条件，导致了很大的运算开销。而第二种方法，为高亮图层单独分配一个数据源，动态地改变高亮图层的过滤条件，也只会导致高亮图层的重绘。</p>
<h1 id="第三种：动态生成高亮数据源"><a href="#第三种：动态生成高亮数据源" class="headerlink" title="第三种：动态生成高亮数据源"></a>第三种：动态生成高亮数据源</h1><p>我们能不能再进一步提高高亮的效率呢？有。第三种方法的思路是：为高亮图层生成一个空的GeoJSON数据源，然后将鼠标hover到的要素动态地填充到数据源中。</p>
<p>使用的接口只要是<code>map.getSource(source).setData(geojson)</code>，其中<code>getSource</code>用于根据sourceId获取数据源，<code>setData</code>用于动态更新数据。效果如下：</p>
<iframe width="100%" height="500" src="//jsfiddle.net/jingsam/ykoyet0w/4/embedded/result,js,html,css" frameborder="0"></iframe>

<p>测试可以发现，这种方法甚至比第二种方法效率更高。原因在于要高亮的要素往往很小，前段切成瓦片可能就一两张，因此不用去整体从原始数据源的瓦片种过滤，效率会更高。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>第一种方法最常用，小批量数据效率还行，但涉及到大数据量情况下，效率就不太理想了。</p>
<p>第二种方法通过小小的改进，就可以极大地提高效率，实现起来也很简单。</p>
<p>第三种方法效率最高，但其中引入了<code>turf.union</code>去合并features，带来了额外的依赖。因此，从简单和优雅的角度来说，我更推荐使用第二种方法。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[docker save与docker export的区别]]></title>
      <url>https://jingsam.github.io/2017/08/26/docker-save-and-docker-export.html</url>
      <content type="html"><![CDATA[<p>很久没有写博客了，坟头草都长了老高了。写博客要靠惯性，一旦停下来时间长了，就很难再坚持下去。今天艰难地捡起来，以后每周至少写一篇。</p>
<p>这篇文章讲一讲docker save和docker export的区别。</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>docker save和docker export都能导出镜像包，咋看起来区别似乎不大。本文就针对这个问题，试图搞清楚docker save和docker export的功能是什么？适用于什么应用场景？</p>
<p>本文的测试的Docker版本如下，不保证所有版本的docker都能重现本文的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt;docker version</div><div class="line"></div><div class="line">Client:</div><div class="line"> Version:      17.07.0-ce-rc1</div><div class="line"> API version:  1.31</div><div class="line"> Go version:   go1.8.3</div><div class="line"> Git commit:   8c4be39</div><div class="line"> Built:        Wed Jul 26 05:19:44 2017</div><div class="line"> OS/Arch:      windows/amd64</div><div class="line"></div><div class="line">Server:</div><div class="line"> Version:      17.07.0-ce-rc1</div><div class="line"> API version:  1.31 (minimum version 1.12)</div><div class="line"> Go version:   go1.8.3</div><div class="line"> Git commit:   8c4be39</div><div class="line"> Built:        Wed Jul 26 05:25:01 2017</div><div class="line"> OS/Arch:      linux/amd64</div><div class="line"> Experimental: <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>另外我是在Windows on bash里面操作docker，有些命令如<code>ls</code>并不是windows命令，如果想要复现我的试验，请换成相应的windows命令。</p>
<h2 id="docker-save"><a href="#docker-save" class="headerlink" title="docker save"></a>docker save</h2><p>docker的命令行接口设计得很优雅，很多命令的帮助直接在后面加<code>--help</code>就可以查看。</p>
<p>docker save的帮助如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker save --<span class="built_in">help</span></div><div class="line"></div><div class="line">Usage:  docker save [OPTIONS] IMAGE [IMAGE...]</div><div class="line"></div><div class="line">Save one or more images to a tar archive (streamed to STDOUT by default)</div><div class="line"></div><div class="line">Options:</div><div class="line">      --<span class="built_in">help</span>            Print usage</div><div class="line">  -o, --output string   Write to a file, instead of STDOUT</div></pre></td></tr></table></figure></p>
<p>从命令行帮助可以看出，docker save是用来将一个或多个image打包保存的工具。</p>
<p>例如我们想将镜像库中的postgres和mongo打包，那么可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save -o images.tar postgres:9.6 mongo:3.4</div></pre></td></tr></table></figure></p>
<p>打包之后的<code>images.tar</code>包含<code>postgres:9.6</code>和<code>mongo:3.4</code>这两个镜像。</p>
<p>虽然命令行参数要求指定image，实际上也可以对container进行打包，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</div><div class="line">3623943d369f        postgres:9.6        <span class="string">"docker-entrypoint..."</span>   3 hours ago         Up 3 hours          5432/tcp            postgres</div><div class="line"></div><div class="line">&gt;docker save -o b.tar postgres</div><div class="line">&gt;docker save -o c.tar postgres:9.6</div><div class="line">&gt;ls -al</div><div class="line">-rwxrwxrwx 1 root root 277886464 8月  26 14:40 b.tar</div><div class="line">-rwxrwxrwx 1 root root 277886464 8月  26 14:41 c.tar</div></pre></td></tr></table></figure></p>
<p>通过以上命令可以看到，<code>b.tar</code>和<code>c.tar</code>是完全一模一样的。这说明，docker save如果指定的是container，docker save将保存的是容器背后的image。</p>
<p>将打包后的镜像载入进来使用docker load，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker load -i images.tar</div></pre></td></tr></table></figure></p>
<p>上述命令将会把<code>postgres:9.6</code>和<code>mongo:3.4</code>载入进来，如果本地镜像库已经存在这两个镜像，将会被覆盖。</p>
<p>docker save的应用场景是，如果你的应用是使用docker-compose.yml编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用docker save将用到的镜像打个包，然后拷贝到客户服务器上使用docker load载入。</p>
<h2 id="docker-export"><a href="#docker-export" class="headerlink" title="docker export"></a>docker export</h2><p>照例查看下docker export的帮助：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;docker export --help</div><div class="line"></div><div class="line">Usage:  docker export [OPTIONS] CONTAINER</div><div class="line"></div><div class="line">Export a container&apos;s filesystem as a tar archive</div><div class="line"></div><div class="line">Options:</div><div class="line">      --help            Print usage</div><div class="line">  -o, --output string   Write to a file, instead of STDOUT</div></pre></td></tr></table></figure></p>
<p>从帮助可以看出，docker export是用来将container的文件系统进行打包的。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker export -o postgres-export.tar postgres</div></pre></td></tr></table></figure></p>
<p>docker export需要指定container，不能像docker save那样指定image或container都可以。</p>
<p>将打包的container载入进来使用docker import，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker import postgres-export.tar postgres:latest</div></pre></td></tr></table></figure></p>
<p>从上面的命令可以看出，docker import将container导入后会成为一个image，而不是恢复为一个container。</p>
<p>另外一点是，docker import可以指定IMAGE[:TAG]，说明我们可以为镜像指定新名称。如果本地镜像库中已经存在同名的镜像，则原有镜像的名称将会被剥夺，赋给新的镜像。原有镜像将成为孤魂野鬼，只能通过IMAGE ID进行操作。</p>
<p>docker export的应用场景主要用来制作基础镜像，比如你从一个ubuntu镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p>
<h2 id="docker-save和docker-export的区别"><a href="#docker-save和docker-export的区别" class="headerlink" title="docker save和docker export的区别"></a>docker save和docker export的区别</h2><p>总结一下docker save和docker export的区别：</p>
<ol>
<li>docker save保存的是镜像（image），docker export保存的是容器（container）；</li>
<li>docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；</li>
<li>docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。</li>
</ol>
<h2 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h2><p>前面所讲的内容都是些基础知识，相信各位读者只要仔细看下官方文档就能知晓。这一节我来讲讲文档上没有的东西。</p>
<p>docker load和docker import都可以将tar包导入为镜像，我不禁脑洞一下，docker load能不能导入docker export的容器包，docker import能不能导入docker save的镜像包呢？</p>
<p>以下开始试验，准备以下两个文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;ls -al</div><div class="line">-rwxrwxrwx 1 root root 271760384 8月  26 12:15 postgres-export.tar</div><div class="line">-rwxrwxrwx 1 root root 398292480 8月  26 12:13 postgres-save.tar</div></pre></td></tr></table></figure></p>
<p>其中<code>postgres-export.tar</code>是通过docker export导出的容器包，<code>postgres-save.tar</code>是通过docker save保存的镜像包，两者都是基于<code>postgres:9.6</code>镜像。从文件大小可以直观的发现，<code>postgres-export.tar</code>显然要比<code>postgres-save.tar</code>小100多M。</p>
<p>现在试试docker load容器包<code>postgres-export.tar</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;docker load -i postgres-export.tar</div><div class="line">open /var/lib/docker/tmp/docker-import-082344818/bin/json: no such file or directory</div></pre></td></tr></table></figure></p>
<p>显然，docker load不能载入容器包。</p>
<p>那么，反过来，docker import载入镜像包可不可以呢？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;docker import postgres-save.tar postgres</div><div class="line">sha256:8910feec1ee2fac8c152dbdd0aaab360ba0b833af5c3ad59fcd648b9a24d4838</div><div class="line">&gt;docker image ls</div><div class="line">REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">postgres                                        latest              8910feec1ee2        2 minutes ago       398MB</div></pre></td></tr></table></figure></p>
<p>WTF，竟然成功了！！！</p>
<p>莫慌，再试试启动一个postgres容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;docker run postgres</div><div class="line">C:\Program Files\Docker\Docker\resources\bin\docker.exe: Error response from daemon: No command specified.</div><div class="line">See &apos;C:\Program Files\Docker\Docker\resources\bin\docker.exe run --help&apos;.</div></pre></td></tr></table></figure></p>
<p>虽然能够成功地导入为一个镜像，然而这个镜像并不能使用。</p>
<p>要搞清楚到底是怎么回事，我们先看看镜像包和容器包由什么区别：</p>
<p><img src="/assets/docker-save-vs-docker-export.png" alt="docker save vs docker export"></p>
<p>从上面可以看出右边的<code>postgres-export.tar</code>的内容是一个linux系统的文件目录，猜测就是一个linux镜像。而<code>postgres-save.tar</code>里面到底是什么内容呢？点开一个文件夹看看：</p>
<p><img src="/assets/postgres-save.png" alt="postgres-save.tar"></p>
<p>其实就是一个分层的文件系统。Docker镜像实际上就是由这样的一层层文件进行叠加起来的，上层的文件会覆盖下层的同名文件。如果将<code>postgres-save.tar</code>中的各层文件合并到一起，基本就是<code>postgres-export.tar</code>的内容。由于<code>postgres-save.tar</code>里面的各层文件会存在很多重复的文件，这也解释了为什么<code>postgres-save.tar</code>会比<code>postgres-export.tar</code>大100多M。</p>
<p>docker load必须要载入的是一个分层文件系统，而<code>postgres-export.tar</code>并不具有这样的结构，因此无法载入。</p>
<p>而docker import仅仅是将tar包里面的文件复制进来，所以不管tar包里面的文件结构是怎样的，都可以载入进来，所以能够载入<code>postgres-save.tar</code>。但<code>postgres-save.tar</code>并不是一个有效的操作系统镜像，因此当我试图以改镜像启动容器时，容器并不能启动。</p>
<p>我们再来看看docker import的帮助：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Usage:  docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</div><div class="line"></div><div class="line">Import the contents from a tarball to create a filesystem image</div><div class="line"></div><div class="line">Options:</div><div class="line">  -c, --change list      Apply Dockerfile instruction to the created image</div><div class="line">      --<span class="built_in">help</span>             Print usage</div><div class="line">  -m, --message string   Set commit message <span class="keyword">for</span> imported image</div></pre></td></tr></table></figure></p>
<p>似乎和docker commit很像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</div><div class="line"></div><div class="line">Create a new image from a container<span class="string">'s changes</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">Options:</span></div><div class="line"><span class="string">  -a, --author string    Author (e.g., "John Hannibal Smith</span></div><div class="line"><span class="string">                         &lt;hannibal@a-team.com&gt;")</span></div><div class="line"><span class="string">  -c, --change list      Apply Dockerfile instruction to the created image</span></div><div class="line"><span class="string">      --help             Print usage</span></div><div class="line"><span class="string">  -m, --message string   Commit message</span></div><div class="line"><span class="string">  -p, --pause            Pause container during commit (default true)</span></div></pre></td></tr></table></figure></p>
<p>发现docker import和docker commit都有<code>--change</code>和<code>--message</code>选项。我们可以将docker import理解为将外部文件复制进来形成只有一层文件系统的镜像，而docker commit则是将当前的改动提交为一层文件系统，然后叠加到原有镜像之上。</p>
<p>关于docker save和docker export的区别讲得差不多，拜了个拜。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://docs.docker.com/engine/reference/commandline/save/" target="_blank" rel="external">docker save帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/load/" target="_blank" rel="external">docker load帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/export/" target="_blank" rel="external">docker export帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/import/" target="_blank" rel="external">docker import帮助文档</a></li>
<li><a href="https://docs.docker.com/engine/reference/commandline/commit/" target="_blank" rel="external">docker commit帮助文档</a></li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue之slot深度复制]]></title>
      <url>https://jingsam.github.io/2017/03/08/vnode-deep-clone.html</url>
      <content type="html"><![CDATA[<p>在Vue中，<code>slot</code>是一个很有用的特性，可以用来向组件内部插入一些内容。<code>slot</code>就是“插槽”的意思，用大白话说就是：定义组件的时候留几个口子，由用户来决定插入的内容。</p>
<p>例如我们定义一个组件<code>MyComponent</code>，其包含一个<code>slot</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当调用<code>&lt;MyComponent&gt;123&lt;/MyComponent&gt;</code>时，会渲染为如下DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  123</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>现在又有新需求了，我们希望调用<code>&lt;MyComponent&gt;123&lt;/MyComponent&gt;</code>时，渲染出这样的DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  123</div><div class="line">  123</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>看起来很容易实现，即再为<code>MyComponent</code>添加一个<code>slot</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">      &lt;slot&gt;&lt;/slot&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>渲染出的结构也确实如你所愿，唯一美中不足的是控制台有一个小小的Warning：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Duplicate presence of slot &quot;default&quot; found in the same render tree</div></pre></td></tr></table></figure></p>
<p>如果你不是强迫症患者，这时候你可以收工安心回家睡觉了。直到有一天你的同事向你抱怨，为什么向<code>MyComponent</code>插入一个自定义组件会渲染不出来？</p>
<p>例如有一自定义组件<code>MyComponent2</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent2&apos;, &#123;</div><div class="line">  template: `</div><div class="line">    &lt;div&gt;456&lt;/div&gt;</div><div class="line">  `</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当调用<code>&lt;MyComponent&gt;&lt;MyComponent2&gt;&lt;/MyComponent2&gt;&lt;/MyComponent&gt;</code>时，预期渲染为如下DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;div&gt;456&lt;/div&gt;</div><div class="line">  &lt;div&gt;456&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>为什么不能正常工作呢？估计是前面的那个Warning搞得鬼，通过查询发现在Vue 2.0中不允许有重名的<code>slot</code>:</p>
<blockquote>
<p>重名的 Slots 移除<br>同一模板中的重名 <slot> 已经弃用。当一个 slot 已经被渲染过了，那么就不能在同一模板其它地方被再次渲染了。如果要在不同位置渲染同一内容，可一用 prop 来传递。</slot></p>
</blockquote>
<p>文档中提示可以用<code>props</code>来实现，然而在我的用例中显然是不合适的。经过搜索后，最靠谱的方法是手写render函数，将<code>slot</code>中的内容复制到其他的位置。</p>
<p>将之前的<code>MyComponent</code>改为render函数的方式定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  render (createElement) &#123;</div><div class="line">    return createElement(&apos;div&apos;, [</div><div class="line">      ...this.$slots.default,</div><div class="line">      ...this.$slots.default</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在上面的定义中我们插入了两个<code>this.$slots.default</code>，测试下能不能正常工作。然而并没有什么卵用，Vue文档在render函数这一章有以下说明：</p>
<blockquote>
<p>VNodes 必须唯一<br>所有组件树中的 VNodes 必须唯一</p>
</blockquote>
<p>这意味着我们不能简单地在不同位置引用<code>this.$slots.default</code>，必须对<code>slot</code>进行深度复制。深度复制的函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function deepClone(vnodes, createElement) &#123;</div><div class="line"></div><div class="line">  function cloneVNode (vnode) &#123;</div><div class="line">    const clonedChildren = vnode.children &amp;&amp; vnode.children.map(vnode =&gt; cloneVNode(vnode));</div><div class="line">    const cloned = createElement(vnode.tag, vnode.data, clonedChildren);</div><div class="line">    cloned.text = vnode.text;</div><div class="line">    cloned.isComment = vnode.isComment;</div><div class="line">    cloned.componentOptions = vnode.componentOptions;</div><div class="line">    cloned.elm = vnode.elm;</div><div class="line">    cloned.context = vnode.context;</div><div class="line">    cloned.ns = vnode.ns;</div><div class="line">    cloned.isStatic = vnode.isStatic;</div><div class="line">    cloned.key = vnode.key;</div><div class="line"></div><div class="line">    return cloned;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  const clonedVNodes = vnodes.map(vnode =&gt; cloneVNode(vnode))</div><div class="line">  return clonedVNodes;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的核心函数就是<code>cloneVNode()</code>，它递归地创建VNode，实现深度复制。VNode的属性很多，我并不了解哪些是关键属性，只是参照着Vue的源码一并地复制过来。</p>
<p>基于以上函数，我们更改<code>MyComponent</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;MyComponent&apos;, &#123;</div><div class="line">  render (createElement) &#123;</div><div class="line">    return createElement(&apos;div&apos;, [</div><div class="line">      ...this.$slots.default,</div><div class="line">      ...deepClone(this.$slots.default, createElement)</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>经测试，一切正常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Vue 1.0中重名的slots并不会出现什么问题，不知道为什么在2.0中取消了这个功能。我听说React提供了复制Element的标准函数，希望Vue也能提供这个函数，免得大家踩坑。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[手机上也可以愉快地搞nodejs开发]]></title>
      <url>https://jingsam.github.io/2017/02/07/nodejs-on-android.html</url>
      <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在微博上看到尤雨溪的这么一则微博：<br><img src="/assets/2017-02-07-1.png" alt=""></p>
<p>嗬！在手机上也能跑nodejs，有点儿意思哈。顺手查了查nodejs官网，发现nodejs是支持ARM处理器的，有了这个先决条件，手机上跑nodejs应该没什么大障碍了。本文就来分享一下我在手机上跑nodejs的一点经验。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你得有一部Android手机，iPhone的硬件条件有，但是由于IOS是一个封闭的系统，实际操作起来会很困难。</p>
<p>软件方面需要安装<a href="1">Termux</a>，这是Android平台下的一个开源的终端模拟器。</p>
<p>另外，我建议安装一个编程键盘<a href="2">Hacker’s Keyboard</a>，因为一般的输入法没有Ctrl、Alt、Tab、Esc这些常用控制键，到时候会很麻烦。安装Hacker’s Keyboard，设置为全键盘模式。</p>
<h2 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h2><p>首先得把nodejs安装到手机上。Termux强大的地方在于它带有一个包管理器<code>apt</code>，使用<code>apt</code>可以直接安装nodejs：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt update</div><div class="line">apt install nodejs</div></pre></td></tr></table></figure></p>
<p>这样node和npm都安装好了，node的版本是v6.9.4，版本还比较新。</p>
<p>搞开发嘛，做好把git和vim也安装上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install git vim</div></pre></td></tr></table></figure></p>
<p>有了npm之后，我们就可以随意安装需要的包了，这里以vue-cli为例，来跑一个vuejs工程。过程与在电脑上是一样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm i vue-cli -g</div><div class="line">vue init webpack vue-test</div><div class="line">cd vue-test</div><div class="line">npm i</div><div class="line">npm run dev</div></pre></td></tr></table></figure></p>
<p>浏览器打开localhost:8080，你就可以看到vuejs的欢迎页面了。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>由于Android权限管理的原因，你并不能随意地在任何位置写入文件。你的活动范围必须在Termux的权限之内，即<code>data/data/com.termux/files</code>目录下。虽然你可以写文件到SD卡，但是有些包symbolink的时候会失败，所以保险的做法是所有的操作都在HOME目录下进行，即<code>data/data/com.termux/files/home</code>目录。</p>
<p>在HOME目录下操作的坏处是，但你卸载Termux时，HOME下的所有文件也会删除。所以玩玩而已，不要当真，哈哈！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实话讲，在手机上不长不方便，我想有一下3点：</p>
<ol>
<li>屏幕太小。本来屏幕空间就有限，输入法还要占一半，估计可以通过投屏解决；</li>
<li>没有好的编辑器。本来就没人会在手机上搞正经开发嘛，所以不会有好的编辑器，还好Vim可以凑合着用；</li>
<li>输入不方便。这个也是最大的问题，手机键盘真的太不方便了，有点想念诺基亚N97了。</li>
</ol>
<p><img src="/assets/2017-02-07-2.jpg" alt=""></p>
<p>关于手机键盘，最好能携带方便，搜了下淘宝，下面两款似乎不错哦：<br><img src="/assets/2017-02-07-3.png" alt=""></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[利用travis-ci持续部署nodejs应用]]></title>
      <url>https://jingsam.github.io/2017/01/23/deploy-nodejs-with-travis-ci.html</url>
      <content type="html"><![CDATA[<p>Travis-ci是一款持续集成（Continuous Integration）服务，它能够很好地与Github结合，每当代码更新时自动地触发集成过程。</p>
<p>Travis-ci配置简单，很多nodejs项目都用它做自动测试。然而，对于持续集成，仅做到自动测试是不够的，还要有后续的自动部署，才能完成“提交代码 =&gt; 自动测试 =&gt; 自动部署”的集成链条。</p>
<p>本文以nodejs应用为例，来谈谈如何利用travis-ci完成自动部署。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>从自动测试到自动部署的核心问题是测试机与生产服务器的信任问题，即如何安全地把程序包传输到生产服务器。市面上的部署工具如scp、ansible、chef，都绕不开这个核心问题。</p>
<p>以scp为例，测试机登录生产服务器的方式有两种：密码和秘钥。密码登录方式需要交互式地输入密码，总不能每次测试的时候，人为地输入密码吧，所以密码方式行不通。</p>
<p>秘钥的方式可以实现自动登录，但首次将测试机的公钥传输给生产服务器仍然需要密码。似乎走入了死胡同，但办法总是有的。我们知道开发机是可以登录到生产服务器的，那么我们就可以<strong>将开发机的公钥复制到生产服务器，将开发机的私钥复制到测试机，测试机通过私钥来伪装成开发机，自动地登录到生产服务器</strong>。</p>
<p>解决了自动登录的问题，另一个问题是怎么将开发机的私钥复制到测试机上。由于测试机每次都是新开的一个虚拟机，这个新开的虚拟机IP不固定，所以没办法直接登录上去。解决办法是将私钥文件作为代码库的一部分提交，这样测试机每次从代码库上拉取代码的同时也获取到了秘钥文件，通过这种方式就实现了私钥从开发机复制到测试机。</p>
<p>将私钥文件提交到代码库有一个很严重的安全性问题，即任何人只要得到了这个私钥文件，他就可以随心所欲的操纵生产服务器。幸好，travis-ci提供了加密方案，它能够将私钥文件加密，加密后的文件只在当前代码库有效。</p>
<p>总的来说，通过复制私钥完成自动登录以及对私钥加密来保障安全性，我们就可以建立起测试机与生产服务器的信任通道，测试机就可以安全地操作生产服务器完成自动部署。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>现在我以scp方式部署nodejs应用为例，来说明travis-ci做自动部署的配置。</p>
<p>首先，建立起开发机与生产服务器的信任关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id username@host</div></pre></td></tr></table></figure></p>
<p>然后，加密你的私钥，私钥文件通常在<code>~/.ssh/id_rsa</code>。加密私钥文件需要使用travis这个命令行工具，它是一个ruby包，使用gem安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gem install travis</div><div class="line">travis login</div></pre></td></tr></table></figure></p>
<p>输入账号密码登录成功后，使用<code>travis encrypt-file</code>加密：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">travis encrypt-file ~/.ssh/id_rsa --add</div></pre></td></tr></table></figure></p>
<p>上面命令执行完后，会生成一段解密命令并添加到<code>.travis.yml</code>中：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">~/.ssh/id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div></pre></td></tr></table></figure></p>
<p>接下来，把加密后的私钥文件（id_rsa.enc）复制到代码库中，千万要注意不要错把未加密的私钥文件（id_rsa）复制到你的代码库中。然后把上面的解密命令的<code>-in ~/.ssh/id_rsa.enc</code>改为<code>-in id_rsa.enc</code>。</p>
<p>通过上面的过程就基本建立测试机与生产服务器的信任关系，但还有一些小细节要处理。例如，降低<code>id_rsa</code>文件的权限，否则ssh处于安全方面的原因会拒绝读取秘钥；将生产服务器地址加入到测试机的信任列表中，否则连接时会询问是否信任服务器。更改后的配置如下:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div><div class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line"><span class="bullet">  -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"Host 102.201.64.94\n\tStrictHostKeyChecking no\n"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></div></pre></td></tr></table></figure></p>
<p>最后，测试机就可以愉快地操作生产服务器了，例如下面是一个nodejs应用的<code>.travis.yml</code>文件配置：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="attr">language:</span> <span class="string">node_js</span></div><div class="line"><span class="attr">node_js:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">'4.4.4'</span></div><div class="line"><span class="attr">before_install:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_830d3b21a25d_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_830d3b21a25d_iv</span></div><div class="line"><span class="bullet">    -</span><span class="string">in</span> <span class="string">id_rsa.enc</span> <span class="bullet">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="bullet">-d</span></div><div class="line"><span class="bullet">  -</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></div><div class="line"><span class="bullet">  -</span> <span class="string">echo</span> <span class="bullet">-e</span> <span class="string">"Host 102.201.64.94\n\tStrictHostKeyChecking no\n"</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/config</span></div><div class="line"><span class="attr">script:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></div><div class="line"><span class="attr">after_success:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">npm</span> <span class="string">prune</span> <span class="bullet">--production</span>  <span class="comment"># 删除devDependencies</span></div><div class="line"><span class="bullet">  -</span> <span class="string">tar</span> <span class="bullet">-jcf</span> <span class="string">indoor-server.tar.bz2</span> <span class="string">*</span>    <span class="comment"># 打包并压缩代码</span></div><div class="line"><span class="bullet">  -</span> <span class="string">scp</span> <span class="string">indoor-server.tar.bz2</span> <span class="string">jingsam@102.201.64.94:~/</span>  <span class="comment"># 复制到生产服务器上</span></div><div class="line"><span class="bullet">  -</span> <span class="string">ssh</span> <span class="string">jingsam@102.201.64.94</span> <span class="string">'mkdir -p indoor-server &amp;&amp; tar -jxf indoor-server.tar.bz2 -C indoor-server'</span>   <span class="comment"># 解压</span></div><div class="line"><span class="bullet">  -</span> <span class="string">ssh</span> <span class="string">jingsam@102.201.64.94</span> <span class="string">'cd indoor-server &amp;&amp; pm2 startOrReload pm2.json'</span>  <span class="comment"># 重启pm2</span></div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章讲的自动部署其实与nodejs关系不大，完全适用于各种语言的自动部署，其原理都是相通的。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[使用node-pre-gyp加速二进制包安装]]></title>
      <url>https://jingsam.github.io/2017/01/12/node-pre-gyp-mirror.html</url>
      <content type="html"><![CDATA[<p>node-pre-gyp是一个分发nodejs二进制程序包的工具，负责将预编译好的二进制程序直接下载到用户目录。它介于npm与node-gyp之间，只在相应平台二进制包不存在时才调用node-gyp编译。</p>
<p>node-pre-gyp存在的意义是什么呢？一些简单的nodejs C++扩展直接从源代码编译安装问题不大，但复杂的扩展编译环境难搭建、编译耗时长，因而从源代码安装非常麻烦。node-pre-gyp能够将预编译好的二进制包直接下载到用户目录，只在必要的时候才调用node-gyp从源代码编译，大大加快了nodejs C++扩展的安装速度。</p>
<p>node-pre-gyp需要开发者将各平台编译好的二进制包上传到网络上，并在package.json的<code>binary</code>字段指明二进制包的位置。然而，很多开发者选择将二进制包上传到aws上，导致国内无法正常下载（被墙）。幸好，可以在npm中设置<code>--{module_name}_binary_host_mirror</code>选项来指定二进制包的位置。例如，安装v8-profiler可以使用如下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install v8-profiler --profiler_binary_host_mirror=https://npm.taobao.org/mirrors/node-inspector/</div></pre></td></tr></table></figure></p>
<p>为了让国内开发者也能享受到node-pre-gyp带来的好处，我使用阿里云做了一个镜像，镜像的地址是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://foxgis.oss-cn-shanghai.aliyuncs.com</div></pre></td></tr></table></figure></p>
<p>如果要安装sqlite3，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install sqlite3 --sqlite3_binary_host_mirror=https://foxgis.oss-cn-shanghai.aliyuncs.com</div></pre></td></tr></table></figure></p>
<p>目前是放到阿里云OSS上的，速度还可以，镜像上面包有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mapnik mapbox-gl-native sqlite3 fontnik gdal osrm zipfile</div></pre></td></tr></table></figure></p>
<p>如果有其他包需要放到上面的，请给我留言或者发邮件（abc#whu.edu.cn）。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[少年，不要滥用箭头函数啊]]></title>
      <url>https://jingsam.github.io/2016/12/08/things-you-should-know-about-arrow-functions.html</url>
      <content type="html"><![CDATA[<p>在ES6大行其道的今天，不应用点ES6特性似乎有些政治不正确。最近刚好有个Node的项目，最低要支持到nodejs 4.0，在<a href="1">node.green</a>看了下ES6的支持度，我想使用的特性基本都有支持，遂决定在新项目中采用ES6来写。</p>
<p>当然第一件事情就是毫不留情地消灭var，项目中能用const的地方不用let，能用let的地方不用var。</p>
<p>第二件事情就是使用劳动人民喜闻乐见的箭头函数替代function。当我心满意足地看到满屏的<code>=&gt;</code>时，现实给了我一记响亮的耳光——改过之后的程序错误百出！</p>
<p>所以，当我们使用箭头函数时，一定要搞清楚箭头函数是什么回事，适用于什么场景。本文就针对以上问题来讨论下箭头函数。</p>
<h2 id="箭头函数是什么？"><a href="#箭头函数是什么？" class="headerlink" title="箭头函数是什么？"></a>箭头函数是什么？</h2><p>箭头函数的语法我就不讲了，相信大家都见识过。跟我一样，大家喜欢箭头函数90%的原因是它好看。除了好看，它是不是与function等价呢？肯定不等价，因为TC39不可能仅因为好看而引入一个语法糖（class除外）。</p>
<p>箭头函数的渊源可以追溯到上古时期一个叫lambda演算的东西。lambda演算是数学家提出来的，有些数学家跟我们程序员一样也很懒，数学定理那么多，今天要证三角定律，明天要证勾股定律，累不累！那能不能将所有的证明问题用一个统一的体系进行形式化描述，然后由机器来完成自动推导呢？lambda演算就是干这个的，图灵也搞了一套体系叫图灵机，两者是等价的。</p>
<p>关于lambda演算说了这么多，好像跟今天要讲的箭头函数没什么关系？其实是有关系的，lambda演算深刻影响了箭头函数的设计。数学家们喜欢用纯函数式编程语言，纯函数的特点是没有副作用，给予特定的输入，总是产生确定的输出，甚至有些情况下通过输出能够反推输入。要实现纯函数，必须使函数的执行过程不依赖于任何外部状态，整个函数就像一个数学公式，给定一套输入参数，不管是在地球上还是火星上执行都是同一个结果。</p>
<p>箭头函数要实现类似纯函数的效果，必须剔除外部状态。所以当你定义一个箭头函数，在普通函数里常见的<code>this</code>、<code>arguments</code>、<code>caller</code>是统统没有的。</p>
<h2 id="箭头函数没有this"><a href="#箭头函数没有this" class="headerlink" title="箭头函数没有this"></a>箭头函数没有<code>this</code></h2><p>箭头函数没有<code>this</code>，那下面的代码明显可以取到<code>this</code>啊：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></div><div class="line">  <span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</div><div class="line"></div><div class="line">  b()</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>以上箭头函数中的<code>this</code>其实是父级作用域中的<code>this</code>，即函数<code>foo</code>的<code>this</code>。箭头函数引用了父级的变量，构成了一个闭包。以上代码等价于：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.a = <span class="number">1</span></div><div class="line"></div><div class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></div><div class="line">  <span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(self.a)</div><div class="line"></div><div class="line">  b()</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>箭头函数不仅没有<code>this</code>，常用的<code>arguments</code>也没有。如果你能获取到<code>arguments</code>，那它一定是来自父作用域的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>])</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>)  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>上例中如果箭头函数有<code>arguments</code>，就应该输出的是3而不是1。</p>
<p>一个经常犯的错误是使用箭头函数定义对象的方法，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  foo: <span class="number">1</span>,</div><div class="line">  bar: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>以上代码中，箭头函数中的<code>this</code>并不是指向<code>a</code>这个对象。对象<code>a</code>并不能构成一个作用域，所以再往上到达全局作用域，<code>this</code>就指向全局作用域。如果我们使用普通函数的定义方法，输出结果就符合预期，这是因为<code>a.bar()</code>函数执行时作用域绑定到了<code>a</code>对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = &#123;</div><div class="line">  foo: <span class="number">1</span>,</div><div class="line">  bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo) &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.bar()  <span class="comment">// 1</span></div></pre></td></tr></table></figure></p>
<p>另一个错误是在原型上使用箭头函数，如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.foo = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">A.prototype.bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo)</div><div class="line"></div><div class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</div><div class="line">a.bar()  <span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>同样，箭头函数中的<code>this</code>不是指向<code>A</code>，而是根据变量查找规则回溯到了全局作用域。同样，使用普通函数就不存在问题。</p>
<p>通过以上说明，我们可以看出，箭头函数除了传入的参数之外，真的是什么都没有！如果你在箭头函数引用了<code>this</code>、<code>arguments</code>或者参数之外的变量，那它们一定不是箭头函数本身包含的，而是从父级作用域继承的。</p>
<h2 id="什么情况下该使用箭头函数"><a href="#什么情况下该使用箭头函数" class="headerlink" title="什么情况下该使用箭头函数"></a>什么情况下该使用箭头函数</h2><p>到这里，我们可以发现箭头函数并不是万金油，稍不留神就会踩坑。</p>
<p>至于什么情况该使用箭头函数，《You Don’t Know About JS》给出了一个决策图：<br><img src="/assets/arrow-function.png" alt="arrow function"></p>
<p>以上决策图看起来有点复杂，我认为有三点比较重要：</p>
<ol>
<li>箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在<code>map</code>、<code>reduce</code>、<code>filter</code>的回调函数定义中；</li>
<li>不要在最外层定义箭头函数，因为在函数内部操作<code>this</code>会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将<code>this</code>控制在可见的范围内；</li>
<li>如开头所述，箭头函数最吸引人的地方是简洁。在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[打包 Vue 组件库的正确姿势]]></title>
      <url>https://jingsam.github.io/2016/11/18/bundle-vue-components.html</url>
      <content type="html"><![CDATA[<p>为了方便其他开发者使用组件库，开发的 Vue 组件库在发布之前需要对其打包。本文基于 Webpack 讨论打包 Vue 组件库的正确方法。</p>
<h2 id="选择正确的打包格式"><a href="#选择正确的打包格式" class="headerlink" title="选择正确的打包格式"></a>选择正确的打包格式</h2><p>首先，我们必须明确组件库的使用场景。有些场景是直接使用 <code>&lt;script&gt;</code> 在 HTML 中引入，有些场景是使用打包工具在后台构建。作为组件库，应该兼容这些使用场景。组件库应该保持中立，不应该限定于某种使用方式或者打包工具。例如，虽然 Webpack 很流行，组件库不能声明只支持 Webpack 方式使用，忽略了其他选择。原因在于，打包工具并不只有 webpack，还有 browserify、rollup 等。另外，前端工具发展很快，今年流行的工具明年可能就没人用了，你肯定不希望你的组件库会随着某个工具不流行而消逝吧。回顾下曾经流行的 grunt、glup，一大堆基于它们的插件随着工具本身的不流行而被扔进了垃圾箱。</p>
<p>为了支持多种使用场景，我们需要选择合适的打包格式。常见的打包格式有 CMD、AMD、UMD，CMD只能在 Node 环境执行，AMD 只能在浏览器端执行，UMD 同时支持两种执行环境。显而易见，我们应该选择 UMD 格式。Webpack 中指定输出格式的设置项为 <code>output.libraryTarget</code>，其支持的格式有：</p>
<ul>
<li>“var” - 以一个变量形式输出： var Library = xxx (default)；</li>
<li>“this” - 以 this 的一个属性输出： this[“Library”] = xxx；</li>
<li>“commonjs” - 以 exports 的一个属性输出：exports[“Library”] = xxx；</li>
<li>“commonjs2” - 以 module.exports 形式输出：module.exports = xxx；</li>
<li>“amd” - 以 AMD 格式输出；</li>
<li>“umd” - 同时以 AMD、CommonJS2 和全局属性形式输出。</li>
</ul>
<p>以下是 <code>webpack.config.js</code> 中 <code>output</code> 设置的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">    publicPath: <span class="string">'/dist/'</span>,</div><div class="line">    filename: <span class="string">'iview.js'</span>,</div><div class="line">    library: <span class="string">'iview'</span>,       <span class="comment">// 模块名称</span></div><div class="line">    libraryTarget: <span class="string">'umd'</span>,   <span class="comment">// 输出格式</span></div><div class="line">    umdNamedDefine: <span class="literal">true</span>    <span class="comment">// 是否将模块名称作为 AMD 输出的命名空间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此，我们解决了组件库输出的问题。</p>
<h2 id="如何打包组件依赖"><a href="#如何打包组件依赖" class="headerlink" title="如何打包组件依赖"></a>如何打包组件依赖</h2><p>在<a href="/2016/11/01/peerDependencies-in-Vue-components.html">前一篇</a>文章中我们讨论了组件库实质上是 Vue 的插件，Vue 应该是组件库的外部依赖。组件库的使用者会自行导入 Vue，打包的时候，不应该将 Vue 打包进组件库。</p>
<p>在 webpack 中，我们可以将 Vue 设置为 <code>externals</code>，以避免将 Vue 打包进组件库，相应的设置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">externals: &#123;</div><div class="line">    vue: <span class="string">'vue'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>啊哈，我们搞定了组件依赖问题。至此，读者可能很皱起眉头开始埋怨我了：这么简单的问题，查下 webpack 文档不就得了，还用得着我啰里啰嗦地写这么多！</p>
<p>事实上，问题往往没有我们想得那么简单！如果你将打包后的组件库以 <code>&lt;script&gt;</code> 标签形式直接引入，你会发现并不能正常执行，提示 vue 未定义。</p>
<p>为了分析问题，我们将打包的代码前几行拿出来看看：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">webpackUniversalModuleDefinition</span>(<span class="params">root, factory</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">'object'</span>)</div><div class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">"vue"</span>));</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd)</div><div class="line">        define(<span class="string">"iview"</span>, [<span class="string">"vue"</span>], factory);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> exports === <span class="string">'object'</span>)</div><div class="line">        exports[<span class="string">"iview"</span>] = factory(<span class="built_in">require</span>(<span class="string">"vue"</span>));</div><div class="line">    <span class="keyword">else</span></div><div class="line">        root[<span class="string">"iview"</span>] = factory(root[<span class="string">"vue"</span>]);</div><div class="line">&#125;)(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">__WEBPACK_EXTERNAL_MODULE_157__</span>) </span>&#123;</div><div class="line">    <span class="comment">// ....</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>我们可以看见，打包后的代码以 4 种形式声明了 Vue 依赖：</p>
<ol>
<li><code>module.exports = factory(require(&quot;vue&quot;))</code> - commonjs2 形式；</li>
<li><code>define(&quot;iview&quot;, [&quot;vue&quot;], factory)</code> - AMD 形式；</li>
<li><code>exports[&quot;iview&quot;] = factory(require(&quot;vue&quot;))</code> - commonjs 形式；</li>
<li><code>root[&quot;iview&quot;] = factory(root[&quot;vue&quot;])</code> - 全局变量形式。</li>
</ol>
<p>以 <code>&lt;script&gt;</code> 标签形式使用组件时，会同样使用 <code>&lt;script&gt;</code> 标签导入 Vue。Vue 导入的变量是 “window.Vue” 而不是 “window.vue”，因此会出现 vue 未定义的错误。</p>
<p>幸好，webpack 可以为各种导入形式设置不同名称，设置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">externals: &#123;</div><div class="line">    vue: &#123;</div><div class="line">        root: <span class="string">'Vue'</span>,</div><div class="line">        commonjs: <span class="string">'vue'</span>,</div><div class="line">        commonjs2: <span class="string">'vue'</span>,</div><div class="line">        amd: <span class="string">'vue'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次打包，你可以发现打包的组件库不管是 <code>&lt;script&gt;</code> 标签方式还是后端构建，都可以正常工作了。</p>
<p>最后，帖一个打包 iView 组件库的 webpack 配置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    entry: &#123;</div><div class="line">        main: <span class="string">'./src/index.js'</span></div><div class="line">    &#125;,</div><div class="line">    output: &#123;</div><div class="line">        path: path.resolve(__dirname, <span class="string">'../dist'</span>),</div><div class="line">        publicPath: <span class="string">'/dist/'</span>,</div><div class="line">        filename: <span class="string">'iview.js'</span>,</div><div class="line">        library: <span class="string">'iview'</span>,</div><div class="line">        libraryTarget: <span class="string">'umd'</span>,</div><div class="line">        umdNamedDefine: <span class="literal">true</span></div><div class="line">    &#125;,</div><div class="line">    externals: &#123;</div><div class="line">        vue: &#123;</div><div class="line">            root: <span class="string">'Vue'</span>,</div><div class="line">            commonjs: <span class="string">'vue'</span>,</div><div class="line">            commonjs2: <span class="string">'vue'</span>,</div><div class="line">            amd: <span class="string">'vue'</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    resolve: &#123;</div><div class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>]</div><div class="line">    &#125;,</div><div class="line">    <span class="built_in">module</span>: &#123;</div><div class="line">        loaders: [&#123;</div><div class="line">            test: <span class="regexp">/\.vue$/</span>,</div><div class="line">            loader: <span class="string">'vue'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.js$/</span>,</div><div class="line">            loader: <span class="string">'babel'</span>,</div><div class="line">            exclude: <span class="regexp">/node_modules/</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.css$/</span>,</div><div class="line">            loader: <span class="string">'style!css!autoprefixer'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.less$/</span>,</div><div class="line">            loader: <span class="string">'style!css!less'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.(gif|jpg|png|woff|svg|eot|ttf)\??.*$/</span>,</div><div class="line">            loader: <span class="string">'url?limit=8192'</span></div><div class="line">        &#125;, &#123;</div><div class="line">            test: <span class="regexp">/\.(html|tpl)$/</span>,</div><div class="line">            loader: <span class="string">'vue-html'</span></div><div class="line">        &#125;]</div><div class="line">    &#125;,</div><div class="line">    plugins: [</div><div class="line">        <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">            <span class="string">'process.env'</span>: &#123;</div><div class="line">                NODE_ENV: <span class="string">'"development"'</span></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[开发组件库时 Vue 应该放哪儿：devDependencies or peerDependencies？]]></title>
      <url>https://jingsam.github.io/2016/11/01/peerDependencies-in-Vue-components.html</url>
      <content type="html"><![CDATA[<p>最近在和 Aresn 开发 iView 组件库的时候，关于依赖包 Vue 到底是放在 devDependencies 还是 peerDependencies 有些争论。本着打破砂锅问到底的精神，这篇文章讨论下 package.json 里面的各种 depedencies 字段到底是干嘛的。</p>
<p>npm 的 package.json 包括 5 种 dependencies：</p>
<ol>
<li><code>dependencies</code>：应用能够正常运行所依赖的包。这种 dependencies 是最常见的，用户在使用 <code>npm install</code> 安装你的包时会自动安装这些依赖。</li>
<li><code>devDependencies</code>：开发应用时所依赖的工具包。通常是一些开发、测试、打包工具，例如 webpack、ESLint、Mocha。应用正常运行并不依赖于这些包，用户在使用 <code>npm install</code> 安装你的包时也不会安装这些依赖。</li>
<li><code>peerDependencies</code>：应用运行依赖的宿主包。最典型的就是插件，例如各种 jQuery 插件，这些插件本身不包含 jQeury，需要外部提供。用户使用 npm 1 或 2 时会自动安装这种依赖，npm 3 不会自动安装，会提示用户安装。</li>
<li><code>bundledDependencies</code>：发布包时需要打包的依赖，似乎很少见。</li>
<li><code>optionalDependencies</code>：可选的依赖包。此种依赖不是程序运行所必须的，但是安装后可能会有新功能，例如一个图片解码库，安装了 <code>optionalDependencies</code> 后会支持更多的格式。</li>
</ol>
<p>从以上的定义可以看出，<code>dependencies</code> 是程序运行依赖，<code>devDependencies</code> 一般是一些开发工具，<code>peerDependencies</code> 一般用于插件。</p>
<p>下表是我在 awesome-vue 中找到的 28 个 Vue 组件库，统计了 Vue 在这些库中的位置。其中，11 个库选择放到 <code>dependencies</code>，10 个库选择放到 <code>devDependencies</code>，4 个库选择放到 <code>peerDependencies</code>，2 个库选择不放 Vue 依赖，最后还有 1 个库选择在 <code>devDependencies</code> 和 <code>peerDependencies</code> 同时加上 Vue 依赖。</p>
<table>
<thead>
<tr>
<th>UI</th>
<th>dependencies</th>
<th>devDependencies</th>
<th>peerDependencies</th>
<th>none</th>
</tr>
</thead>
<tbody>
<tr>
<td>vue-strap</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>gritcode-components</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Keen-UI</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>material-ui-vue</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-admin</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-carbon</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-impression</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vuikit</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-material</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-kit</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-material-design</td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>vuestrap-base-components</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vux</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-materialize</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>mint-ui</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>N3-components</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-desktop</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-beauty</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>radon-ui</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>vue-antd</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>bootstrap-vue</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
</tr>
<tr>
<td>iview</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>wovue</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>vue-bulma</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>quasar</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
</tr>
<tr>
<td>vueboot</td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>material-components</td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr>
<td>element</td>
<td></td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>
<p>下面分析下各种选择的优劣：</p>
<ul>
<li><code>dependencies</code>：放到 <code>dependencies</code> 的好处是安装组件库的时候 Vue 会自动安装。问题是已有的工程项目中往往已经安装了 Vue，会导致在 npm 1 或 2 中重复安装 Vue。虽然此问题在 npm 3 中可以规避，但是如果已安装的 Vue 版本与组件库所依赖的版本不兼容时，Vue 仍然会重复安装。</li>
<li><code>devDependencies</code>：由于组件库单元测试时会用到 Vue，所以严格来说 Vue 是属于开发工具包，放到 <code>devDependencies</code> 合情合理。但是，在 <code>devDependencies</code> 中的 Vue 依赖不会自动安装，所以需要用户去查文档来确定到底应该安装哪个版本的 Vue，对用户似乎不太友好。</li>
<li><code>peerDevDependencies</code>：Vue 组件库本质上是 Vue 的插件，依赖于外部提供的 Vue。把 Vue 放到这里，npm 能够提示用户需要安装哪个版本的 Vue，这点比 <code>devDependencies</code>  友好。问题在于，从 npm 3 开始，<code>peerDevDependencies</code> 中的依赖不会自动安装，会导致自动集成测试失败。</li>
<li>不添加依赖：这基本上是最差的选择了，用户甚至不能知道组件库到底依赖哪个版本的 Vue，只能靠猜。</li>
<li><code>devDependencies</code>、<code>peerDevDependencies</code> 同时添加：这是我和 Element UI 的开发者讨论后最优的做法。<code>peerDevDependencies</code> 中的 Vue 是组件库运行所依赖的 Vue 的最低版本，而 <code>devDependencies</code> 运行测试时需要的 Vue 版本，一般情况下 <code>devDependencies &gt;= peerDevDependencies</code>。这种做法保证了 npm 1、2、3 都不会出问题，并且当用户安装组件库时给予友好的提示信息。</li>
</ul>
<p>到这里，我们可以得出以下结论：<strong>在开发 Vue 组件库是，应当同时在 <code>devDependencies</code> 和 <code>peerDevDependencies</code> 添加 Vue 依赖。</strong></p>
<p>最后，可能有人会说：哥们，何必较真呢，能用不就行了吗？我的观点是，如果大家都按照规范来，会减少很多不必要的麻烦。想想看，如果大家在 npm 上发布包的时候不遵守 semver 规范，你还有信心说，你的程序只要 npm install 就能正常运行么？</p>
<p>按老罗的话说，我不是为了输赢，我就是认真！</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[聊聊 Vue 组件命名那些事]]></title>
      <url>https://jingsam.github.io/2016/10/30/vue-components-naming.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>There are only two things in Computer Sciences: cache invalidation and naming things.<br>—— Phil Karlton</p>
</blockquote>
<p>诚如上述所言，编程中变量命名确实令人很头疼。我们模糊地知道，Vue 组件的名称最好不要和原生 HTML 标签相同。为了避免重名，通常会在组件名称前面加上一个前缀，如 <code>el-button</code>、<code>el-input</code>、<code>el-date-picker</code>。这通常不会有什么问题，但有时候你的模板中混杂了原生 HTML 标签和组件标签，要想区分它们并不是很容易。</p>
<p>当我看到 Ant.design 的 React 组件是下面这样的时候，我感觉到一种自由的味道。首先，组件名可以使用原生 HTML 标签名，意味着再也不用较劲脑汁去规避原生 HTML 标签了。另外，这些组件都使用了首字母大写标签名，使它们很容易地与原生小写的 HTML 标签区分。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;Button type=<span class="string">"primary"</span>&gt;Primary&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">    &lt;Input placeholder="Basic usage" /</span>&gt;</div><div class="line">    &lt;Select defaultValue=<span class="string">".com"</span> style=&#123;&#123; <span class="attr">width</span>: <span class="number">70</span> &#125;&#125;&gt;</div><div class="line">      &lt;Option value=<span class="string">".com"</span>&gt;.com&lt;<span class="regexp">/Option&gt;</span></div><div class="line"><span class="regexp">      &lt;Option value=".jp"&gt;.jp&lt;/</span>Option&gt;</div><div class="line">      &lt;Option value=<span class="string">".cn"</span>&gt;.cn&lt;<span class="regexp">/Option&gt;</span></div><div class="line"><span class="regexp">      &lt;Option value=".org"&gt;.org&lt;/</span>Option&gt;</div><div class="line">    &lt;<span class="regexp">/Select&gt;</span></div><div class="line"><span class="regexp">  &lt;/</span>div&gt;,</div><div class="line">  mountNode</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>受 Ant.design 的启发，我思考 Vue 组件命名能不能达到同样的效果呢？要找到答案，必须摸清楚 Vue 组件命名到底有什么限制。下面将分别从 Vue 1.0 和 Vue 2.0 来谈谈组件命名的机制：</p>
<h2 id="Vue-1-0-组件命名机制"><a href="#Vue-1-0-组件命名机制" class="headerlink" title="Vue 1.0 组件命名机制"></a>Vue 1.0 组件命名机制</h2><h3 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h3><p>我们以一个最简单的例子来研究 Vue 组件的注册过程：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>通过跟踪代码的执行过程，发现对组件的名称有两处检查。</p>
<ol>
<li><p>检查名称是否与 HTML 元素或者 Vue 保留标签重名，不区分大小写。可以发现，只检查了常用的 HTML 元素，还有很多元素没有检查，例如 <code>button</code>、<code>main</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (type === <span class="string">'component'</span> &amp;&amp; (commonTagRE.test(id) || reservedTagRE.test(id))) &#123;</div><div class="line">  warn(<span class="string">'Do not use built-in or reserved HTML elements as component '</span> + <span class="string">'id: '</span> + id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;</span></div><div class="line"><span class="comment">// var reservedTagRE = /^(slot|partial|component)$/i;</span></div></pre></td></tr></table></figure>
</li>
<li><p>检查组件名称是否以字母开头，后面跟字母、数值或下划线。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!<span class="regexp">/^[a-zA-Z][\w-]*$/</span>.test(name)) &#123;</div><div class="line">  warn(<span class="string">'Invalid component name: "'</span> + name + <span class="string">'". Component names '</span> + <span class="string">'can only contain alphanumeric characaters and the hyphen.'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>基于以上两点，可以总结出组件的命名规则为：组件名以字母开头，后面跟字母、数值或下划线，并且不与 HTML 元素或 Vue 保留标签重名。</p>
<p>然而我们注意到，在上面的检查中，不符合规则的组件名称是 warn 而不是 error，意味着检查并不是强制的。实际上，<strong>Vue 组件注册的名称是没有限制的</strong>。你可以用任何 JavaScript 能够表示的字符串，不管是数字、特殊符号、甚至汉字，都可以成功注册。</p>
<h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><p>虽然 Vue 组件没有命名限制，但是我们终究是要在模板中引用的，不合理的组件名可能会导致我们无法引用它。</p>
<p>为了弄清楚 Vue 是如何将模板中的标签对应到自定义组件的，我们以一段简单的代码说明：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;my-component&gt;&lt;/my-component&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>总体来说，模板解析分为两个过程：</p>
<p>首先，Vue 会将 <code>template</code> 中的内容插到 DOM 中，以方便解析标签。由于 HTML 标签不区分大小写，所以在生成的标签名都会转换为小写。例如，当你的 <code>template</code> 为 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 时，插入 DOM 后会被转换为 <code>&lt;mycomponent&gt;&lt;/mycomponent&gt;</code>。</p>
<p>然后，通过标签名寻找对应的自定义组件。<strong>匹配的优先顺序从高到低为：原标签名、camelCase化的标签名、PascalCase化的标签名。</strong>例如 <code>&lt;my-component&gt;</code> 会依次匹配 my-component、myComponent、MyComponent。camelCase 和 PascalCase 的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> camelizeRE = <span class="regexp">/-(\w)/g</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">camelize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> str.replace(camelizeRE, toUpper);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUpper</span>(<span class="params">_, c</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> c ? c.toUpperCase() : <span class="string">''</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pascalize</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> camelCase = camelize(str);</div><div class="line">  <span class="keyword">return</span> camelCase.charAt(<span class="number">0</span>).toUpperCase() + camelCase.slice(<span class="number">1</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于一个 Vue 新手，经常对以下示例代码不能正常运行感到非常疑惑：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;MyComponent&gt;&lt;/MyComponent&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>如果我们按照模板解析的过程推理，就很好解释了。模板 <code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 插入到 DOM 后会变成 <code>&lt;mycomponent&gt;&lt;/mycomponent&gt;</code>。标签 mycomponent 匹配的组件依次为 mycomponent（原标签名）、mycomponent（camelCase形式）、Mycomponent（PascalCase形式），并没有匹配到注册的组件名 MyComponent，所以会报找不到组件 <mycomponent> 的警告。</mycomponent></p>
<h3 id="命名限制"><a href="#命名限制" class="headerlink" title="命名限制"></a>命名限制</h3><p>通过分析组件注册和模板解析的过程，发现 Vue 组件命名限制并没有我们想象得多。大家可以尝试一下各种命名，我试过 <code>&lt;a_=-*%按钮&gt;&lt;/a_=-*%按钮&gt;</code> 都可正常运行。</p>
<p>但是，并不意味着完全没有限制。由于在模板需要插入到 DOM 中，所以模板中的标签名必须能够被 DOM 正确地解析。主要有三种情况：一是完全不合法的标签名，例如 &lt;/&gt;；二是与 HTML 元素重名会产生不确定的行为，例如使用 input 做组件名不会解析到自定义组件，使用 button 在 Chrome 上正常但在 IE 上不正常；三是与 Vue 保留的 slot、partial、component 重名，因为会优先以本身的意义解析，从而产生非预期的结果。</p>
<p>上述命名限制存在的根本原因，在于模板解析的过程依赖了 DOM。能不能对模板解析过程改进一下，使其不依赖于 DOM 呢？实际上，这正是 Vue 2.0 的主要改进，将模板解析过程使用 Virtual DOM 实现，使得组件命名更加灵活。</p>
<h2 id="Vue-2-0-组件命名机制"><a href="#Vue-2-0-组件命名机制" class="headerlink" title="Vue 2.0 组件命名机制"></a>Vue 2.0 组件命名机制</h2><h3 id="组件注册-1"><a href="#组件注册-1" class="headerlink" title="组件注册"></a>组件注册</h3><p>Vue 2.0 的组件注册过程与 Vue 1.0 基本相同，只是 HTML 标签和 Vue 保留标签范围有些不同：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 区分大小写</span></div><div class="line"><span class="keyword">var</span> isHTMLTag = makeMap(</div><div class="line">  <span class="string">'html,body,base,head,link,meta,style,title,'</span> +</div><div class="line">  <span class="string">'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,'</span> +</div><div class="line">  <span class="string">'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,'</span> +</div><div class="line">  <span class="string">'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,'</span> +</div><div class="line">  <span class="string">'s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,'</span> +</div><div class="line">  <span class="string">'embed,object,param,source,canvas,script,noscript,del,ins,'</span> +</div><div class="line">  <span class="string">'caption,col,colgroup,table,thead,tbody,td,th,tr,'</span> +</div><div class="line">  <span class="string">'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,'</span> +</div><div class="line">  <span class="string">'output,progress,select,textarea,'</span> +</div><div class="line">  <span class="string">'details,dialog,menu,menuitem,summary,'</span> +</div><div class="line">  <span class="string">'content,element,shadow,template'</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// 不区分大小写</span></div><div class="line"><span class="keyword">var</span> isSVG = makeMap(</div><div class="line">  <span class="string">'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,'</span> +</div><div class="line">  <span class="string">'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,'</span> +</div><div class="line">  <span class="string">'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view'</span>,</div><div class="line">  <span class="literal">true</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> isReservedTag = <span class="function"><span class="keyword">function</span> (<span class="params">tag</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> isHTMLTag(tag) || isSVG(tag)</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 区分大小写</span></div><div class="line"><span class="keyword">var</span> isBuiltInTag = makeMap(<span class="string">'slot,component'</span>, <span class="literal">true</span>);</div></pre></td></tr></table></figure></p>
<p>虽然 HTML 元素重名警告的标签数大大增加了，但重要的是重名区分大小写，所以我们可以愉快地使用 Input、Select、Option 等而不用担心重名。这个功劳属于 Vue 2.0 引入的 Virtual DOM。</p>
<h3 id="模板解析-1"><a href="#模板解析-1" class="headerlink" title="模板解析"></a>模板解析</h3><p>前面提到，Vue 2.0 相对于 1.0 的最大改进就是引入了 Virtual DOM，使模板的解析不依赖于 DOM。</p>
<p>使用 Virtual DOM 解析模板时，不必像 DOM 方式那样将模板中的标签名转成小写，而是原汁原味地保留原始标签名。然后，使用原始的标签名进行匹配组件。例如，<code>&lt;MyComponent&gt;&lt;/MyComponent&gt;</code> 不会转为为小写形式，直接以 MyComponent 为基础开始匹配。当然，匹配的规则与 1.0 是一样的，即依次匹配：原标签名、camelCase化的标签名、PascalCase化的标签名。</p>
<p>之前在 1.0 不能正常运行的示例代码，在 2.0 中可以正常运行了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Vue.component(<span class="string">'MyComponent'</span>, &#123;</div><div class="line">  template: <span class="string">'&lt;div&gt;hello, world&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  el: <span class="string">'#app'</span>,</div><div class="line">  template: <span class="string">'&lt;MyComponent&gt;&lt;/MyComponent&gt;'</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在 Vue 1.0 和 2.0 中还有一种定义组件模板的方式，即使用 DOM 元素。在这种情况下，解析模板时仍然会将标签转为小写形式。所以下面的代码，在 1.0 和 2.0 均不能正常运行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.html</span></div><div class="line">&lt;div id=<span class="string">"app"</span>&gt;</div><div class="line">  &lt;MyComponent&gt;<span class="xml"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">/</span><span class="regexp">/ main.js</span></div><div class="line"><span class="regexp">Vue.component('MyComponent', &#123;</span></div><div class="line"><span class="regexp">  template: '&lt;div&gt;hello, world&lt;/</span>div&gt;<span class="string">'</span></div><div class="line"><span class="string">&#125;)</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">new Vue(&#123;</span></div><div class="line">  el: '#app'</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="命名限制-1"><a href="#命名限制-1" class="headerlink" title="命名限制"></a>命名限制</h3><p>Vue 2.0 中组件的命名限制与 1.0 的最大区别在于区分了大小写。总结一下就是：一是不使用非法的标签字符；二是不与 HTML 元素（区分大小写）或 SVG 元素（不区分大小写）重名；三是不使用 Vue 保留的 slot 和 component（区分大小写）。</p>
<p>除了以上三条，由于 Vue 2.0 内置了 KeepAlive、Transition、TransitionGroup 三个组件，所以尽量避免与这三个组件重名。但从另一方面讲，你也可以故意重名来实现一些特殊的功能。例如，keep-alive 的匹配顺序为 keep-alive、keepAlive、KeepAlive，所以我们可以注册一个 keep-alive 组件来拦截 KeepAlive 匹配。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我们可以知道 Vue 2.0 完全可以像 React 那样使用 PascalCase 形式的组件标签。对于 Vue 1.0，想以 PascalCase 形态写模板，尽量以全小写或者仅首字母大写形式注册组件，例如 <code>&lt;InputNumber&gt;</code> 组件，可以注册为 inputnumber 或者 Inputnumber。但是，如果你想在 1.0 中使用 Input、Select 这类与 HTML 元素重名的标签名，基本上是无解的，所以是时候尝试下 Vue 2.0 了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue.js 2.0 独立构建和运行时构建的区别]]></title>
      <url>https://jingsam.github.io/2016/10/23/standalone-vs-runtime-only-build-in-vuejs2.html</url>
      <content type="html"><![CDATA[<p>在使用 Vue.js 2.0 时，有独立构建（standalone）和运行时构建（runtime-only）两种版本可供选择。而在 Vue.js 1.0 中，却没有这种版本区别。到底该使用哪一个版本？这让我有点懵逼的感觉。本着知其然还要知其所以然的精神，我决定好好研究下两者间的区别。</p>
<p>Vue.js 的官方教程上是这么说的：</p>
<blockquote>
<ul>
<li>独立构建包括编译和支持 template 选项。 它也依赖于浏览器的接口的存在，所以你不能使用它来为服务器端渲染。</li>
<li>运行时构建不包括模板编译，不支持 template 选项。运行时构建，可以用 render 选项，但它只在单文件组件中起作用，因为单文件组件的模板是在构建时预编译到 render 函数中，运行时构建只有独立构建大小的 30%，只有 16Kb min+gzip 大小。</li>
</ul>
</blockquote>
<p>看了半天，实在没搞清两者之间的区别。经过一番搜索，终于搞清楚了问题的本源，且听我娓娓道来。</p>
<p>Vue.js 的运行过程实际上包含两步。第一步，编译器将字符串模板（template）编译为渲染函数（render），称之为编译过程；第二步，运行时实际调用编译的渲染函数，称之为运行过程。</p>
<p>由于 Vue.js 1.0 的编译过程需要依赖浏览器的 DOM，所以无法（或者说没有意义）将编译器和运行时分开。因此在 Vue.js 1.0 分发包中，编译器和运行时是打包在一起，都在浏览器端执行。</p>
<p>然而到了 Vue.js 2.0，为了支持服务端渲染（server-side rendering），编译器不能依赖于 DOM，所以必须将编译器和运行时分开。这就形成了独立构建（编译器 + 运行时）和运行时构建（仅运行时）。显而易见，运行时构建要小于独立构建。</p>
<p>在现代前端工程构建中，通常会使用 vue-loader 和 vueify 预编译模板。在这种情况下，只需要打包运行时，而不需要打包编译器，运行时构建即可满足所需。当然，如果你需要在前端使用 <code>template</code> 选项实时编译模板，那么还是需要使用独立构建将编译器发送到浏览器。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[《Mapbox 地图样式规范》中文版上线啦]]></title>
      <url>https://jingsam.github.io/2016/10/19/mapbox-gl-style-spec.html</url>
      <content type="html"><![CDATA[<p>最近逮空翻译了下《Mapbox 地图样式规范》，对于英文不好或者懒得看英文的朋友们可能会有用。</p>
<p>页面托管到了 <a href="https://jingsam.github.io/mapbox-gl-style-spec">Github</a> 上，现在也正在和 Mapbox 沟通，看能不能发布到 <a href="http://www.mapbox.cn/" target="_blank" rel="external">mapbox.cn</a> 上，服务下广大中国 Mapboxer。</p>
<p>当然，如果有什么翻译不到位或者错误的地方，欢迎给我发 <a href="https://github.com/jingsam/mapbox-gl-style-spec/issues" target="_blank" rel="external">issue</a>。</p>
<p><img src="/assets/mapbox-gl-style-spec.png" alt=""></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[多边形centroid的计算方法]]></title>
      <url>https://jingsam.github.io/2016/10/05/centroid.html</url>
      <content type="html"><![CDATA[<p>在<a href="/2016/09/26/polylabel2.html">上一篇</a>计算多边形的最佳注记点的算法中，需要计算多边形的centroid。本文就来讲一讲多边形centroid的计算方法。</p>
<h2 id="Centroid的定义"><a href="#Centroid的定义" class="headerlink" title="Centroid的定义"></a>Centroid的定义</h2><p><a href="https://en.wikipedia.org/wiki/Centroid" target="_blank" rel="external">Centroid</a>是多边形的质量中心（Center of mass）。假设多边形是一块厚度均匀的薄板，当我们用一根绳子从一个平衡点吊起薄板时，薄板能够保持水平稳定，那么这个平衡点就是centroid。</p>
<p><img src="/assets/tilt-slab-construction.jpg" alt="tilt-slab-construction"></p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>我们先从1维直线说起，如下图，在原点的一端不同位置上分别挂着重10kg、5kg、7kg的砝码。如果我们将三个砝码当成一个整体，挂在同一个位置，使其产生的杠杆效应与之前相同，那么这个位置点就相当于质心。</p>
<p><img src="/assets/Image1203.gif" alt="Center of mass"></p>
<p>计算方法如下：</p>
<p>总惯性 = 10 × 2 + 5 × 4 + 7 × 5 = 75 kg.m<br>总质量 = 10 + 5 + 7 = 22 kg<br>假设质心距离原点为d，那么 22 x d = 75，得出 d = 75 / 22 ≈ 3.4 m</p>
<p><img src="/assets/Image1207.gif" alt="Center of mass 2"></p>
<p>上述计算1维直线上的质心很简单，那么现在扩展到2维平面。如下图，矩形的质心很容易求得为 (2，1)。</p>
<p><img src="/assets/Image1208.gif" alt="Center of mass 3"></p>
<p>如果更复杂的形状呢？</p>
<p><img src="/assets/Image1211.gif" alt="Center of mass 4"></p>
<p>计算方法是将多边形分解为多个容易求质心的规则矩形，过程如下：</p>
<p>首先将多边形分解为左右两个规则矩形，如下图：</p>
<p><img src="/assets/Image1212.gif" alt="Center of mass 5"></p>
<p>左矩形的面积为 3 x 2 = 6，质心为 (-0.5, 1)<br>左矩形的面积为 2 x 4 = 8，质心为 (2, 2)</p>
<p>我们假设多边形质量是均匀分布的，那么矩形的面积就可以代表它的质量，所以在x轴上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">6 x -0.5 + 8 x 2 = (6 + 8) x dx</div><div class="line">-3 + 16 = 14 x dx</div><div class="line">13 = 14 x dx</div><div class="line">dx = 13 / 14</div></pre></td></tr></table></figure></p>
<p>同理，在y轴上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">6 x 1 + 8 x 2 = (6 + 8) x dy</div><div class="line">6 + 16 = 14 x dy</div><div class="line">22 = 14 x dy</div><div class="line">dy = 11 / 7</div></pre></td></tr></table></figure></p>
<p>最终求得多边形的质心为(13/14, 11/7)</p>
<p>由以上过程，我们可以得出一个更为普遍的结论：</p>
<p>质心 = 惯性 / 质量</p>
<p>用公式表达即为：<br><img src="/assets/eq1.png" alt="eq1"></p>
<p>对于任意不规则多边形，如何利用上述公式计算质心呢？其原理是将多边形剖分为三角形，然后分别计算每个三角形的面积和质心。</p>
<p><img src="/assets/PolygonArea1.png" alt="Polygon area"></p>
<p>对于三角形的面积，我们可以采用向量积公式计算:<br>$<br>signedArea(ABC)=\frac{1}{2}(x_1y_2 - x_2y_1)<br>$<br><img src="/assets/figure7.jpg" alt="Area of triangle"></p>
<p>对于三角形的质心，采用如下公式计算：<br>$<br>centroid(ABC)=(\frac{A_x + B_x + C_x}{3}, \frac{A_y + B_y + C_y}{3})<br>$<br><img src="/assets/figure8.jpg" alt="Centroid of triangle"></p>
<p>剩下的任务是选择一个剖分点P，将多边形剖分为多个三角形。由于我们在用向量积计算三角形面积时，其结果是有正负的。选择哪一个剖分点，并不影响最终加和后的总面积，<strong>前提是多边形的坐标点按逆时针排列</strong>。所以，为了简便期间，选取坐标原点作为剖分点。<br><img src="/assets/PolygonArea3.png" alt="Polygon area"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// polygon按顺时针排列顶点</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCentroid</span>(<span class="params">polygon</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> totalArea = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> totalX = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> totalY = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> points = polygon[<span class="number">0</span>]</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; points.length; ++i) &#123;</div><div class="line">    <span class="comment">// a、b以及原点构成一个三角形</span></div><div class="line">    <span class="keyword">var</span> a = points[i + <span class="number">1</span>]</div><div class="line">    <span class="keyword">var</span> b = points[i]</div><div class="line"></div><div class="line">    <span class="keyword">var</span> area = <span class="number">0.5</span> * (a[<span class="number">0</span>] * b[<span class="number">1</span>] - b[<span class="number">0</span>] * a[<span class="number">1</span>])  <span class="comment">// 计算面积</span></div><div class="line">    <span class="keyword">var</span> x = (a[<span class="number">0</span>] + b[<span class="number">0</span>]) / <span class="number">3</span>  <span class="comment">// 计算x方向质心</span></div><div class="line">    <span class="keyword">var</span> y = (a[<span class="number">1</span>] + b[<span class="number">1</span>]) / <span class="number">3</span>  <span class="comment">// 计算y方向质心</span></div><div class="line"></div><div class="line">    totalArea += area</div><div class="line">    totalX += area * x</div><div class="line">    totalY += area * y</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> [totalX / totalArea, totalY/ totalArea]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[求点到多边形的距离的算法实现]]></title>
      <url>https://jingsam.github.io/2016/09/26/polydist.html</url>
      <content type="html"><![CDATA[<p>在之前的<a href="/2016/09/26/polylabel2.html">博文</a>中，多边形注记点搜寻算法需要计算点到多边形的距离，本文就来讲一讲如何用JS实现点到多边形距离的计算。</p>
<h2 id="如何定义点到多边形的距离？"><a href="#如何定义点到多边形的距离？" class="headerlink" title="如何定义点到多边形的距离？"></a>如何定义点到多边形的距离？</h2><p>在本文中，点到多边形的距离定义如下：</p>
<ol>
<li>点到多边形边界的最短距离。</li>
<li>点在多边形内部，距离为正；在多边形外部，距离为负；在边上，距离为零。</li>
</ol>
<p>根据上面的定义，计算点到多边形的距离需要解决两个问题：</p>
<ol>
<li>点到多边形的最短距离如何计算？</li>
<li>如何判断点在多边形内部、外部、还是在边界上？</li>
</ol>
<h2 id="点到多边形最短距离的计算"><a href="#点到多边形最短距离的计算" class="headerlink" title="点到多边形最短距离的计算"></a>点到多边形最短距离的计算</h2><p>计算点到多边形最短距离的基本原理是：依次计算点到多边形每条边的距离，然后筛选出最短距离。</p>
<p><img src="/assets/min-dist.png" alt="min-dist"></p>
<p>如下图，假设<code>AB</code>为多边形的一条边，现在求点<code>P</code>到<code>AB</code>的距离。</p>
<p><img src="/assets/segment-dist.png" alt="segment-dist"></p>
<p>根据<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E9%87%8F%E7%A7%AF" target="_blank" rel="external">向量内集</a>的公式（$\vec{a} \cdot \vec{b} = |a||b|cosθ$）,我们可以推出：<br>$<br>\vec{AB} \cdot \vec{AP} = |AB||AP|cosθ = |AB||AD|<br>\ 设 |AD| = t|AB|<br>\ 则 t = \frac{\vec{AB} \cdot \vec{AP}}{|AB|^2}<br>$</p>
<p>根据以上公式，我们可以求出<code>t</code>，进而求出点<code>D</code>的坐标，最终<code>PD</code>的长度就很容易求得了。</p>
<p>但是还有一些边界条件需要注意，即最终<code>D</code>点不是落在<code>AB</code>上，有以下上中情况：</p>
<ol>
<li><code>t &lt; 0</code>，<code>D</code>在<code>BA</code>延长线上，此时最短距离取<code>PA</code>；</li>
<li><code>0 &lt;= t &lt;= 1</code>，<code>D</code>在<code>AB</code>上，此时最短距离取<code>PD</code>；</li>
<li><code>t &gt; 1</code>，<code>D</code>在<code>AB</code>延长线上，此时最短距离取<code>PB</code>；</li>
</ol>
<p><img src="/assets/t.png" alt="t"></p>
<p>JS实现代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointToSegmentDist</span>(<span class="params">p, a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> AB = [b[<span class="number">0</span>] - a[<span class="number">0</span>], b[<span class="number">1</span>] - a[<span class="number">1</span>]]</div><div class="line">  <span class="keyword">var</span> AP = [p[<span class="number">0</span>] - a[<span class="number">0</span>], p[<span class="number">1</span>] - a[<span class="number">1</span>]]</div><div class="line"></div><div class="line">  <span class="keyword">var</span> AB_AP = AB[<span class="number">0</span>] * AP[<span class="number">0</span>] + AB[<span class="number">1</span>] * AP[<span class="number">1</span>]</div><div class="line">  <span class="keyword">var</span> distAB2 = AB[<span class="number">0</span>] * AB[<span class="number">0</span>] + AB[<span class="number">1</span>] * AB[<span class="number">1</span>]</div><div class="line"></div><div class="line">  <span class="keyword">var</span> D = [a[<span class="number">0</span>], a[<span class="number">1</span>]]</div><div class="line">  <span class="keyword">if</span> (distAB2 != <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">var</span> t = AB_AP / distAB2</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (t &gt; <span class="number">1</span>) &#123;</div><div class="line">      D = [b[<span class="number">0</span>], b[<span class="number">1</span>]]</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; <span class="number">0</span>) &#123;</div><div class="line">      D = [a[<span class="number">0</span>] + AB[<span class="number">0</span>] * t, a[<span class="number">1</span>] + AB[<span class="number">1</span>] * t]</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      D = [a[<span class="number">0</span>], a[<span class="number">1</span>]]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> AD = [p[<span class="number">0</span>] - a[<span class="number">0</span>], p[<span class="number">1</span>] - a[<span class="number">1</span>]]</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(AD[<span class="number">0</span>] * AD[<span class="number">0</span>] + AD[<span class="number">1</span>] * AD[<span class="number">1</span>])</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="判断点与多边形的位置关系"><a href="#判断点与多边形的位置关系" class="headerlink" title="判断点与多边形的位置关系"></a>判断点与多边形的位置关系</h2><p>判断点与多边形的位置关系，常用的算法是射线法，即经过点沿水平方向做一条直线，观察点左边或右边交点的个数。如果交点个数为奇数，点在多变形内部；交点个数为偶数，点在多边形外部。</p>
<p><img src="/assets/ray.gif" alt="ray"></p>
<p>如下图，<code>ab</code>与过<code>p</code>点的水平线相交于c，则有：<br>$<br>\frac{x_2 - x_1}{y_2 - y_1} = \frac{x’ - x_1}{y - y_1}<br>\ 那么 x’ = \frac{(x_2 - x_1)(y - y_1)}{y_2 - y_1} + x_1<br>$</p>
<p><img src="/assets/ray2.png" alt="ray2"></p>
<p>JS 算法实现为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointInPolygon</span>(<span class="params">p, polygon</span>) </span>&#123;</div><div class="line">  <span class="comment">// 统计p点右边交点的个数</span></div><div class="line">  <span class="keyword">var</span> count = <span class="number">0</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; polygon.length; k++) &#123;</div><div class="line">    <span class="keyword">var</span> ring = polygon[k]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ring.length - <span class="number">1</span>; i++) &#123;</div><div class="line">      <span class="keyword">var</span> a = ring[i]</div><div class="line">      <span class="keyword">var</span> b = ring[j]</div><div class="line"></div><div class="line">      <span class="keyword">if</span> ((a[<span class="number">1</span>] &gt; y !== b[<span class="number">1</span>] &gt; y) &amp;&amp;</div><div class="line">        (x &lt; (b[<span class="number">0</span>] - a[<span class="number">0</span>]) * (y - a[<span class="number">1</span>]) / (b[<span class="number">1</span>] - a[<span class="number">1</span>]) + a[<span class="number">0</span>])) count++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> count % <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>解决了以上两个难题之后，下面给出完整实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pointToPolygonDist</span>(<span class="params">p, polygon</span>) </span>&#123;</div><div class="line">  <span class="comment">// 统计p点右边交点的个数</span></div><div class="line">  <span class="keyword">var</span> count = <span class="number">0</span></div><div class="line">  <span class="keyword">var</span> minDist = <span class="literal">Infinity</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; polygon.length; k++) &#123;</div><div class="line">    <span class="keyword">var</span> ring = polygon[k]</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ring.length - <span class="number">1</span>; i++) &#123;</div><div class="line">      <span class="keyword">var</span> a = ring[i]</div><div class="line">      <span class="keyword">var</span> b = ring[j]</div><div class="line"></div><div class="line">      <span class="keyword">if</span> ((a[<span class="number">1</span>] &gt; y !== b[<span class="number">1</span>] &gt; y) &amp;&amp;</div><div class="line">        (x &lt; (b[<span class="number">0</span>] - a[<span class="number">0</span>]) * (y - a[<span class="number">1</span>]) / (b[<span class="number">1</span>] - a[<span class="number">1</span>]) + a[<span class="number">0</span>])) count++;</div><div class="line"></div><div class="line">      minDist = <span class="built_in">Math</span>.min(minDist, pointToSegmentDist(p, a, b))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (count % <span class="number">2</span> === <span class="number">0</span>) minDist = -minDist</div><div class="line"></div><div class="line">  <span class="keyword">return</span> minDist</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[多边形注记点搜索算法实现]]></title>
      <url>https://jingsam.github.io/2016/09/26/polylabel2.html</url>
      <content type="html"><![CDATA[<p>在<a href="/2016/09/24/polylabel.html">上一篇</a>博文中，我讲了多边形注记点搜索算法的基本原理，本篇文章讲一讲如何用JS实现。</p>
<p>建议读者阅读本篇博文之前，一定要先了解<a href="/2016/09/24/polylabel.html">上一篇</a>博文中提到的算法原理。</p>
<h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><p>我们定义一个函数接口，接受一个多边形，计算其标注点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">polylabel</span>(<span class="params">polygon</span>) </span>&#123;</div><div class="line">  <span class="comment">// TODO</span></div><div class="line">  <span class="keyword">return</span> [x, y]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.export = polylabel</div></pre></td></tr></table></figure></p>
<p>使用时，我们可以这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var polylabel = require(&apos;polylabel&apos;)</div><div class="line"></div><div class="line">var polygon = [[[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]]]</div><div class="line">var point = polylabel(polygon)</div></pre></td></tr></table></figure></p>
<p>对于polygon，我们采用geojson对多边形的坐标定义格式，即多边形由多个环组成，其中第一个环是外环，其他的为内环。所以<code>polygon[0]</code>表示第一个环，<code>ploygon[0][0]</code>表示起点坐标。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始实现polylabel之前，需要一些辅助函数和库。</p>
<p>首先，我们定义网格对象<code>Cell</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cell</span>(<span class="params">x, y, h, polygon</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.x = x  <span class="comment">// 中心点x</span></div><div class="line">  <span class="keyword">this</span>.y = y  <span class="comment">// 中心点y</span></div><div class="line">  <span class="keyword">this</span>.h = h  <span class="comment">// 中心点到网格的距离，相当于格网大小的1/2</span></div><div class="line">  <span class="keyword">this</span>.d = pointToPolygonDist(x, y, polygon)  <span class="comment">// 中心点到多边形的距离</span></div><div class="line">  <span class="keyword">this</span>.max = <span class="keyword">this</span>.d + <span class="keyword">this</span>.h * <span class="built_in">Math</span>.SQRT2     <span class="comment">// 网格内部区域到多边形的最大距离</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义网格对象的主要目的是方便求取最大距离<code>this.max</code>，有了网格对象<code>Cell</code>之后，每当我们实例化一个cell对象，我们就可以知道这个网格区域的最大距离以及它所代表的区域。</p>
<p><code>pointToPolygonDist</code>是计算点到多边形的距离的函数，其基本原理是计算点到多边形每条边的距离，取最短距离即为点到多边形的距离。详细的算法实现我考虑专门用一篇文章来讲。</p>
<p><code>this.d + this.h * Math.SQRT2</code>即为我们之前在算法原理中求得的最大距离<code>dist + radius</code>，由于格网是一个正方形，其外接圆形的半径即为中心点到任意一个顶点的距离，即<code>this.h * Math.SQRT2</code>。</p>
<p><img src="/assets/radius.png" alt="radius"></p>
<p>另一个需要准备的是一个<a href="https://en.wikipedia.org/wiki/Priority_queue" target="_blank" rel="external">优先级队列</a>的数据结构，它与一般的队列不同在于，优先级队列中的元素都是经过排序的。每当push一个元素，并不是简单地将该元素放入队列末尾，而是会将该元素与队列中的元素进行比较，放到一个合适的位置上。</p>
<p>我们可以定义一个优先级队列，队列里存储的是格网对象。每push入一个格网，根据最大距离<code>max</code>进行排序，大的在前，小的在后。由此，我们可以分裂格网时，只需从队首pop出一个格网进行操作。</p>
<p>优先级队列的一个JS实现是<a href="https://github.com/mourner/tinyqueue" target="_blank" rel="external">tinyqueue</a>，同样是Vladimir Agafonkin的作品。</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Queue = <span class="built_in">require</span>(<span class="string">'tinyqueue'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">polylabel</span>(<span class="params">polygon</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 计算bbox，为切分网格做准备</span></div><div class="line">  <span class="keyword">var</span> minX, minY, maxX, maxY</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; polygon[<span class="number">0</span>].length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> p = polygon[<span class="number">0</span>][i]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">0</span>] &lt; minX) minX = p[<span class="number">0</span>]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">1</span>] &lt; minY) minY = p[<span class="number">1</span>]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">0</span>] &gt; maxX) maxX = p[<span class="number">0</span>]</div><div class="line">    <span class="keyword">if</span> (!i || p[<span class="number">1</span>] &gt; maxY) maxY = p[<span class="number">1</span>]</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 计算长和宽，初始格网大小和高度</span></div><div class="line">  <span class="keyword">var</span> width = maxX - minX</div><div class="line">  <span class="keyword">var</span> height = maxY - minY</div><div class="line">  <span class="keyword">var</span> cellSize = <span class="built_in">Math</span>.min(width, height)</div><div class="line">  <span class="keyword">var</span> h = cellSize / <span class="number">2</span></div><div class="line"></div><div class="line">  <span class="comment">// 初始化一个存储Cell的优先级队列，按距离从大到小排列</span></div><div class="line">  <span class="keyword">var</span> cellQueue = <span class="keyword">new</span> Queue(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> b.max - a.max</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 将多边形切分</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = minX; x &lt; maxX; x += cellSize) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> y = minY; y &lt; maxY; y += cellSize) &#123;</div><div class="line">      cellQueue.push(<span class="keyword">new</span> Cell(x + h, y + h, h, polygon));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 取对首为最优格网</span></div><div class="line">  <span class="keyword">var</span> bestCell = cellQueue.peek()</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (cellQueue.length) &#123;</div><div class="line">    <span class="keyword">var</span> cell = cellQueue.pop()</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cell.d &gt; bestCell.d) bestCell = cell</div><div class="line"></div><div class="line">    <span class="comment">// 最大距离小于最优格网的距离，直接淘汰</span></div><div class="line">    <span class="keyword">if</span> (cell.max &lt;= bestCell.d) <span class="keyword">continue</span></div><div class="line"></div><div class="line">    <span class="comment">// 将格网裂为4个小格网</span></div><div class="line">    h = cell.h / <span class="number">2</span></div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x - h, cell.y - h, h, polygon))</div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x + h, cell.y - h, h, polygon))</div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x - h, cell.y + h, h, polygon))</div><div class="line">    cellQueue.push(<span class="keyword">new</span> Cell(cell.x + h, cell.y + h, h, polygon))</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> [bestCell.x, bestCell.y]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h2><p>上一节描述了多边形注记点搜寻算法的基本实现，我们还需要对其进行优化，提升算法效率。</p>
<p>为了提升效率，我们可以增加一个容差参数，允许最后的注记点有一定的误差，以减少运算次数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// if (cell.max &lt;= bestCell.d) continue</span></div><div class="line"><span class="keyword">if</span> (cell.max - bestCell.d &lt;= precision) <span class="keyword">continue</span></div></pre></td></tr></table></figure></p>
<p>另外，我们可以在初始时，用centroid作为初始最优点，因为大多数凸多边形的centroid就是最佳注记点：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// var bestCell = cellQueue.peek()</span></div><div class="line"><span class="keyword">var</span> bestCell = getCentroidCell(polygon)</div></pre></td></tr></table></figure></p>
<p>当然，多变形的centeroid怎么求，估计又得用一篇博文来说了。</p>
<p>感觉给自己挖了好多坑。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[多边形注记点搜索的算法原理]]></title>
      <url>https://jingsam.github.io/2016/09/24/polylabel.html</url>
      <content type="html"><![CDATA[<p>在制图过程中，对多边形进行标注是一个常见的需求。然而如何快速找到一个合适的注记点，确不是一个很容易的事情。</p>
<p>最近，Leaflet的作者<a href="https://github.com/mourner" target="_blank" rel="external">Vladimir Agafonkin</a>大神发表了一篇<a href="https://www.mapbox.com/blog/polygon-center/" target="_blank" rel="external">博文</a>，描述了他如何用100多行JS代码，实现一个高效的多边形标注点搜寻<a href="https://github.com/mapbox/polylabel" target="_blank" rel="external">算法</a>。</p>
<p>虽然他在博文中描述了算法的原理，但是对于我这种数学不好的人，有些细节方面的东西还不甚了解。因此，此篇文章将以我这种小白角度，事无巨细地解释下他的算法。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>对于一个多边形，哪一个点才适合做标注点呢？自然而然我们就会想到是重心，即<a href="https://en.wikipedia.org/wiki/Centroid" target="_blank" rel="external">centroid</a>。然而对于凹多边形或者环，它们的重心会出现在多边形外部，这明显不是我们想要的。</p>
<p><img src="/assets/centeroid.png" alt="centeroid"></p>
<p>一个合适的标注点，应该是多边形的视觉中心，即以该点为圆心在多边形内部画一个圆，该圆的面积是最大的。假如我们定义一个点到多边形的距离为该点到多边形各边的最短距离，并且规定点在多边形内部时距离为正，点在外部时距离为负。所以多边形标注问题就可以简化为寻找离多边形最远的点，即<a href="https://en.wikipedia.org/wiki/Pole_of_inaccessibility" target="_blank" rel="external">pole of inaccessibility</a>。</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>理论上，只要知道多边形的各点坐标，必定能够用数学公式求出这个离多边形最远的点。然而，求解这个标注点的精确坐标必定非常耗时，实际上我们只需要一个近似解就足够了。</p>
<p>如何搜寻这个点呢？其实算法原理很简单，即利用分而治之的思想，先搜寻一小块区域，逐步淘汰差的区域，逐步缩小搜寻范围，最终找到最优点。具体步骤为：</p>
<ol>
<li>对多边形进行格网划分，求出格网内部的点到多边形的最大距离。</li>
<li>按最大距离对格网进行排序，淘汰距离小的格网，保留距离大的格网。</li>
<li>对剩下的格网再进行细分，重复步骤1和步骤2。</li>
</ol>
<p>在以上的步骤中，格网内部的点到多边形的最大距离如何计算是一个问题。如下图，格网中心点到多边形的距离为<code>dist</code>，到顶点的距为<code>radius</code>，那么格网到多边形的最大距离<code>maxd = dist + radius</code>。</p>
<p><img src="/assets/dist.jpg" alt="dist"></p>
<p>如何证明上述计算最大距离的公式呢？我几何学得不好，没办法给出严密的数学证明，但是我可以通过图示予以说明。</p>
<p>如下图，设多边形内部一点<code>O</code>，其距多边形的距离<code>OA</code>长度为<code>dist</code>。以<code>O</code>为圆心，以<code>radius</code>为半径作一个圆。延长AO，交圆于点<code>B</code>，那么<code>AB</code>的长度为<code>dist + radius</code>。在圆内部任意取一点<code>B&#39;</code>，显然<code>AB&#39; &lt;= AB = dist + radius</code>。假设点<code>B‘</code>到多边形的距离为<code>d</code>，那么<code>d &lt;= AB&#39; &lt;= AB = dist + radius</code>。所以对于圆内的任意一点，其到多边形的距离必定小于等于<code>dist + radius</code>。在圆内部取一个正方形区域，仍然符合<code>d &lt;= dist + radius</code>，这就证明格网区域的最大距离为<code>dist + radius</code>。</p>
<p><img src="/assets/proof.png" alt="proof"></p>
<p>如何对格网进行细分呢？我们可以用四叉树，将一个格网分割为4个小格网。</p>
<p><img src="/assets/quadtree.jpg" alt="quadtree"></p>
<p>搜寻标注点的算法原理是不是很简单？我将在下一篇博文中详细描述如何用JS实现该算法。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Mongodb全文搜索实战]]></title>
      <url>https://jingsam.github.io/2016/06/04/mongodb-text-search.html</url>
      <content type="html"><![CDATA[<p>在传统的关系型数据库中，我们通常将数据结构化，通过一系列表关联、聚合来查询我们所需的结果。而在非结构化的数据中，缺少这种预定义的结构，因而如何快速查询定位到我们所需要的结果，不是一件容易的事。</p>
<p>Mongodb作为一种NoSQL数据库，非常适合存储和管理非结构化数据，例如互联网上的各种文本数据。假如我们用Mongodb存储了很多博客文章，那么如何快速找到所有关于“nodejs”这个主题的文章呢？Mongodb内建的全文搜索可以帮助我们完成这个功能。</p>
<p>在本篇博文中，将要介绍的是我使用Mongdb text search的一些经验。</p>
<h3 id="Mongodb-text-search是什么？"><a href="#Mongodb-text-search是什么？" class="headerlink" title="Mongodb text search是什么？"></a>Mongodb text search是什么？</h3><p>Mongodb text search是Mongodb对数据库进行搜索的功能模块，类似于数据库内建的搜索引擎。有些人可能会疑问，查数据库为什么还需要搜索引擎？直接用条件查询不就得了。例如在前面的文章主题搜索中，我们不可能事先提取出每篇文章的主题，然后用专门的字段存储，因此没办法进行条件查询。并且同一个主题词，有多种不同的表达方式，例如”node”、”nodejs”可视为同一个主题。</p>
<p>Mongodb text search可以自动地对大段的文本数据进行分词处理、模糊匹配、同义词匹配，解决文本搜索的问题。</p>
<h3 id="建立文本索引"><a href="#建立文本索引" class="headerlink" title="建立文本索引"></a>建立文本索引</h3><p>要使Mongodb能够进行全文搜索，首先要对搜索的字段建立文本索引。建立文本索引的关键字是<code>text</code>，我们既可以建立单个字段的文本索引，也可以建立包含多个字段的复合文本索引。<strong>需要注意的是，每个collection只能建立一个文本索引，且只能对String或String数组的字段建立文本索引</strong>。</p>
<p>我们可以通过以下命令，建立一个文本索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.collection.createIndex(&#123; subject: &quot;text&quot;, content: &quot;text&quot; &#125;)</div></pre></td></tr></table></figure></p>
<p>在mongoose中我们可以通过以下代码，创建文本索引：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">schema.index(&#123; subject: &quot;text&quot;, content: &quot;text&quot; &#125;)</div></pre></td></tr></table></figure></p>
<p>需要注意的是，由于每个collection只支持一个文本索引，所以当你需要在schema中添加或删除文本索引字段时，往往不起作用。这时候你需要到数据库中，手动删除已经建立的文本索引。</p>
<h3 id="文本搜索示例"><a href="#文本搜索示例" class="headerlink" title="文本搜索示例"></a>文本搜索示例</h3><p>文本搜索的语法为：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  $text:</div><div class="line">    &#123;</div><div class="line">      $search: &lt;string&gt;,</div><div class="line">      $language: &lt;string&gt;,</div><div class="line">      $caseSensitive: &lt;boolean&gt;,</div><div class="line">      $diacriticSensitive: &lt;boolean&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在mongoose中，我们可以通过以下语句进行文本搜索：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var query = model.find(&#123; $text: &#123; $search: &quot;hello world&quot; &#125; &#125;)</div></pre></td></tr></table></figure></p>
<p><code>$search</code>后面的关键词可以有多个，关键词之间的分隔符可以是多种字符，例如空格、下划线、逗号、加号等，但不能是<code>-</code>和<code>\&quot;</code>，因为这两个符号会有其他用途。搜索的多个关键字是<code>or</code>的关系，除非你的关键字包含<code>-</code>。例如<code>hello world</code>会包含所有匹配<code>hello</code>或<code>world</code>的文本，而<code>hello -world</code>只会匹配包含<code>hello</code>且不包含<code>world</code>的文本。</p>
<p><code>$language</code>指示搜索的语言类型，在最新的Mongodb 3.2 enterprise版本中，已经增加了对中文文本的搜索。</p>
<p><code>$caseSensitive</code>设置是否区分大小写。</p>
<p><code>$diacriticSensitive</code>设置是否区别发音符号，<code>CAFÉ</code>于<code>Café</code>是同一语义，只是重音不一样。</p>
<p>我们还可以对搜索的结果按匹配度进行排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.posts.find(</div><div class="line">   &#123; $text: &#123; $search: &quot;hello world&quot; &#125; &#125;,</div><div class="line">   &#123; score: &#123; $meta: &quot;textScore&quot; &#125; &#125;</div><div class="line">).sort( &#123; score: &#123; $meta: &quot;textScore&quot; &#125; &#125; )</div></pre></td></tr></table></figure></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Mongodb建立文本索引时，会对提取所有文本的关键字建立索引，因而会造成一定的性能问题。所以对于结构化的字段，建议用普通的关系查询，如果需要对大段的文本进行搜索，才考虑用全文搜索。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu server命令行配置shadowsocks全局代理]]></title>
      <url>https://jingsam.github.io/2016/05/08/setup-shadowsocks-http-proxy-on-ubuntu-server.html</url>
      <content type="html"><![CDATA[<p>由于Ubuntu Server是不带用户界面的，所以要为Server配置Shadowsocks还是稍显麻烦。本文就是我配置Shadowsocks的一些经验，以待参考。</p>
<h3 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h3><p>由于shadowsocks是基于python开发的，所以必须安装python：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python</div></pre></td></tr></table></figure></p>
<p>接着安装python的包管理器pip：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python-pip</div></pre></td></tr></table></figure></p>
<p>安装完毕之后，通过pip直接安装shadowsocks：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo pip install shadowsocks</div></pre></td></tr></table></figure></p>
<h3 id="配置shadowsocks"><a href="#配置shadowsocks" class="headerlink" title="配置shadowsocks"></a>配置shadowsocks</h3><p>新建一个配置文件<code>shawdowsocks.json</code>，然后配置相应的参数：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"server"</span>: <span class="string">"&#123;your-server&#125;"</span>,</div><div class="line">  <span class="attr">"server_port"</span>: <span class="number">40002</span>,</div><div class="line">  <span class="attr">"local_port"</span>: <span class="number">1080</span>,</div><div class="line">  <span class="attr">"password"</span>: <span class="string">"&#123;your-password&#125;"</span>,</div><div class="line">  <span class="attr">"timeout"</span>: <span class="number">600</span>,</div><div class="line">  <span class="attr">"method"</span>: <span class="string">"aes-256-cfb"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的参数需要你的shawdowsocks服务提供商为你提供，当然你也可以自己搭建一个。如何搭建个人的shawdowsocks不在本文讨论范围之内，请参阅其他教程。</p>
<p>配置完成后就可以启动shawdowsocks服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo sslocal -c shawdowsocks.json -d start</div></pre></td></tr></table></figure></p>
<h3 id="配置全局代理"><a href="#配置全局代理" class="headerlink" title="配置全局代理"></a>配置全局代理</h3><p>启动shawdowsocks服务后，发现并不能翻墙上网，这是因为shawdowsocks是socks 5代理，需要客户端配合才能翻墙。</p>
<p>为了让整个系统都走shawdowsocks通道，需要配置全局代理，可以通过polipo实现。</p>
<p>首先是安装polipo：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install polipo</div></pre></td></tr></table></figure></p>
<p>接着修改polipo的配置文件<code>/etc/polipo/config</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">logSyslog = <span class="literal">true</span></div><div class="line">logFile = /var/<span class="built_in">log</span>/polipo/polipo.log</div><div class="line"></div><div class="line">proxyAddress = <span class="string">"0.0.0.0"</span></div><div class="line"></div><div class="line">socksParentProxy = <span class="string">"127.0.0.1:1080"</span></div><div class="line">socksProxyType = socks5</div><div class="line"></div><div class="line">chunkHighMark = 50331648</div><div class="line">objectHighMark = 16384</div><div class="line"></div><div class="line">serverMaxSlots = 64</div><div class="line">serverSlots = 16</div><div class="line">serverSlots1 = 32</div></pre></td></tr></table></figure></p>
<p>重启polipo服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/polipo restart</div></pre></td></tr></table></figure></p>
<p>为终端配置http代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export http_proxy=&quot;http://127.0.0.1:8123/&quot;</div></pre></td></tr></table></figure></p>
<p>接着测试下能否翻墙：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl www.google.com</div></pre></td></tr></table></figure></p>
<p>如果有响应，则全局代理配置成功。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>服务器重启后，下面两句需要重新执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo sslocal -c shawdowsocks.json -d start</div><div class="line">export http_proxy=&quot;http://127.0.0.1:8123/&quot;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Nodejs网站部署到DigtialOcean]]></title>
      <url>https://jingsam.github.io/2016/04/20/deploy-to-digitialocean.html</url>
      <content type="html"><![CDATA[<p>最近基于Express + Mongodb开发了一个纯API服务，现在要部署到公网上。我选择的是DigitialOcean的主机，但整个部署过程不仅仅适用于DigitialOcean，其他VPS也可参考。</p>
<h2 id="创建主机"><a href="#创建主机" class="headerlink" title="创建主机"></a>创建主机</h2><p>假设我们现在已经注册了DigitialOcean账号，并且通过了邮箱验证和信用卡绑定。<br>首先创建一个主机，登录后点击<code>Create Droplets</code>，即可开始创建主机。Droplets的意思是小水滴，DigitialOcean是数字海洋，两者之间的关系还是蛮形象的。<br>在创建主机界面，我们可以选择主机的操作系统、服务器的位置、服务器的硬件配置等。我选择的是Ubuntu 15.10，San Franscisco的机房，以及最便宜5美元一个月的配置：1 CPU + 512M RAM + 20G SSD。<br>选择完配置之后，先别忙着点确定。里面有一项叫SSH key，可以将你的SSH的公钥填进去，这样我们稍后登录主机的时候就不需要填密码了。当然，如果你不知道怎么生成SSH key或者嫌麻烦，也可以通过密码登录，密码会在你创建完主机之后发到你的注册邮箱。</p>
<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>当主机创建完之后，我们可以通过SSH远程登录到主机上：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh root@xxx.xxx.xxx.xxx</div></pre></td></tr></table></figure></p>
<p>这里有个问题就是，我们是以root身份登录到系统中，而我们网站不能在root权限下部署。否则，要是有黑客获取了网站控制权限，就掌握了主机的控制权限，这是很危险的。所以，我们需要创建一个普通权限的用户，以普通用户的身份部署网站。</p>
<p>使用下面的命令添加新用户和密码，其中<code>-m</code>表示在<code>/home</code>目录下创建用户文件夹。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add user -m judy</div><div class="line">passwd judy</div></pre></td></tr></table></figure></p>
<p>为了之后安装软件方便，我们将新用户添加到<code>sudo</code>组中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo adduser judy sudo</div></pre></td></tr></table></figure></p>
<p>现在我们完成了新用户的创建。有些人在使用SSH登录到DigitalOcean后会发现很卡，打个命令半天才回显，在这里我推荐一款很好用的SSH替代软件：mosh。SSH的机制是我们输入一个字符，这个字符会发送到远程服务器，然后远程服务器收到后再发送回终端显示。在这个传输过程中，如果网络条件不好，会产生明显地卡顿。而mosh在你输入一个字符时，立即在终端上显示，然后再后台自动地将命令发送到远程服务器。因此即使在较差的网络条件下，mosh也可以很流畅。</p>
<p>mosh需要在客户端和服务端同时安装，安装的的命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install mosh</div></pre></td></tr></table></figure></p>
<p>退出root用户，然后用mosh重连，你将会发现比之前流畅多了，mosh连接的命令和SSH一样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mosh judy@xxx.xxx.xxx.xxx</div></pre></td></tr></table></figure></p>
<h2 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h2><p>由于我们的网站是基于Express的，因此需要安装nodejs。Ubuntu的官方源上没有nodejs，需要添加nodesource源，安装的命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install curl</div><div class="line">curl -sL https://deb.nodesource.com/setup_5.x | sudo -E bash -</div><div class="line">sudo apt-get install nodejs</div></pre></td></tr></table></figure></p>
<p><code>sudo</code>命令是临时借用root的权限去执行命令。</p>
<h2 id="安装mongodb和git"><a href="#安装mongodb和git" class="headerlink" title="安装mongodb和git"></a>安装mongodb和git</h2><p>网站的数据库采用的是mongodb，幸运的是Ubuntu的官方源收录了mongodb，所以我们可以直接用apt安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mongodb</div></pre></td></tr></table></figure></p>
<p>mongodb安装完之后会自动启动守护程序mongod，并设置了开机自启动。检查mongodb是否成功启动，可以运行<code>mongo</code>连接数据是否成功。</p>
<p>网站的源代码托管在GitHub上，所以要把代码下载下来，我们还需要安装git：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install git</div></pre></td></tr></table></figure></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>通过git将网站源代码拉取下来，并安装相应的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/&#123;your_git_repo&#125; site</div><div class="line">cd site</div><div class="line">npm install</div></pre></td></tr></table></figure></p>
<p>网站的软件环境基本上准备好了，如果代码有测试的话，可以跑一遍测试看网站是否各项功能正常。</p>
<p>Express网站开发的时候，默认的服务端口是3000。由于服务是公开发布的，总不能让用户还在网址后面加个端口号吧。所以，我们将网站切换到80端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PORT=80 node ./bin/www</div></pre></td></tr></table></figure></p>
<p>不幸的是，你将马上看到出错信息，信息显示80端口只有root用户才能使用。实际上，任何小于1024的端口，都只能由root用户使用。所以我们用采取一定的措施，使得网站服务可以使用80端口。方法很简单，我们可以借助cap2实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libcap2-bin</div><div class="line">sudo <span class="built_in">setcap</span> cap_net_bind_service=+ep `<span class="built_in">which</span> nodejs`</div></pre></td></tr></table></figure></p>
<p>后一条命令中的<code>which nodejs</code>是找出nodejs可执行文件的路径，一定要是nodejs的实际路径，不能是符号链接。</p>
<p>执行以上命令后，再次测试就会发现能够使用80端口了。</p>
<h2 id="更改时区"><a href="#更改时区" class="headerlink" title="更改时区"></a>更改时区</h2><p>新建的主机默认的时区是0时区，更改为北京时间可用交互式的命令行工具<code>tzselect</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tzselect</div><div class="line">sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上过程，基本上完成了对服务器的配置。但是还有很多工作要做，例如nodejs进程自动重启、网站制动部署等，这将在以后的博文中逐步说明。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[TileJSON技术规范]]></title>
      <url>https://jingsam.github.io/2016/04/18/tilejson-spec.html</url>
      <content type="html"><![CDATA[<p>以下是<a href="https://github.com/mapbox/tilejson-spec/tree/master/2.1.0" target="_blank" rel="external">《TileJSON Specification》</a>最新的2.1.0版的中文翻译，以便查阅。</p>
<h1 id="TileJSON-2-1-0"><a href="#TileJSON-2-1-0" class="headerlink" title="TileJSON 2.1.0"></a>TileJSON 2.1.0</h1><p>本文档中的“<strong>必须</strong>”、“<strong>必须不</strong>”、“<strong>必备</strong>”、”<strong>应该</strong>“、“<strong>不应该</strong>”、“<strong>建议</strong>”、“<strong>可以</strong>”、“<strong>可选</strong>”的含义参照<a href="https://www.ietf.org/rfc/rfc2119.txt" target="_blank" rel="external">RFC 2119</a>。</p>
<h2 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h2><p>本规范提出一种技术标准，来描述多种类型的网络地图图层的元数据信息，以方便客户端进行配置和浏览。</p>
<h2 id="2-文件格式"><a href="#2-文件格式" class="headerlink" title="2. 文件格式"></a>2. 文件格式</h2><p>TileJSON描述文件采用JSON格式，参见RFC 4627。</p>
<p>本规范的实现<strong>必须</strong>忽略掉未知key。但是，实现<strong>必须</strong>在他们的API中暴露出<br>这些未知的key/values，使得API用户可以选择性地处理这些keys。<br>实现<strong>必须</strong>忽略keys的无效values。如果key是必选的，实现<strong>必须</strong>认为整个<br>TileJSON描述文件无效并且拒绝进一步处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// **必选**。表示语义化的版本号。描述本JSON对象所遵守的TileJSON版本。</span></div><div class="line">    <span class="string">"tilejson"</span>: <span class="string">"2.1.0"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。表示瓦片集的名称。名称可以是任何合法字符。</span></div><div class="line">    <span class="comment">// 实现**不应该**将此名称当做HTML来解析。</span></div><div class="line">    <span class="string">"name"</span>: <span class="string">"compositing"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。表示瓦片集的描述信息。描述可以是任何合法字符。</span></div><div class="line">    <span class="comment">// 实现**不应该**将此描述当做HTML来解析。</span></div><div class="line">    <span class="string">"description"</span>: <span class="string">"A simple, light grey world."</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值："1.0.0"。表示语义化的版本号。当瓦片发生更改时，次版本号</span></div><div class="line">    <span class="comment">// **必须**相应地更改。这可能导致标签的变化。因此，实现方能够在次版本号变化时</span></div><div class="line">    <span class="comment">// 清除缓存。更新级别的更改，**必须**限制在单块瓦片之内。</span></div><div class="line">    <span class="comment">// 当瓦片更改较大时，主版本号**必须**增加。</span></div><div class="line">    <span class="comment">// 实现**必须不**要使用不同主版本号的瓦片。</span></div><div class="line">    <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。包含地图的所有者信息。</span></div><div class="line">    <span class="comment">// 实现**可以**把这部分内容当做HTML或者纯文本。</span></div><div class="line">    <span class="comment">// 处于安全方面的原因，要绝对确保本字段的不会被用来进行XSS攻击或beacon跟踪。</span></div><div class="line">    <span class="string">"attribution"</span>: <span class="string">"&lt;a href='http://openstreetmap.org'&gt;OSM contributors&lt;/a&gt;"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。包含一个mustache模板，用来格式化grids数据来完成交互。</span></div><div class="line">    <span class="comment">// 参见https://github.com/mapbox/utfgrid-spec/tree/master/1.2的交互部分。</span></div><div class="line">    <span class="string">"template"</span>: <span class="string">"&#123;&#123;#__teaser__&#125;&#125;&#123;&#123;NAME&#125;&#125;&#123;&#123;/__teaser__&#125;&#125;"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。包含地图图例信息。</span></div><div class="line">    <span class="comment">// 实现**可以**把这部分内容当做HTML或者纯文本。</span></div><div class="line">    <span class="comment">// 处于安全方面的原因，要绝对确保本字段的不会被用来进行XSS攻击或beacon跟踪。</span></div><div class="line">    <span class="string">"legend"</span>: <span class="string">"Dangerous zones are red, safe zones are green"</span>,</div><div class="line">、</div><div class="line">    <span class="comment">// **可选**。默认值："xyz"。可以是"xyz"或"tms"。主要影响瓦片坐标的y轴方向。</span></div><div class="line">    <span class="comment">// 默认为global-mercator(Spherical Mercator)坐标系。</span></div><div class="line">    <span class="string">"scheme"</span>: <span class="string">"xyz"</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **必选**。表示一组瓦片资源。</span></div><div class="line">    <span class="comment">// 如果存在&#123;z&#125;、&#123;x&#125;和&#123;y&#125;，它们将会被相应的整数替换。</span></div><div class="line">    <span class="comment">// 如果指定了多个资源，客户端可以使用任意的资源组合。</span></div><div class="line">    <span class="comment">// 所有的资源**必须**为相同的URL返回相同的内容。</span></div><div class="line">    <span class="comment">// 本数组**必须**至少包含一个资源。</span></div><div class="line">    <span class="string">"tiles"</span>: [</div><div class="line">        <span class="string">"http://localhost:8888/admin/1.0.0/world-light,broadband/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png"</span></div><div class="line">    ],</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：[]。表示一组交互资源。</span></div><div class="line">    <span class="comment">// 如果存在&#123;z&#125;、&#123;x&#125;和&#123;y&#125;，它们将会被相应的整数替换。</span></div><div class="line">    <span class="comment">// 如果指定了多个资源，客户端可以使用任意的资源组合。</span></div><div class="line">    <span class="comment">// 所有的资源**必须**为相同的URL返回相同的内容。</span></div><div class="line">    <span class="comment">// 如果本数组没有任何内容，那么说明本瓦片集不支持交互数据。</span></div><div class="line">    <span class="comment">// 参见https://github.com/mapbox/utfgrid-spec/tree/master/1.2的交互部分</span></div><div class="line">    <span class="string">"grids"</span>: [</div><div class="line">        <span class="string">"http://localhost:8888/admin/1.0.0/broadband/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.grid.json"</span></div><div class="line">    ],</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：[]。表示一组GeoJSON格式的数据文件。</span></div><div class="line">    <span class="comment">// 如果存在&#123;z&#125;、&#123;x&#125;和&#123;y&#125;，它们将会被相应的整数替换。</span></div><div class="line">    <span class="comment">// 如果指定了多个资源，客户端可以使用任意的资源组合。</span></div><div class="line">    <span class="comment">// 所有的资源**必须**为相同的URL返回相同的内容。</span></div><div class="line">    <span class="comment">// 如果本数组没有任何内容，那么地图上不会呈现数据内容。</span></div><div class="line">    <span class="string">"data"</span>: [</div><div class="line">        <span class="string">"http://localhost:8888/admin/data.geojson"</span></div><div class="line">    ],</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：0。值域范围[0, 22]。</span></div><div class="line">    <span class="comment">// 表示最小缩放级别的一个整数。</span></div><div class="line">    <span class="string">"minzoom"</span>: <span class="number">0</span>,</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：22。值域范围[0, 22]。</span></div><div class="line">    <span class="comment">// 表示最大缩放级别的一个整数。**必须**大于等于minzoom</span></div><div class="line">    <span class="string">"maxzoom"</span>: <span class="number">11</span>,</div><div class="line"></div><div class="line">    <span class="comment">// 表示地图瓦片的最大范围。这个范围**必须**覆盖到所有的缩放级别。</span></div><div class="line">    <span class="comment">// 范围用WGS84坐标系下的经纬度来表示，顺序为左、下、右、上。</span></div><div class="line">    <span class="comment">// 范围值可能是整数或者浮点数。</span></div><div class="line">    <span class="string">"bounds"</span>: [ <span class="number">-180</span>, <span class="number">-85.05112877980659</span>, <span class="number">180</span>, <span class="number">85.0511287798066</span> ],</div><div class="line"></div><div class="line">    <span class="comment">// **可选**。默认值：null。</span></div><div class="line">    <span class="comment">// 第一个值是经度，第二个是纬度（都为WGS84坐标系），第三个是表示缩放级别的整数。</span></div><div class="line">    <span class="comment">// 经度和纬度**必须**在bounds范围内。缩放级别**必须**在minzoom和maxzoom之间。</span></div><div class="line">    <span class="comment">// 实现可以根据这个值设置地图的默认显示位置。</span></div><div class="line">    <span class="comment">// 如果这个值为null，实现可以根据自己的算法自行决定默认位置。</span></div><div class="line">    <span class="string">"center"</span>: [ <span class="number">-76.275329586789</span>, <span class="number">39.153492567373</span>, <span class="number">8</span> ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3. 缓存"></a>3. 缓存</h2><p>客户端<strong>可以</strong>缓存从远程服务器获取的文件。当实现决定采用缓存措施时，<strong>必须</strong><br>遵从为瓦片数据和TileJSON描述文件定义的有效HTTP缓存控制头。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Eslint配置实战]]></title>
      <url>https://jingsam.github.io/2016/04/17/config-eslint.html</url>
      <content type="html"><![CDATA[<p>在软件开发中，编码风格的统一，对项目可维护性具有重要作用。不像python、go语言对代码格式有着严格的规范，Javascript的语法非常灵活，开发人员可以写出天马行空的Javascript代码。而且，Javascript编译器的容错度较高，会诱使开发人员随意编写杂乱的代码。不规范的编码风格，不仅增加了理解代码的困难，也常常会产生隐含的bug。因此，Javascript相比于其他语言，更需要制定相应的编码规范。</p>
<p>统一代码规范，最直观的方法是团队成员商定一套统一的代码规范，大家按照这套规范进行代码编写。但是这种约定的方式约束力太弱，总会有人有意或无意地不遵守规范。更好的方式是，借助代码格式检测工具，自动化地进行格式检查，并将格式检查作为代码测试的一部分，集成到项目的持续集成过程中。</p>
<p>主流的Javascript代码格式检查工具有JSLint、JSHint、JSCS、ESLint。这些工具中，ESLint可以灵活配置规则，并以插件机制支持各种扩展，因而比前3种工具在功能上更为全面。本文以ESLint作为代码检查工具，描述如何将其集成到Javascript开发项目中。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装ESLint很简单，可以通过npm安装。ESLint既可以全局安装，也可以本地安装。推荐本地安装，因为这样做的好处一是不污染全局，二是分发比较方便，不会产生外部依赖，因为无法保证其他人的机器上也全部安装了ESLint。安装ESLint的命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install eslint --save-dev</div></pre></td></tr></table></figure></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>要使ESLint生效，需要在项目根目录下建立一个配置文件，来设定检查规则。ESLint提供了交互式的命令行工具，可以帮助我们快速地配置规则，初始化命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node_modules/.bin/eslint --init</div></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在package.json的script下添加一个lint命令，并指定要检测的文件或文件夹：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"lint"</span>: <span class="string">"eslint *.js models/**"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>命令行中运行如下命令，即可得到检测结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run lint</div></pre></td></tr></table></figure></p>
<p>实践中，通常会将lint集成到测试流程中：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"lint"</span>: <span class="string">"eslint *.js models/**"</span>,</div><div class="line">  <span class="attr">"test"</span>: <span class="string">"npm run lint &amp;&amp; mocha"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="例外规则"><a href="#例外规则" class="headerlink" title="例外规则"></a>例外规则</h2><p>编码过程中出于实际需要，会不可避免地违反lint规则。ESLint提供了例外规则，供开发人员临时地关闭某些检测规则。</p>
<p>屏蔽文件的某个区块：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* eslint-disable no-console */</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello, world"</span>)</div><div class="line"></div><div class="line"><span class="comment">/* eslint-enable */</span></div></pre></td></tr></table></figure></p>
<p>屏蔽一行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* eslint-disable-line no-console */</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"hello, world"</span>)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="number">42</span>) <span class="comment">// eslint-disable-line no-console</span></div></pre></td></tr></table></figure></p>
<p>由于项目中会用到测试框架mocha，测试用例包含的全局变量如describe、it等，会造成lint报错。屏蔽这些错误的方法是，在.eslintrc中添加运行环境mocha，配置如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"env"</span>: &#123;</div><div class="line">    <span class="attr">"node"</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">"mocha"</span>: <span class="literal">true</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果使用了Chai或者Shouldjs，还会产生no-unused-vars的错误，用例外规则屏蔽之：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> should = <span class="built_in">require</span>(<span class="string">'chai'</span>).should() <span class="comment">// eslint-disable-line no-unused-vars</span></div></pre></td></tr></table></figure></p>
<h2 id="Sublime集成"><a href="#Sublime集成" class="headerlink" title="Sublime集成"></a>Sublime集成</h2><p>上面配置好ESLint之后，根据命令行检测出结果，定位到文件中进行相应的修改，然后再检测在修改。这种命令行方式比较繁琐，更好的办法是集成到代码编辑器中，实时地进行检测。</p>
<p>ESLint可以很好地集成到Sublime中，通过Package Control安装SublimeLinter、SublimeLinter-contrib-eslint两个插件，即可完成对ESLint的集成。</p>
<p>要启用ESLint，还需要配置SublimeLinter的nodejs的路径。具体做法是打开Preference &gt; Package Settings &gt; SublimeLinter &gt; Settings - Default文件，在paths下面填写响应平台下的node路径：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">"paths": &#123;</div><div class="line">  "linux": [],</div><div class="line">  "osx": [],</div><div class="line">  "windows": ["D:/Program Files/nodejs/node.exe"]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置好路径后，务必<strong>重启Sublime</strong>，才会使得SublimeLinter生效。</p>
<p>我们在编写代码时，SublimeLinter会读取项目目录下的.eslintrc规则文件，实时动态地标出错误代码的位置。</p>
<p>另外我们可以开启SublimeLinter的debug模式，该模式下将会在状态栏给出错误的说明。启用的方法是打开Tools &gt; SublimeLinter &gt; Debug Mode。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[《Mapbox矢量瓦片标准》深度解析]]></title>
      <url>https://jingsam.github.io/2016/04/16/vector-tiles-spec-in-depth.html</url>
      <content type="html"><![CDATA[<p><a href="/2016/03/04/vector-tile-spec.html">Mapbox矢量瓦片标准</a>至今已发布至2.1版，各版本间只有细微的差别。标准的内容并不长，相信大部分人能够在半小时内读完。标准对矢量瓦片的编码格式做了详细地描述，大部分内容简洁易懂，但是仍然有些细节容易被误解。本文提炼出几点内容，对矢量瓦片标准进行补充说明。</p>
<h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>矢量数据切片为瓦片后，其坐标从地理坐标转换为屏幕坐标，以整数形式存储。整型比浮点型所需的存储空间更小，大大降低了瓦片的传输成本。</p>
<p>我们通常可以将矢量瓦片看作是一种带元数据的图片，因为它和栅格瓦片一样，都是存储的屏幕坐标，但是两者之间在坐标上还是有差别的。</p>
<p>在栅格瓦片中，坐标(0, 0)代表瓦片最左上角的一个像素点；而在矢量瓦片中，坐标(0, 0)代表的是瓦片的左边缘与上边缘的交点。所以，如下图示例，我们可以认为栅格瓦片的坐标是在格网中心，而矢量瓦片的坐标位于格网的交点。</p>
<p><img src="/assets/raster-vector.png" alt="raster-vector"></p>
<p>瓦片的<code>extent</code>并不限定瓦片内的所有坐标必须在<code>extent</code>范围内。由于瓦片buffer的存在，矢量瓦片存储的坐标可以为负值或者大于<code>extent</code>。</p>
<p>另外值得注意的是，瓦片的<code>extent</code>只是指明了瓦片的范围，并不是瓦片的渲染之后的大小。例如一张<code>extent</code>为4096的矢量瓦片，并不意味着最终渲染出来的是一张4096 X 4096大小的图片。渲染出的图片大小并不由<code>extent</code>决定，通常会被渲染为256 X 256或512 X 512大小的图片。假设将一张<code>extent</code>为4096的矢量瓦片渲染为256 X 256大小的图片，那么(0, 0)~(16, 16)坐标范围内的点都将被综合到图片上的(0, 0)像素点。</p>
<h2 id="version字段"><a href="#version字段" class="headerlink" title="version字段"></a><code>version</code>字段</h2><p>矢量瓦片由一组命名的图层构成，每个图层必须包含一个<code>version</code>字段。标准并未规定所有的图层的<code>version</code>字段必须一致，所以我们可以认为矢量瓦片的图层可以包含不同<code>version</code>字段。按照旧版本编码的图层可以添加到新版本的图层中而互不影响，保持了对就版本的兼容性。</p>
<p>虽然理论上图层的<code>version</code>可以不同，实践上还是应该保持所有<code>version</code>字段一致，免得为解析带来不必要的麻烦。</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>矢量瓦片存储的是相对坐标，总是存储相对于上一点在XY方向上的偏移量。游标在数据库中表示当前所指向的行，通过移动游标来遍历所有的记录。矢量瓦片构造点、线、面的过程也可以通过移动游标来模拟。游标可以看做是一只画笔，依次经过各个节点来画出几何要素，矢量瓦片记录就是画笔移动的偏移量。</p>
<p>对于多边形的游标有一点需要注意，即多边形闭合时，游标保持在最后一点，并不折回起点。例如下图，ABCD是一个多边形，游标在到达D点后闭合多边形，并不回到起点A。所以开始构造下一个几何要素时，坐标要相对于D点计算偏移量。之所以这么设计，是因为这样可以少存一个点，以减少瓦片存储大小。</p>
<p><img src="/assets/cursor.png" alt="cursor"></p>
<h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a><code>tag</code></h2><p>矢量瓦片会按图层提取出所有的字段和值的唯一值，然后构建索引序列。对于要素的每个属性用一对<code>tag</code>字段表示。每对<code>tag</code>中，第一个<code>tag</code>表示字段的索引号，第二个表示值的索引号。所以，一个要素的<code>tag</code>字段数目必定为偶数，并且<code>tag</code>字段的值要小于字段和值得唯一值个数。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Nodejs开发工具遇到的坑]]></title>
      <url>https://jingsam.github.io/2016/04/14/traps-with-nodejs.html</url>
      <content type="html"><![CDATA[<p>最近在开发一个在线制图平台，开发语言为Javascript，前端用Vuejs + Material Design Lite做界面，后端用Express做地图服务。</p>
<p>开发主要在Windows上进行。看过我博客的人，应该知道我对Cygwin的爱，因此采用Cygwin作为终端，而不是常用的cmd。Cywin是一个在Windows运行的Unix环境，是典型的身在曹营心在汉。Cygwin的用户还是比较小众的，很多跨平台软件开发时往往是忽视Cygwin的兼容性，造成很多问题。这些问题大部分发生于Cywin中执行Windows命令，例如nodejs不提供Cygwin版本，因此只能调用Windows下安装的Nodejs。大部分npm安装的包都能够在Cygwin中执行，但是有些工具没有考虑到Cygwin的兼容性，导致执行出错。</p>
<p>以下是我在开发中遇到的一些坑，在此记录一下，以后会持续更新：</p>
<p><del>1. nodemon无法在Cygwin下运行，只能在cmd下运行。</del></p>
<ol>
<li>nodemon在windows下运行需要调用cmd.exe, 所以在Cygwin下运行要将<code>/cygdrive/c/Windows/system32</code>添加到PATH环境变量中;</li>
<li>istanbul和mocha集成的时候，在Windows运行的时候命令要写成<code>istanbul cover ./node_modules/mocha/bin/_mocha</code>，直接用<code>istanbul cover _mocha</code>是不行的。</li>
</ol>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Vue组件产生片段实例的几种情况]]></title>
      <url>https://jingsam.github.io/2016/03/15/avoid-fragment-instance.html</url>
      <content type="html"><![CDATA[<p>在Vuejs中，所谓片段实例是指组件的模板包含零个或多个根节点，例如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 零个根节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">I have no root node</div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 多个根节点 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>root node 1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>root node 2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure>
<p>虽然Vue能够处理片段实例，但是会产生种种缺陷，例如组件元素上的非流程控制指令，非prop特性和transition将被忽略，性能也要稍微差一些。因此，除非万不得已，应该尽量避免产生片段实例。</p>
<p>产生片段实例的情况有以下几种：</p>
<ol>
<li>模板包含多个顶级元素。</li>
<li>模板只包含普通文本。</li>
<li>模板只包含其它组件（其它组件可能是一个片段实例）。</li>
<li>模板只包含一个元素指令，如 <partial> 或 vue-router 的 <router-view>。</router-view></partial></li>
<li>模板根节点有一个流程控制指令，如 v-if 或 v-for。</li>
</ol>
<p>情况1、2会产生多个或零个根节点，3、4、5可能会产生多个或零个根节点。即使是可能，Vue在碰到情况3、4、5时也会把组件视为片段实例而发出警告，因此也要尽量避免这3种情况。</p>
<p>避免片段实例的方法很简单，即在构造组件模板时，始终添加一个根元素div，如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  始终添加一个顶级div，避免片段实例</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Mapbox矢量瓦片标准]]></title>
      <url>https://jingsam.github.io/2016/03/04/vector-tile-spec.html</url>
      <content type="html"><![CDATA[<p>以下是<a href="https://github.com/mapbox/vector-tile-spec/tree/master/2.1" target="_blank" rel="external">《Mapbox Vector Tile Specification》</a>最新的2.1版的中文翻译，以便查阅。</p>
<h1 id="矢量瓦片标准"><a href="#矢量瓦片标准" class="headerlink" title="矢量瓦片标准"></a>矢量瓦片标准</h1><p>本文档中的“<strong>必须</strong>”、“<strong>必须不</strong>”、“<strong>必备</strong>”、”<strong>应该</strong>“、“<strong>不应该</strong>”、“<strong>建议</strong>”、“<strong>可以</strong>”、“<strong>可选</strong>”的含义参照<a href="https://www.ietf.org/rfc/rfc2119.txt" target="_blank" rel="external">RFC 2119</a>。</p>
<h2 id="1-目标"><a href="#1-目标" class="headerlink" title="1. 目标"></a>1. 目标</h2><p>本文档规定了一种节省存储空间的矢量瓦片数据编码格式。这种格式应用于客户端或服务端高效渲染或查询要素信息。</p>
<h2 id="2-文件格式"><a href="#2-文件格式" class="headerlink" title="2. 文件格式"></a>2. 文件格式</h2><p>矢量瓦片文件采用<a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">Google Protocol Buffers</a>进行编码。Google Protocol Buffers是一种兼容多语言、多平台、易扩展的数据序列化格式。</p>
<h3 id="2-1-文件后缀"><a href="#2-1-文件后缀" class="headerlink" title="2.1. 文件后缀"></a>2.1. 文件后缀</h3><p>矢量瓦片文件的后缀<strong>应该</strong>为<code>mvt</code>。例如，<code>vector.mvt</code>。</p>
<h3 id="2-2-MIME类型"><a href="#2-2-MIME类型" class="headerlink" title="2.2 MIME类型"></a>2.2 MIME类型</h3><p>矢量瓦片的MIME类型<strong>应该</strong>设置为<code>application/vnd.mapbox-vector-tile</code>。</p>
<h2 id="3-投影和范围"><a href="#3-投影和范围" class="headerlink" title="3. 投影和范围"></a>3. 投影和范围</h2><p>矢量瓦片表示的是投影在正方形区块上的数据。矢量瓦片<strong>不应该</strong>包含范围和投影信息。解码方被假定知道矢量瓦片的范围和投影信息。</p>
<p><a href="https://en.wikipedia.org/wiki/Web_Mercator" target="_blank" rel="external">Web Mercator</a>是默认的投影方式，<a href="http://www.maptiler.org/google-maps-coordinates-tile-bounds-projection/" target="_blank" rel="external">Google tile scheme</a>是默认的瓦片编号方式。两者一起完成了与任意范围、任意精度的地理区域的一一对应，例如<code>https://example.com/17/65535/43602.mvt</code>。</p>
<p>矢量瓦片<strong>可以</strong>用来表示任意投影方式、任意瓦片编号方案的数据。</p>
<h2 id="4-内部结构"><a href="#4-内部结构" class="headerlink" title="4. 内部结构"></a>4. 内部结构</h2><p>这部分内容描述矢量瓦片的数据结构。读者需要先了解<a href="https://github.com/mapbox/vector-tile-spec/blob/master/2.1%2Fvector_tile.proto" target="_blank" rel="external">矢量瓦片protobuf编码方案文件</a>中的结构定义。</p>
<h3 id="4-1-图层"><a href="#4-1-图层" class="headerlink" title="4.1. 图层"></a>4.1. 图层</h3><p>矢量瓦片由一组命名的图层构成。每个图层包含几何要素和元数据信息。设计的图层格式能够保证图层数据能够在内存中按顺序排列，由此在图层组末尾添加一个新的图层就不用更改已有的数据。</p>
<p>每块矢量瓦片<strong>应该</strong>至少包含一个图层。每个图层<strong>应该</strong>至少包含一个要素。</p>
<p>图层<strong>必须</strong>包含一个<code>version</code>字段表示此图层所遵守的《矢量瓦片标准》的主版本号。例如，某个图层遵守2.1版本的标准，那么它的<code>version</code>字段的值则为整数<code>2</code>。<code>version</code>字段<strong>应该</strong>设定为图层的第一个字段。解码器<strong>应该</strong>首先解析<code>version</code>字段，以确定是否能够解析该版本的图层。当遇到一个未知版本的矢量瓦片图层时，解码器<strong>可以</strong>尝试去解析它，或者<strong>可以</strong>跳过该图层。以上两种情况下，解码器都<strong>应该</strong>继续解析后续的图层。</p>
<p>图层<strong>必须</strong>包含一个<code>name</code>字段。每块矢量瓦片<strong>必须不</strong>包含两个或两个以上的图层具有相同<code>name</code>值。在向一块矢量瓦片添加一个新的图层之前，编码器<strong>必须</strong>检查已有的<code>name</code>值以防止重复。</p>
<p>图层中的每个要素<strong>可以</strong>包含一个或多个key-value作为它的元数据（见下文）。所有要素的key和value被分别索引为两个列表——<code>keys</code>和<code>values</code>——为图层中的所有要素所共享。</p>
<p>图层<code>keys</code>字段的每个元素都是字符串。<code>keys</code>字段包含了图层中所有要素的key，并且每个key可以通过它在<code>keys</code>列表中的索引号引用，第一个key的索引号是0 。<code>keys</code>列表<strong>必须不</strong>包含两个或两个以上key是一样的。</p>
<p>图层<code>values</code>字段的每个元素是多种类型的值的编码（见下文）。<code>values</code>字段包含了图层中所有要素的value，并且每个value可以通过它在<code>values</code>列表中的索引号引用，第一个value的索引号是0 。<code>values</code>列表<strong>必须不</strong>包含两个或两个以上value是一样的。</p>
<p>为了支持字符串型、布尔型、整型、浮点型多种类型的值，对<code>value</code>字段的编码包含了一组<code>optional</code>字段。每个value<strong>必须</strong>包含其中的一个字段。</p>
<p>图层<strong>必须</strong>包含一个<code>extent</code>字段，表示瓦片的宽度和高度，以整数表示。矢量瓦片中的几何坐标<strong>可以</strong>超出<code>extent</code>定义的范围。超出<code>extent</code>范围的几何要素被经常用来作为缓冲区，以渲染重叠在多块相邻瓦片上的要素。</p>
<p>例如，如果一块瓦片的<code>extent</code>范围是4096，那么坐标的单位是瓦片长宽的1/4096。坐标0在瓦片的顶部或左边缘，坐标4096在瓦片的底部或右边缘。坐标从1到4095都是在瓦片内部，坐标小于0或者大于4096在瓦片外部。坐标<code>(1,10)</code>或<code>(4095,10)</code>在瓦片内部。坐标<code>(0,10)</code>或<code>(4096,10)</code>在瓦片边缘。坐标<code>(-1,10)</code>或<code>(4097,10)</code>在瓦片外部。</p>
<h3 id="4-2-要素"><a href="#4-2-要素" class="headerlink" title="4.2. 要素"></a>4.2. 要素</h3><p>每个要素<strong>必须</strong>包含一个<code>geometry</code>字段。</p>
<p>每个要素<strong>必须</strong>包含一个<code>type</code>字段，该字段将在几何类型章节描述（4.3.4）。</p>
<p>每个要素<strong>可以</strong>包含一个<code>tags</code>字段。如果存在属于要素级别的元数据，<strong>应该</strong>存储到<code>tags</code>字段中。</p>
<p>每个要素<strong>可以</strong>包含一个<code>id</code>字段。如果一个要素包含一个<code>id</code>字段，那么<code>id</code>字段的值<strong>应该</strong>相对于图层中的其他要素是唯一的。</p>
<h3 id="4-3-几何图形编码"><a href="#4-3-几何图形编码" class="headerlink" title="4.3. 几何图形编码"></a>4.3. 几何图形编码</h3><p>矢量瓦片中的几何数据被定义为屏幕坐标系。瓦片的左上角（显示默认如此）是坐标系的原点。X轴向右为正，Y轴向下为正。几何图形中的坐标<strong>必须</strong>为整数。</p>
<p>几何图形被编码为要素的<code>geometry</code>字段的一个32位无符号型整数序列。每个整数是<code>CommandInteger</code>或者<code>ParameterInteger</code>。解码器解析这些整数序列作为生成几何图形的一系列有序操作。</p>
<p>指令涉及到的位置是相对于“游标”的，即一个可重定义的点。对于要素中的第一条指令，游标在坐标系中的位置是<code>(0,0)</code>。有些指定能够移动游标，因而会影响到接下来执行的指令。</p>
<h4 id="4-3-1-指令数"><a href="#4-3-1-指令数" class="headerlink" title="4.3.1. 指令数"></a>4.3.1. 指令数</h4><p><code>CommandInteger</code>指代所要执行的操作和执行的次数，分别以command ID和command count表示。</p>
<p>command ID以<code>CommandInteger</code>最末尾的3个比特位表示，即从0到7。command count以<code>CommandInteger</code>剩下的29个比特位表示，即<code>0</code>到<code>pow(2, 29) - 1</code>。</p>
<p>command ID、command count、和<code>CommandInteger</code>三者可以通过以下位运算相互转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CommandInteger = (id &amp; <span class="number">0x7</span>) | (count &lt;&lt; <span class="number">3</span>)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id = CommandInteger &amp; <span class="number">0x7</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">count = CommandInteger &gt;&gt; <span class="number">3</span></div></pre></td></tr></table></figure>
<p>每个command ID表示以下指令中的一种：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th style="text-align:center">Id</th>
<th>参数</th>
<th>参数个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>MoveTo</td>
<td style="text-align:center"><code>1</code></td>
<td><code>dX</code>, <code>dY</code></td>
<td>2</td>
</tr>
<tr>
<td>LineTo</td>
<td style="text-align:center"><code>2</code></td>
<td><code>dX</code>, <code>dY</code></td>
<td>2</td>
</tr>
<tr>
<td>ClosePath</td>
<td style="text-align:center"><code>7</code></td>
<td>无参数</td>
<td>0</td>
</tr>
</tbody>
</table>
<h5 id="指令数示例"><a href="#指令数示例" class="headerlink" title="指令数示例"></a>指令数示例</h5><table>
<thead>
<tr>
<th>指令</th>
<th style="text-align:center">ID</th>
<th style="text-align:center">Count</th>
<th style="text-align:center">CommandInteger</th>
<th style="text-align:center">二进制表示<code>[Count][Id]</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>MoveTo</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>9</code></td>
<td style="text-align:center"><code>[00000000 00000000 0000000 00001][001]</code></td>
</tr>
<tr>
<td>MoveTo</td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>120</code></td>
<td style="text-align:center"><code>961</code></td>
<td style="text-align:center"><code>[00000000 00000000 0000011 11000][001]</code></td>
</tr>
<tr>
<td>LineTo</td>
<td style="text-align:center"><code>2</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>10</code></td>
<td style="text-align:center"><code>[00000000 00000000 0000000 00001][010]</code></td>
</tr>
<tr>
<td>LineTo</td>
<td style="text-align:center"><code>2</code></td>
<td style="text-align:center"><code>3</code></td>
<td style="text-align:center"><code>26</code></td>
<td style="text-align:center"><code>[00000000 00000000 0000000 00011][010]</code></td>
</tr>
<tr>
<td>ClosePath</td>
<td style="text-align:center"><code>7</code></td>
<td style="text-align:center"><code>1</code></td>
<td style="text-align:center"><code>15</code></td>
<td style="text-align:center"><code>[00000000 00000000 0000000 00001][111]</code></td>
</tr>
</tbody>
</table>
<h4 id="4-3-2-参数数"><a href="#4-3-2-参数数" class="headerlink" title="4.3.2. 参数数"></a>4.3.2. 参数数</h4><p>指令的所有参数紧跟在<code>ParameterInteger</code>之后。跟在<code>CommandInteger</code>之后的<code>ParameterIntegers</code>个数等于指令所需要参数的个数乘以指令执行的次数。例如，一条指示<code>MoveTo</code>指令执行3次的<code>CommandInteger</code>之后会跟随6个<code>ParameterIntegers</code>。</p>
<p><code>ParameterInteger</code>由<a href="https://developers.google.com/protocol-buffers/docs/encoding#types" target="_blank" rel="external">zigzag</a>方式编码得到，以使小负数和正数都被编码为小整数。将参数值编码为<code>ParameterInteger</code>按以下公式转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ParameterInteger = (value &lt;&lt; <span class="number">1</span>) ^ (value &gt;&gt; <span class="number">31</span>)</div></pre></td></tr></table></figure>
<p>参数值不支持大于<code>pow(2,31) - 1</code>或<code>-1 * (pow(2,31) - 1)</code>的数值。</p>
<p>以下的公式用来将<code>ParameterInteger</code>解码为实际值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value = ((ParameterInteger &gt;&gt; <span class="number">1</span>) ^ (-(ParameterInteger &amp; <span class="number">1</span>)))</div></pre></td></tr></table></figure>
<h4 id="4-3-3-指令类型"><a href="#4-3-3-指令类型" class="headerlink" title="4.3.3. 指令类型"></a>4.3.3. 指令类型</h4><p>以下关于指令的描述中，游标的初始位置定义为坐标<code>(cX, cY)</code>，其中<code>cX</code>指代游标在X轴上的位置，<code>cY</code>指代游标在Y轴上的位置。</p>
<h5 id="4-3-3-1-MoveTo指令"><a href="#4-3-3-1-MoveTo指令" class="headerlink" title="4.3.3.1. MoveTo指令"></a>4.3.3.1. MoveTo指令</h5><p>表示<code>MoveTo</code>指令执行<code>n</code>的<code>ParameterInteger</code><strong>必须</strong>立即接上<code>n</code>对<code>ParameterInteger</code>。对于<code>(dX, dY)</code>参数：</p>
<ol>
<li>定义坐标<code>(pX, pY)</code>，其中<code>pX = cX + dX</code>和<code>pY = cY + dY</code>。<ul>
<li>对于点要素，这个坐标定义了一个新的点要素。</li>
<li>对于线要素，这个坐标定义了一条新的线要素的起点。</li>
<li>对于面要素，这个坐标定义了一个新环的起点。</li>
</ul>
</li>
<li>将游标移至<code>(pX, pY)</code>。</li>
</ol>
<h5 id="4-3-3-1-LineTo指令"><a href="#4-3-3-1-LineTo指令" class="headerlink" title="4.3.3.1. LineTo指令"></a>4.3.3.1. LineTo指令</h5><p>表示<code>LineTo</code>指令执行<code>n</code>的<code>ParameterInteger</code><strong>必须</strong>立即接上<code>n</code>对<code>ParameterInteger</code>。对于<code>(dX, dY)</code>参数：</p>
<ol>
<li>定义一条以游标位置<code>(cX, cY)</code>为起点，<code>(pX, pY)</code>为终点的线段，其中<code>pX = cX + dX</code>和<code>pY = cY + dY</code>。<ul>
<li>对于线要素，这条线段延长了当前线要素。</li>
<li>对于面要素，这条线段延长了当前环。</li>
</ul>
</li>
<li>将游标移至<code>(pX, pY)</code>。</li>
</ol>
<p>对于任意一对<code>(dX, dY)</code>，<code>dX</code>和<code>dY</code><strong>必须不</strong>能同时为<code>0</code>.</p>
<h4 id="4-3-3-3-ClosePath指令"><a href="#4-3-3-3-ClosePath指令" class="headerlink" title="4.3.3.3. ClosePath指令"></a>4.3.3.3. ClosePath指令</h4><p>每条<code>ClosePath</code>指令<strong>必须</strong>只能执行一次并且无附带参数。这条指令通过构造一条以游标<code>(cX, cY)</code>为起点、当前环的起点为终点的线段，闭合面要素的当前环。</p>
<p>这条指定不改变游标的位置。</p>
<h4 id="4-3-4-几何类型"><a href="#4-3-4-几何类型" class="headerlink" title="4.3.4. 几何类型"></a>4.3.4. 几何类型</h4><p>要素<code>geometry</code>字段的<code>type</code>的取值<strong>必须</strong>是<code>GeomType</code>枚举值之一。支持的几何类型如下：</p>
<ul>
<li>UNKNOWN</li>
<li>POINT</li>
<li>LINESTRING</li>
<li>POLYGON</li>
</ul>
<p>不支持<code>GeometryCollection</code>类型。</p>
<h5 id="4-3-4-1-Unknown几何类型"><a href="#4-3-4-1-Unknown几何类型" class="headerlink" title="4.3.4.1. Unknown几何类型"></a>4.3.4.1. Unknown几何类型</h5><p>本标准有意设置一个Unknown几何类型。这种几何类型<strong>可以</strong>用来编码试验性的几何类型。解码器<strong>可以</strong>选择忽略这种几何类型的要素。</p>
<h5 id="4-3-4-2-Point几何类型"><a href="#4-3-4-2-Point几何类型" class="headerlink" title="4.3.4.2. Point几何类型"></a>4.3.4.2. Point几何类型</h5><p><code>POINT</code>几何类型用来表示单点或多点几何。每个点几何的指令序列<strong>必须</strong>包含一个<code>MoveTo</code>指令，并且该指令的command count大于0。</p>
<p>如果<code>POINT</code>几何的<code>MoveTo</code>的command count为1，那么<strong>必须</strong>将其解析为单点；否则<strong>必须</strong>解析为多点，指令后面的每对<code>ParameterInteger</code>表示一个单点。</p>
<h5 id="4-3-4-3-Linestring几何类型"><a href="#4-3-4-3-Linestring几何类型" class="headerlink" title="4.3.4.3. Linestring几何类型"></a>4.3.4.3. Linestring几何类型</h5><p><code>LINESTRING</code>几何类型用来表示单线或多线几何。线几何的指令序列<strong>必须</strong>包含一个或多个下列序列：</p>
<ol>
<li>一个<code>MoveTo</code>指令，其command count为1</li>
<li>一个<code>LineTo</code>指令，其command count大于0</li>
</ol>
<p>如果<code>LINESTRING</code>的指令序列只包含1个<code>MoveTo</code>指令，那么<strong>必须</strong>将其解析为单线；否则，<strong>必须</strong>将其解析为多线，其中的每个<code>MoveTo</code>指令开始构造一条新线几何。</p>
<h5 id="4-3-4-4-Polygon几何类型"><a href="#4-3-4-4-Polygon几何类型" class="headerlink" title="4.3.4.4. Polygon几何类型"></a>4.3.4.4. Polygon几何类型</h5><p><code>POLYGON</code>几何类型表示面或多面几何，每个面有且只有一个外环和零个或多个内环。面几何的指令序列包含一个或多个下列序列：</p>
<ol>
<li>一个<code>ExteriorRing</code></li>
<li>零个或多个<code>InteriorRing</code></li>
</ol>
<p>Each <code>ExteriorRing</code> and <code>InteriorRing</code> MUST consist of the following sequence:<br>每个<code>ExteriorRing</code>和<code>InteriorRing</code>必须包含以下序列：</p>
<ol>
<li>一个<code>MoveTo</code>指令，其command count为1</li>
<li>一个<code>LineTo</code>指令，其command count大于1</li>
<li>一个<code>ClosePath</code>指令</li>
</ol>
<p>一个外环被<strong>定义</strong>为一个线性的环，当应用<a href="https://en.wikipedia.org/wiki/Shoelace_formula" target="_blank" rel="external">surveyor’s formula</a>，以多边形的节点在瓦片坐标系下的坐标计算面积时，其面积为正。在瓦片坐标系下（X向右为正，Y向下为正），外环节点以顺时针旋转。</p>
<p>一个内环被<strong>定义</strong>为一个线性的环，当应用<a href="https://en.wikipedia.org/wiki/Shoelace_formula" target="_blank" rel="external">surveyor’s formula</a>，以多边形的节点在瓦片坐标系下的坐标计算面积时，其面积为负。在瓦片坐标系下（X向右为正，Y向下为正），内环节点以逆时针旋转。</p>
<p>如果<code>POLYGON</code>的指令序列只包含一个外环，那么<strong>必须</strong>将其解析为单面；否则，<strong>必须</strong>解析为多面几何，其中每个外环表示一个新面的开始。如果面几何包换内环，那么<strong>必须</strong>将其编码到所属的外环之后。</p>
<p>线性环<strong>必须</strong>不包含异常点，例如自相交或自相切。在<code>ClosePath</code>之前的坐标<strong>不应该</strong>与线性环的起始点坐标相同，因为会产生零长度的线段。线性环经过surveyor’s formula计算的面积<strong>不应该</strong>为0，因为这意味着环包含有异常点。</p>
<p>面几何<strong>必须不</strong>能有内环相交，并且内环<strong>必须</strong>被包围在内环之中。</p>
<h4 id="4-3-5-几何要素编码示例"><a href="#4-3-5-几何要素编码示例" class="headerlink" title="4.3.5. 几何要素编码示例"></a>4.3.5. 几何要素编码示例</h4><h5 id="4-3-5-1-点要素示例"><a href="#4-3-5-1-点要素示例" class="headerlink" title="4.3.5.1. 点要素示例"></a>4.3.5.1. 点要素示例</h5><p>假设示例点的坐标为：</p>
<ul>
<li>(25, 17)</li>
</ul>
<p>表示它只需要一条指令：</p>
<ul>
<li>MoveTo(+25, +17)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">编码      : [ 9 50 34 ]</div><div class="line">              | |  `&gt; 解码: ((34 &gt;&gt; 1) ^ (-(34 &amp; 1))) = +17</div><div class="line">              | `&gt; 解码: ((50 &gt;&gt; 1) ^ (-(50 &amp; 1))) = +25</div><div class="line">              | ===== 相对地 MoveTo(+25, +17) == 创建点 (25,17)</div><div class="line">              `&gt; [00001 001] = <span class="built_in">command</span> id 1 (MoveTo), <span class="built_in">command</span> count 1</div></pre></td></tr></table></figure>
<h5 id="4-3-5-2-多点要素示例"><a href="#4-3-5-2-多点要素示例" class="headerlink" title="4.3.5.2. 多点要素示例"></a>4.3.5.2. 多点要素示例</h5><p>假设多点要素的坐标为:</p>
<ul>
<li>(5,7)</li>
<li>(3,2)</li>
</ul>
<p>编码需要两条指令：</p>
<ul>
<li>MoveTo(+5,+7)</li>
<li>MoveTo(-2,-5)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">编码      : [ 17 10 14 3 9 ]</div><div class="line">               |  |  | | `&gt; 解码: ((9 &gt;&gt; 1) ^ (-(9 &amp; 1))) = -5</div><div class="line">               |  |  | `&gt; 解码: ((3 &gt;&gt; 1) ^ (-(3 &amp; 1))) = -2</div><div class="line">               |  |  | === 相对地 MoveTo(-2, -5) == 创建点 (3,2)</div><div class="line">               |  |  `&gt; 解码: ((34 &gt;&gt; 1) ^ (-(34 &amp; 1))) = +7</div><div class="line">               |  `&gt; 解码: ((50 &gt;&gt; 1) ^ (-(50 &amp; 1))) = +5</div><div class="line">               | ===== relative MoveTo(+25, +17) == 创建点 (25,17)</div><div class="line">               `&gt; [00010 001] = <span class="built_in">command</span> id 1 (MoveTo), <span class="built_in">command</span> count 2</div></pre></td></tr></table></figure>
<h5 id="4-3-5-3-线要素示例"><a href="#4-3-5-3-线要素示例" class="headerlink" title="4.3.5.3. 线要素示例"></a>4.3.5.3. 线要素示例</h5><p>假设示例线要素的坐标为:</p>
<ul>
<li>(2,2)</li>
<li>(2,10)</li>
<li>(10,10)</li>
</ul>
<p>编码需要3条指令：</p>
<ul>
<li>MoveTo(+2,+2)</li>
<li>LineTo(+0,+8)</li>
<li>LineTo(+8,+0)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">编码      : [ 9 4 4 18 0 16 16 0 ]</div><div class="line">              |      |      ==== 相对地 LineTo(+8, +0) == 连接到点 (10, 10)</div><div class="line">              |      | ==== 相对地 LineTo(+0, +8) == 连接到点 (2, 10)</div><div class="line">              |      `&gt; [00010 010] = <span class="built_in">command</span> id 2 (LineTo), <span class="built_in">command</span> count 2</div><div class="line">              | === 相对地 MoveTo(+2, +2)</div><div class="line">              `&gt; [00001 001] = <span class="built_in">command</span> id 1 (MoveTo), <span class="built_in">command</span> count 1</div></pre></td></tr></table></figure>
<h5 id="4-3-5-4-Example-Multi-Linestring"><a href="#4-3-5-4-Example-Multi-Linestring" class="headerlink" title="4.3.5.4. Example Multi Linestring"></a>4.3.5.4. Example Multi Linestring</h5><h5 id="4-3-5-4-多线要素示例"><a href="#4-3-5-4-多线要素示例" class="headerlink" title="4.3.5.4. 多线要素示例"></a>4.3.5.4. 多线要素示例</h5><p>假设示例要素的坐标为：</p>
<ul>
<li>Line 1:<ul>
<li>(2,2)</li>
<li>(2,10)</li>
<li>(10,10)</li>
</ul>
</li>
<li>Line 2:<ul>
<li>(1,1)</li>
<li>(3,5)</li>
</ul>
</li>
</ul>
<p>编码需要以下指令：</p>
<ul>
<li>MoveTo(+2,+2)</li>
<li>LineTo(+0,+8)</li>
<li>LineTo(+8,+0)</li>
<li>MoveTo(-9,-9)</li>
<li>LineTo(+2,+4)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">编码      : [ 9 4 4 18 0 16 16 0 9 17 17 10 4 8 ]</div><div class="line">              |      |           |        | === 相对地 LineTo(+2, +4) == 连接到点 (3,5)</div><div class="line">              |      |           |        `&gt; [00001 010] = <span class="built_in">command</span> id 2 (LineTo), <span class="built_in">command</span> count 1</div><div class="line">              |      |           | ===== 相对地 MoveTo(-9, -9) == 新建一条线从 (1,1)</div><div class="line">              |      |           `&gt; [00001 001] = <span class="built_in">command</span> id 1 (MoveTo), <span class="built_in">command</span> count 1</div><div class="line">              |      |      ==== 相对地 LineTo(+8, +0) == 连接到点 (10, 10)</div><div class="line">              |      | ==== 相对地 LineTo(+0, +8) == 连接到点 (2, 10)</div><div class="line">              |      `&gt; [00010 010] = <span class="built_in">command</span> id 2 (LineTo), <span class="built_in">command</span> count 2</div><div class="line">              | === 相对地 MoveTo(+2, +2)</div><div class="line">              `&gt; [00001 001] = <span class="built_in">command</span> id 1 (MoveTo), <span class="built_in">command</span> count 1</div></pre></td></tr></table></figure>
<h5 id="4-3-5-5-面要素示例"><a href="#4-3-5-5-面要素示例" class="headerlink" title="4.3.5.5. 面要素示例"></a>4.3.5.5. 面要素示例</h5><p>假设示例面要素的坐标为：</p>
<ul>
<li>(3,6)</li>
<li>(8,12)</li>
<li>(20,34)</li>
<li>(3,6) <em>闭合</em></li>
</ul>
<p>编码需要以下指令：</p>
<ul>
<li>MoveTo(3, 6)</li>
<li>LineTo(5, 6)</li>
<li>LineTo(12, 22)</li>
<li>ClosePath</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">编码      : [ 9 6 12 18 10 12 24 44 15 ]</div><div class="line">              |       |              `&gt; [00001 111] <span class="built_in">command</span> id 7 (ClosePath), <span class="built_in">command</span> count 1</div><div class="line">              |       |       ===== 相对地 LineTo(+12, +22) == 连接到点 (20, 34)</div><div class="line">              |       | ===== 相对地 LineTo(+5, +6) == 连接到点 (8, 12)</div><div class="line">              |       `&gt; [00010 010] = <span class="built_in">command</span> id 2 (LineTo), <span class="built_in">command</span> count 2</div><div class="line">              | ==== 相对地 MoveTo(+3, +6)</div><div class="line">              `&gt; [00001 001] = <span class="built_in">command</span> id 1 (MoveTo), <span class="built_in">command</span> count 1</div></pre></td></tr></table></figure>
<h5 id="4-3-5-6-多面要素示例"><a href="#4-3-5-6-多面要素示例" class="headerlink" title="4.3.5.6. 多面要素示例"></a>4.3.5.6. 多面要素示例</h5><p>示例要素包含两个多边形，其中一个多边形有一个洞。多边形中的点如下。注意，多边形中的点环绕顺序<strong>非常</strong>重要，应为这个顺序被用来区别外环和内环。</p>
<ul>
<li>Polygon 1:<ul>
<li>外环:<ul>
<li>(0,0)</li>
<li>(10,0)</li>
<li>(10,10)</li>
<li>(0,10)</li>
<li>(0,0) <em>闭合</em></li>
</ul>
</li>
</ul>
</li>
<li>Polygon 2:<ul>
<li>外环:<ul>
<li>(11,11)</li>
<li>(20,11)</li>
<li>(20,20)</li>
<li>(11,20)</li>
<li>(11,11) <em>闭合</em></li>
</ul>
</li>
<li>内环:<ul>
<li>(13,13)</li>
<li>(13,17)</li>
<li>(17,17)</li>
<li>(17,13)</li>
<li>(13,13) <em>闭合</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>编码需要以下一系列指令：</p>
<ul>
<li>MoveTo(+0,+0)</li>
<li>LineTo(+10,+0)</li>
<li>LineTo(+0,+10)</li>
<li>LineTo(-10,+0) // 执行这条指令后，游标的位置在(0, 10)</li>
<li>ClosePath // Polygon 1结束</li>
<li>MoveTo(+11,+1) // <strong>这条指令相对于上面最后一条LineTo指令！</strong></li>
<li>LineTo(+9,+0)</li>
<li>LineTo(+0,+9)</li>
<li>LineTo(-9,+0) // 执行这条指令后，游标的位置在（11, 20)</li>
<li>ClosePath // 这是一个新面要素，因为面积为正</li>
<li>MoveTo(+2,-7) // <strong>这条指令相对于上面最后一条LineTo指令！</strong></li>
<li>LineTo(+0,+4)</li>
<li>LineTo(+4,+0)</li>
<li>LineTo(+0,-4) // 执行这条指令后，游标的位置在（17, 13)</li>
<li>ClosePath // 这是一个内环，因为面积为负</li>
</ul>
<h3 id="4-4-要素属性"><a href="#4-4-要素属性" class="headerlink" title="4.4. 要素属性"></a>4.4. 要素属性</h3><p>要素属性被编码为<code>tag</code>字段中的一对对整数。在每对<code>tag</code>中，第一个整数表示key在其所属的<code>layer</code>的<code>keys</code>列表的中索引号（以0开始）。第二个整数表示value在其所属的<code>layer</code>的<code>values</code>列表的中索引号（以0开始）。一个要素的所有key索引<strong>必须唯一</strong>，以保证要素中没有重复的属性项。每个要素的<code>tag</code>字段<strong>必须</strong>为偶数。要素中的<code>tag</code>字段包含的key索引号或value索引号<strong>必须不</strong>能大于或等于相应图层中<code>keys</code>或<code>values</code>列表中的元素数目。</p>
<h3 id="4-5-示例"><a href="#4-5-示例" class="headerlink" title="4.5. 示例"></a>4.5. 示例</h3><p>例如，一个GeoJSON格式的要素如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"type"</span>: <span class="string">"FeatureCollection"</span>,</div><div class="line">    <span class="attr">"features"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"geometry"</span>: &#123;</div><div class="line">                <span class="attr">"type"</span>: <span class="string">"Point"</span>,</div><div class="line">                <span class="attr">"coordinates"</span>: [</div><div class="line">                    <span class="number">-8247861.1000836585</span>,</div><div class="line">                    <span class="number">4970241.327215323</span></div><div class="line">                ]</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"Feature"</span>,</div><div class="line">            <span class="attr">"properties"</span>: &#123;</div><div class="line">                <span class="attr">"hello"</span>: <span class="string">"world"</span>,</div><div class="line">                <span class="attr">"h"</span>: <span class="string">"world"</span>,</div><div class="line">                <span class="attr">"count"</span>: <span class="number">1.23</span></div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"geometry"</span>: &#123;</div><div class="line">                <span class="attr">"type"</span>: <span class="string">"Point"</span>,</div><div class="line">                <span class="attr">"coordinates"</span>: [</div><div class="line">                    <span class="number">-8247861.1000836585</span>,</div><div class="line">                    <span class="number">4970241.327215323</span></div><div class="line">                ]</div><div class="line">            &#125;,</div><div class="line">            <span class="attr">"type"</span>: <span class="string">"Feature"</span>,</div><div class="line">            <span class="attr">"properties"</span>: &#123;</div><div class="line">                <span class="attr">"hello"</span>: <span class="string">"again"</span>,</div><div class="line">                <span class="attr">"count"</span>: <span class="number">2</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会被结构化为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">layers &#123;</div><div class="line">  version: <span class="number">2</span></div><div class="line">  name: <span class="string">"points"</span></div><div class="line">  features: &#123;</div><div class="line">    id: <span class="number">1</span></div><div class="line">    tags: <span class="number">0</span></div><div class="line">    tags: <span class="number">0</span></div><div class="line">    tags: <span class="number">1</span></div><div class="line">    tags: <span class="number">0</span></div><div class="line">    tags: <span class="number">2</span></div><div class="line">    tags: <span class="number">1</span></div><div class="line">    type: Point</div><div class="line">    geometry: <span class="number">9</span></div><div class="line">    geometry: <span class="number">2410</span></div><div class="line">    geometry: <span class="number">3080</span></div><div class="line">  &#125;</div><div class="line">  features &#123;</div><div class="line">    id: <span class="number">1</span></div><div class="line">    tags: <span class="number">0</span></div><div class="line">    tags: <span class="number">2</span></div><div class="line">    tags: <span class="number">2</span></div><div class="line">    tags: <span class="number">3</span></div><div class="line">    type: Point</div><div class="line">    geometry: <span class="number">9</span></div><div class="line">    geometry: <span class="number">2410</span></div><div class="line">    geometry: <span class="number">3080</span></div><div class="line">  &#125;</div><div class="line">  keys: <span class="string">"hello"</span></div><div class="line">  keys: <span class="string">"h"</span></div><div class="line">  keys: <span class="string">"count"</span></div><div class="line">  values: &#123;</div><div class="line">    string_value: <span class="string">"world"</span></div><div class="line">  &#125;</div><div class="line">  values: &#123;</div><div class="line">    double_value: <span class="number">1.23</span></div><div class="line">  &#125;</div><div class="line">  values: &#123;</div><div class="line">    string_value: <span class="string">"again"</span></div><div class="line">  &#125;</div><div class="line">  values: &#123;</div><div class="line">    int_value: <span class="number">2</span></div><div class="line">  &#125;</div><div class="line">  extent: <span class="number">4096</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意几何要素的实际坐标取决于坐标系和瓦片的范围。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[两个学习flexbox的小游戏]]></title>
      <url>https://jingsam.github.io/2016/03/03/flexbox-games.html</url>
      <content type="html"><![CDATA[<p>网页布局的传统方法是使用<code>dispaly</code>、<code>position</code>、<code>float</code>三个属性，实现起来相当麻烦。2009年，W3C提出flexbox布局方案，大大简化了布局的难度。如今，各大浏览器都支持flexbox布局方案，我们可以放心使用。</p>
<p>虽然flexbox降低了网页布局的难度，但是其也有上十种属性，想要完全掌握也不是轻而易举的。</p>
<p>相比于读枯燥的说明文档，通过游戏学习flexbox布局将更有趣、更易理解。本文将介绍两款学习flexbox布局的小游戏。</p>
<h2 id="Flexbox-defense"><a href="#Flexbox-defense" class="headerlink" title="Flexbox defense"></a>Flexbox defense</h2><p><a href="http://www.flexboxdefense.com/" target="_blank" rel="external">Flexbox defense</a>是一款塔防游戏，通过flexbox相关属性调整炮塔的位置，消灭行进中的怪物。游戏总共有10关，完成所有的关卡可以学习<code>justify-content</code>、<code>align-items</code>、<code>flex-direction</code>、<code>order</code>、<code>align-self</code>这5个属性。游戏比较简单，初学者10分钟左右就能通关。</p>
<p><img src="/assets/flexbox-defense.png" alt="flexbox defense"></p>
<h2 id="Flexbox-froggy"><a href="#Flexbox-froggy" class="headerlink" title="Flexbox froggy"></a>Flexbox froggy</h2><p><a href="http://flexboxfroggy.com/#zh-cn" target="_blank" rel="external">Flexbox froggy</a>要求你通过设置flex属性，将青蛙移到相应颜色的荷叶上。游戏总共有24关，难度较前一个游戏高，不仅包括前面已经学习的5个属性，还增加了<code>flex-wrap</code>、<code>flex-flow</code>、<code>align-content</code>3个属性。但是，玩通前一个游戏后再玩这个游戏，也不算难。</p>
<p><img src="/assets/flexbox-froggy.png" alt="flexbox froggy"></p>
<p>第21关的<code>align-content</code>属性容易与<code>align-items</code>相混淆，不易理解。<code>align-items</code>所调整的是元素整体的位置，而<code>align-content</code>调整的是元素整体中所包含的多行子元素间的布局关系。因此，如果元素整体只有1行，<code>align-content</code>属性是无效的。</p>
<h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><p>除了以上提到的8个flexbox属性外，还有<code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>、<code>flex</code>4个属性，详情请参考阮一峰先生的博文：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">Flex 布局教程：语法篇</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="external">Flex 布局教程：实例篇</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Cygwin 安装 PostGIS]]></title>
      <url>https://jingsam.github.io/2016/01/17/installing-postgis-on-cygwin.html</url>
      <content type="html"><![CDATA[<p>PostGIS 是一款基于 PostgreSQL 的插件，提供对空间数据的操作。虽然 PostgreSQL 本身可以存储空间数据，但 PostGIS 扩展可以使用户直接使用 SQL 语句进行空间查询、分析和处理。</p>
<p>Cygwin 的官方源中并没有 PostGIS 的二进制发行包，所以要在 Cygwin 上使用 PostGIS 必须自行编译。</p>
<p>PostGIS 依赖于 GEOS、GDAL、XML2、JSON-C、PROJ、PostgreSQL，其中 GEOS 和 GDAL 需要通过源代码安装，<a href="/2016/01/17/compiling-geos-on-cygwin.html">编译GEOS的方法</a>和<a href="/2016/01/17/compiling-gdal-on-cygwin.html">编译GDAl的方法</a>可以参考往期博文。其他包可通过如下命令安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-cyg install libxml2-devel libjson-c-devel libproj-devel libreadline-devel libpg-devel</div></pre></td></tr></table></figure></p>
<p>安装完依赖之后，到 PostGIS 的<a href="http://postgis.net/source/" target="_blank" rel="external">官网</a>上下载源代码。解压源代码，进入到解压后的目录，使用 Linux 常用的三条命令进行编译安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>我在编译的过程中，出现如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/cygdrive/d/Download/postgis-2.2.1/raster/rt_core/rt_raster.c:1966：对‘strnicmp’未定义的引用</div></pre></td></tr></table></figure></p>
<p>原因是 <code>strnicmp</code> 函数不属于标准库函数，标准库中对应的函数是 <code>strncasecmp</code>。因此，将 rt_raster.c 中的 <code>strnicmp</code> 替换为 <code>strncasecmp</code> 即可。</p>
<p>成功安装 PostGIS 之后，进入需要添加空间扩展的 PostgreSQL 数据库，执行以下命令完成扩展的添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create extension postgis;</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[在 Cygwin 上编译 GDAL]]></title>
      <url>https://jingsam.github.io/2016/01/16/compiling-gdal-on-cygwin.html</url>
      <content type="html"><![CDATA[<p>GDAL (Geospatial Data Abstraction Library) 是最广泛使用的空间数据操作库，包括栅格数据和矢量数据的读写。</p>
<p>Cygwin 的官方源中并没有 GDAL 的二进制发行包，所以要在 Cygwin 上使用 GDAL 必须自行编译。</p>
<p>编译的第一步，需要到 GDAL 的<a href="http://trac.osgeo.org/gdal/wiki/DownloadSource" target="_blank" rel="external">官网</a>上下载源代码。</p>
<p>源代码解压后，进入到解压后的目录，使用 Linux 常用的三条命令进行编译安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>我在编译的过程中，出现如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/home/Sam/download/gdal-2.0.1/frmts/o/.libs/dgif_lib.o: In <span class="keyword">function</span> `DGifOpenFileHandle<span class="string">':</span></div><div class="line"><span class="string">/cygdrive/d/Download/gdal-2.0.1/frmts/gif/giflib/dgif_lib.c:111: undefined reference to `setmode'</span></div><div class="line">/cygdrive/d/Download/gdal-2.0.1/frmts/gif/giflib/dgif_lib.c:111:(.text+0x8e1): relocation truncated to fit: R_X86_64_PC32 against undefined symbol `setmode<span class="string">'</span></div><div class="line"><span class="string">/home/Sam/download/gdal-2.0.1/frmts/o/.libs/egif_lib.o: In function `EGifOpenFileHandle'</span>:</div><div class="line">/cygdrive/d/Download/gdal-2.0.1/frmts/gif/giflib/egif_lib.c:137: undefined reference to `setmode<span class="string">'</span></div><div class="line"><span class="string">/cygdrive/d/Download/gdal-2.0.1/frmts/gif/giflib/egif_lib.c:137:(.text+0x4c7): relocation truncated to fit: R_X86_64_PC32 against undefined symbol `setmode'</span></div></pre></td></tr></table></figure>
<p>查询得知，<code>setmode()</code> 函数并不是标准函数库的一部分，它是一个 BSD 函数。使用 <code>setmode()</code> 函数，需要包含以下头文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;io.h&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>因此解决方案是：找到 dgif_lib.c 和 egif_lib.c，分别在 <code>setmode()</code> 函数前添加头文件 <code>#include &lt;io.h&gt;</code> 。</p>
<p>更新：在 GDAL 2.0.2 中，编译 gdalserver.c 时会报 fd_set 未定义的错误，解决方法是在该文件的46行下面添加 <code>#include &lt;sys/select.h&gt;</code> 。</p>
<p>更新2：使用坐标系转换需要 proj.4 支持，在 cygwin 平台下，GDAL 默认链接到 <code>cygproj-0.dll</code>，可能会出现找不到 proj.4 的错误。这时，在 <code>ogr/ogrct.cpp</code> 中将 98 行的 <code>#  define LIBNAME      &quot;cygproj-0.dll&quot;</code> 改为 <code>#  define LIBNAME      &quot;cygproj-1.dll&quot;</code> 后，重新编译。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[在 Cygwin 上编译 GEOS]]></title>
      <url>https://jingsam.github.io/2016/01/16/compiling-geos-on-cygwin.html</url>
      <content type="html"><![CDATA[<p>GEOS (Geometry Engine - Open Source) 是 Java Topology Suite (JTS) 的 C++ 实现，提供大量的几何操作函数。</p>
<p>Cygwin 的官方源中并没有 GEOS 的二进制发行包，所以要在 Cygwin 上使用 GEOS 必须自行编译。</p>
<p>编译的第一步，需要到 GEOS 的<a href="http://trac.osgeo.org/geos/" target="_blank" rel="external">官网</a>上下载源代码。</p>
<p>源代码解压后，进入到解压后的目录，使用 Linux 常用的三条命令进行编译安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./configure</div><div class="line">make</div><div class="line">make install</div></pre></td></tr></table></figure>
<p>我在编译的过程中，出现如下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">libtool: compile:  g++ -DHAVE_CONFIG_H -I. -I../include -I../include/geos -I../include -DGEOS_CAPI_VERSION=\<span class="string">"3.5.0-CAPI-1.9.0\" -DGEOS_JTS_PORT=\"1.13.0\" -DGEOS_INLINE -pedantic -Wall -ansi -Wno-long-long -ffloat-store -g -O2 -MT libgeos_c_la-geos_ts_c.lo -MD -MP -MF .deps/libgeos_c_la-geos_ts_c.Tpo -c geos_ts_c.cpp  -DDLL_EXPORT -DPIC -o .libs/libgeos_c_la-geos_ts_c.o</span></div><div class="line"><span class="string">geos_ts_c.cpp: 在成员函数‘void GEOSContextHandle_HS::NOTICE_MESSAGE(std::string, ...)’中:</span></div><div class="line"><span class="string">geos_ts_c.cpp:225:81: 错误：‘vsnprintf’在此作用域中尚未声明</span></div><div class="line"><span class="string">       int result = vsnprintf(msgBuffer, sizeof(msgBuffer) - 1, fmt.c_str(), args);</span></div><div class="line"><span class="string">                                                                                 ^</span></div><div class="line"><span class="string">geos_ts_c.cpp: 在成员函数‘void GEOSContextHandle_HS::ERROR_MESSAGE(std::string, ...)’中:</span></div><div class="line"><span class="string">geos_ts_c.cpp:246:81: 错误：‘vsnprintf’在此作用域中尚未声明</span></div><div class="line"><span class="string">       int result = vsnprintf(msgBuffer, sizeof(msgBuffer) - 1, fmt.c_str(), args);</span></div></pre></td></tr></table></figure></p>
<p>错误提示 <code>vsnprintf()</code> 函数未声明，查询得知此函数出现于 C++11 标准。而上面的编译命令中有 <code>-ansi</code>，限定了以 C++98 标准进行编译，所以无法找到 <code>vsnprintf()</code> 函数的声明和定义。</p>
<p>解决方案很简单：进入到源代码目录下的 capi 子目录，找到 Makefile 文件，去掉编译命令中的 <code>-ansi</code> 选项。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Cygwin 安装 Postgresql]]></title>
      <url>https://jingsam.github.io/2016/01/12/installing-postgresql-on-cygwin.html</url>
      <content type="html"><![CDATA[<p>最近开始研究 PostgreSQL, 这篇文章主要讲如何在 Cygwin 上安装和使用 PostgreSQL。</p>
<h3 id="为什么选择-PostgreSQL？"><a href="#为什么选择-PostgreSQL？" class="headerlink" title="为什么选择 PostgreSQL？"></a>为什么选择 PostgreSQL？</h3><p>市面上有各种各样的数据库系统，商业数据库如 Oracle、SQL Server，开源数据库如 SQLite、MySQL、PostgreSQL，为什么从众多的数据库中我选择了 PostgreSQL 呢？</p>
<p>开源且免费是我考虑的首要因素，其次是要支持多用户并发的大型数据库系统，最后数据库要成熟稳定。满足要求的就只有 MySQL 和 PostgreSQL 了， 两者之间的差别可以从它们首页的标题可以一窥大概：</p>
<blockquote>
<p>The world’s most popular open source database.   (MySQL)<br>The world’s most advanced open source database.  (PostgreSQL)</p>
</blockquote>
<p>MySQL 是最流行的数据库系统，说明用的人最多；PostgreSQL 是最先进的数据库系统，说明技术更先进。</p>
<p>MySQL 自从被 Oracle 收购之后，也沾染了些大公司的习气，变得趋于保守。MySQL 社区的一部分成员担心 MySQL 会被大公司主导而偏离了方向，因而 fork 出了一个新的数据库 MariaDB。MariaDB 虽然由社区主导，开发更为激进，但是生态环境远不足 MySQL 丰富。MySQL 的命运与同被 Oracle 收购的 OpenOffice 极其相似，我对它的未来持怀疑态度。 同时，我也感慨 Oracle 公司不要再将魔爪伸向开源社区了，手下留情啊！</p>
<p>PostgreSQL 这边完全是另一番风景，它完全由社区主导，对新技术更为开放。更重要的是，PostgreSQL 对空间数据的支持是最好的，借助 PostGIS 扩展我们可以直接用 SQL 语句进行空间查询。考虑到我后续的工作都会与空间数据有关，所以 PostgreSQL 是我的不二选择。</p>
<h3 id="为什么要在-Cygwin-上安装-PostgreSQL"><a href="#为什么要在-Cygwin-上安装-PostgreSQL" class="headerlink" title="为什么要在 Cygwin 上安装 PostgreSQL?"></a>为什么要在 Cygwin 上安装 PostgreSQL?</h3><p>PostgreSQL 在 Windows 上有原生的安装包，那为什么还要大费周章地在 Cygwin 上安装呢？原因是 Cygwin 提供了与 Linux 一致的开发环境，将来我的程序部署到 Linux 上时更为简单方便。</p>
<p>PostgreSQL 可以直接从 Cygwin 的软件仓库中安装。一种方式是通过 Cygwin 的安装程序安装，另一种方式是通过包管理工具安装。后一种方式需要先安装 apt-cyg，安装的方法可以从我的另一篇博文中找到。安装好 apt-cyg 之后，运行以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-cyg install postgresql</div></pre></td></tr></table></figure></p>
<p>接下来运行 <code>cygserver-config</code>，使 Cygwin 新建一个 Windows 服务。必须注意的是，这条命令必须在管理员权限下运行，因此 Cygwin 命令窗口需以管理员身份打开。然后运行以下命令开启服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cygrunsrv -S cygserver</div></pre></td></tr></table></figure></p>
<h3 id="配置-PostgreSQL"><a href="#配置-PostgreSQL" class="headerlink" title="配置 PostgreSQL"></a>配置 PostgreSQL</h3><p>首次使用 PostgreSQL 数据库，需要运行以下命令完成数据库初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">initdb -D /var/lib/postgresql/data</div></pre></td></tr></table></figure></p>
<p>其中参数 <code>-D</code> 指定数据库文件的存储位置</p>
<p>然后使用 <code>pg_ctl</code> 来开启数据库服务，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pg_ctl start -D /var/lib/postgresql/data -l /var/log/postgresql.log</div></pre></td></tr></table></figure></p>
<p>其中参数<code>-l</code>指定日志文件的位置。</p>
<p>接下来我们就可以新建一个数据库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">createdb mydb</div></pre></td></tr></table></figure></p>
<p>通过以下命令连接到数据库控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">psql mydb</div></pre></td></tr></table></figure></p>
<h3 id="关闭-PostgreSQL-数据库"><a href="#关闭-PostgreSQL-数据库" class="headerlink" title="关闭 PostgreSQL 数据库"></a>关闭 PostgreSQL 数据库</h3><p>当我们使用完数据库之后，不希望数据库服务占用系统资源，因此需要关闭数据相关服务。</p>
<p>同样使用 <code>pg_ctl</code> 来关闭数据库服务，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pg_ctl stop -D /var/lib/postgresql/data</div></pre></td></tr></table></figure></p>
<p>最后终止 cygserver：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cygrunsrv -E cygserver</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以下是本文安装与配置 PostgreSQL 时，所有涉及到的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 安装</div><div class="line">apt-cyg install postgresql</div><div class="line"></div><div class="line">// 初始化 cygserver</div><div class="line">cygserver-config</div><div class="line"></div><div class="line">// 启动 cygserver</div><div class="line">cygrunsrv -S cygserver</div><div class="line"></div><div class="line">// 初始化数据库</div><div class="line">initdb -D /var/lib/postgresql/data</div><div class="line"></div><div class="line">// 开启数据库服务</div><div class="line">pg_ctl start -D /var/lib/postgresql/data -l /var/<span class="built_in">log</span>/postgresql.log</div><div class="line"></div><div class="line">// 新建数据库</div><div class="line">createdb mydb</div><div class="line"></div><div class="line">// 连接数据库</div><div class="line">psql mydb</div><div class="line"></div><div class="line">// 关闭数据库服务</div><div class="line">pg_ctl stop -D /var/lib/postgresql/data</div><div class="line"></div><div class="line">// 终止 cygserver</div><div class="line">cygrunsrv -E cygserver</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 检测生僻字]]></title>
      <url>https://jingsam.github.io/2016/01/09/string-in-python.html</url>
      <content type="html"><![CDATA[<p>最近碰到一个需求，要求检测字段是否包含生僻字以及一些非法字符如 <code>~!@#$%^&amp;*</code>。</p>
<p>首先想到的就是利用 python 的正则表达式来匹配非法字符，然后找出非法记录。然而理想总是丰满的，现实却是残酷的。在实现的过程中，才发现自己对于字符编码、以及 python 内部字符串表示的相关知识的缺乏。在这期间，踩过了不少坑，到最后虽然还有些模糊的地方，但总算有一个总体清晰的了解。在此记录下心得，避免以后在同一个地方跌倒。</p>
<p>以下的测试环境是 ArcGIS 10.3 自带的 python 2.7.8 环境，不保证其他 python 环境也适用。</p>
<h3 id="python-正则表达式"><a href="#python-正则表达式" class="headerlink" title="python 正则表达式"></a>python 正则表达式</h3><p>python 中的正则功能由内嵌的 re 函数库提供，主要用到 3 个函数。<code>re.compile()</code> 提供可重用的正则表达式，<code>match()</code> 和 <code>search()</code> 函数返回匹配结果，两者之间的区别在于： <code>match()</code> 从指定位置开始匹配，<code>search()</code> 会从指定位置向后搜索直到找到匹配字符串。例如下面的代码中，<code>match_result</code> 从第一个字符 f 开始匹配，匹配失败返回空值；<code>search_result</code> 从 f 开始向后搜索，直到找到第一个匹配的字符 a, 然后通过 <code>group()</code> 函数输出匹配结果为字符 a。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">pattern = re.compile(<span class="string">'[abc]'</span>)</div><div class="line">match_result = pattern.match(<span class="string">'fabc'</span>)</div><div class="line"><span class="keyword">if</span> match_result:</div><div class="line">	<span class="keyword">print</span> match_result.group()</div><div class="line"></div><div class="line">search_result = pattern.search(<span class="string">'fabc'</span>)</div><div class="line"><span class="keyword">if</span> search_result:</div><div class="line">	<span class="keyword">print</span> search_result.group()</div></pre></td></tr></table></figure>
<p>以上的实现方式需要先编译一个 pattern，然后再进行匹配。实际上，我们可以直接利用 <code>re.match(pattern, string)</code> 函数来实现相同的功能。但是直接匹配的方式没有先编译再匹配的方式灵活，首先是正则表达式没办法重用，如果大量数据进行同一模式匹配，意味着每次都需要内部编译，造成性能损失；另外，<code>re.match()</code> 函数没有 <code>pattern.match()</code> 功能强大，后者可以指定从哪个位置开始匹配。</p>
<h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>了解 python 正则的基本功能后，剩下的事情就是找到一个合适的正则表达式来匹配生僻字和非法字符。非法字符很简单，采用以下 pattern 就可以实现匹配：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pattern = re.compile(<span class="string">r'[~!@#$%^&amp;* ]'</span>)</div></pre></td></tr></table></figure></p>
<p>然而对于生僻字的匹配，着实难倒了我。首先是对于生僻字的定义，什么样的字算生僻字？经过咨询项目经理，规定非 GB2312 的字符属于生僻字。接下来的问题是，如何匹配 GB2312 字符？</p>
<p>经过查询，GB2312 的范围是 <code>[\xA1-\xF7][\xA1-\xFE]</code>，其中汉字区的范围是 <code>[\xB0-\xF7][\xA1-\xFE]</code>。因此，添加生僻字匹配后的表达式为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pattern = re.compile(<span class="string">r'[~!@#$%^&amp;* ]|[^\xA1-\xF7][^\xA1-\xFE]'</span>)</div></pre></td></tr></table></figure></p>
<p>问题似乎是顺理得当地解决了，然而我还是 too simple too naive 。由于要判断的字符串都是从图层文件读取的，arcpy 贴心地将读取的字符编码为 unicode 格式。因此，我需要找出 GB2312 字符集在 unicode 中的编码范围。但现实是，GB2312 字符集在 unicode 中的分布并不是连续的，使用正则表示这个范围必定是非常复杂的。使用正则表达式匹配生僻字的构想，似乎陷入了死胡同。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>既然提供的字符串是 unicode 格式，那么我可不可以将其转换为 GB2312 再进行匹配呢？实际上是不行，因为 unicode 字符集要远大于 GB2312 字符集，因此 <code>GB2312 =&gt; unicode</code> 总是可以实现的，而反过来 <code>unicode =&gt; GB2312</code> 不一定能成功。</p>
<p>这突然为我提供了另外一种思路，假设一个字符串的 <code>unicode =&gt; GB2312</code> 转换会失败，那么是不是恰恰说明了它不属于 GB2312 字符集？所以，我使用 <code>unicode_string.encode(&#39;GB2312&#39;)</code> 函数尝试转换字符串，捕获 <code>UnicodeEncodeError</code> 异常来识别生僻字。</p>
<p>最终的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_rare_name</span><span class="params">(string)</span>:</span></div><div class="line">	pattern = re.compile(<span class="string">u"[~!@#$%^&amp;* ]"</span>)</div><div class="line">	match = pattern.search(string)</div><div class="line">	<span class="keyword">if</span> match:</div><div class="line">		<span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line">	<span class="keyword">try</span>:</div><div class="line">        string.encode(<span class="string">"gb2312"</span>)</div><div class="line">    <span class="keyword">except</span> UnicodeEncodeError:</div><div class="line">    	<span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[arcpy.Polygon 数据结构]]></title>
      <url>https://jingsam.github.io/2015/12/31/arcpy-polygon.html</url>
      <content type="html"><![CDATA[<p><code>arcpy.Polygon</code> 是描述多边形的几何类，并不像 ArcEngine 中区分 polygon 和 multipolygon，而是采用同一套数据结构描述两类多边形。</p>
<p>在 arcpy 中，一个多边形（polygon）可能包含多个部件（part），而每个部件除了必须包含一个外环（exterior ring），还可能包含几个内环（interior ring），每个环由多个封合的坐标点（point）构成。polygon的层次结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">polygon</div><div class="line">├── part0</div><div class="line">│   ├── ring0</div><div class="line">│   │    ├── point0</div><div class="line">│   │    ├── point1</div><div class="line">│   │    ├── point2</div><div class="line">│   │    ├── ...</div><div class="line">│   ├── ring1</div><div class="line">│   ├── ring2</div><div class="line">│   └── ...</div><div class="line">├── part1</div><div class="line">├── part2</div><div class="line">├── ...</div></pre></td></tr></table></figure></p>
<p>如下图是一个 multipolygon，它包含 3 个部件，其中第一个部件包含一个外环（ring0）和一个内环（ring1）。</p>
<p><img src="/assets/polygon.png" alt="polygon"></p>
<p>在 arcpy 中，每个 polygon 是由多个 part 构成的列表表示，每个 part 直接由一系列坐标串表示。在这里我们可以发现，没有表示 ring 的数据结构。其实 arcpy 会环与环之间添加一个 None 坐标点，在遍历坐标串的过程中，通过 None 结点来判断环的结束。如下如图是包含一个内环的 polygon：</p>
<p><img src="/assets/ring.png" alt="ring"></p>
<p>如果打印这个polygon，我们将会看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[(1, 2), (3, 4), (5, 6), (7, 8), None, (8, 9), (6, 7), (5, 4), (3, 2)]]</div></pre></td></tr></table></figure></p>
<p>我们同时可以发现对于外环，坐标串是按照顺时针排列的；对于内环，按逆时针排列。当我们用梯形求和的方法计算多边形的面积时，采用这种顺序会使得外环的面积为正，内环为负，这样我们就可以直接对环的面积求和，而不用判断是外环还是内环。</p>
<p>当我们打印坐标点（point）的时候，并不会看到是两个坐标的元组，而是 4 个：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Point (<span class="number">1</span>, <span class="number">2</span>, <span class="comment">#, #)</span></div></pre></td></tr></table></figure></p>
<p>实际上，每个 point 包含 （X, Y, Z, M）4 个属性, 在大地坐标系的情况下，其中 X 表示经度，Y 表示纬度，Z 表示高程，M 表示里程。</p>
<p>最后，附上一段求一个多边形的所有的环的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rings</span><span class="params">(polygon)</span>:</span></div><div class="line">    rings = []</div><div class="line">    <span class="keyword">for</span> part <span class="keyword">in</span> polygon:</div><div class="line">        ring = []</div><div class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> part:</div><div class="line">            <span class="keyword">if</span> point:</div><div class="line">                ring.append([point.X, point.Y])</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                rings.append(ring)</div><div class="line">                ring = []</div><div class="line">        <span class="keyword">if</span> ring:</div><div class="line">            rings.append(ring)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> rings</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[正确使用 Multiprocessing 的姿势]]></title>
      <url>https://jingsam.github.io/2015/12/31/multiprocessing.html</url>
      <content type="html"><![CDATA[<p>最近在使用 arcpy 处理一些地理数据，为了提高处理性能，使用 multiprocessing 库进行并行化。在使用 multiprocessing 库的过程中，踩了不少坑，在此记录一下。</p>
<p>multiprocessing 是 python 的多进程并行库，我使用进程池 multiprocessing.pool 来自动管理进程任务。通过一下语句初始化 pool:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">multiprocessing.freeze_support()  <span class="comment"># Windows 平台要加上这句，避免 RuntimeError</span></div><div class="line">pool = multiprocessing.Pool()</div></pre></td></tr></table></figure></p>
<p>假设我们要并行执行的任务是以下函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(pid)</span>:</span></div><div class="line">    <span class="comment"># do something</span></div><div class="line">    <span class="keyword">return</span> result</div></pre></td></tr></table></figure></p>
<p>然后在主函数调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">results = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="number">4</span>):</div><div class="line">    result = pool.apply_async(task, args=(i,))</div><div class="line">    results.append(result)</div></pre></td></tr></table></figure></p>
<p><code>pool.apply_async</code> 采用异步方式调用 task，<code>pool.apply</code> 则是同步方式调用。同步方式意味着下一个 task 需要等待上一个 task 完成后才能开始运行，这显然不是我们想要的功能，所以采用异步方式连续地提交任务。在上面的语句中，我们提交了 4 个任务，假设我的 CPU 是 4 核，那么我的每个核运行一个任务。如果我提交多于 4 个任务，那么每个核就需要同时运行 2 个以上的任务，这回带来任务切换成本，降低了效率。所以我们设置的并行任务数最好等于 CPU 核心数， CPU 核可以通过下面语句得到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cpus = multiprocessing.cpu_count()</div></pre></td></tr></table></figure></p>
<p>接下来我们使用 <code>result.get()</code> 来获取 task 的返回值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">    print(result.get())</div></pre></td></tr></table></figure></p>
<p>在这里不免有人要疑问，为什么不直接在 for 循环中直接 <code>result.get()</code>呢？这是因为<code>pool.apply_async</code>之后的语句都是阻塞执行的，调用 <code>result.get()</code> 会等待上一个任务执行完之后才会分配下一个任务。事实上，<strong>获取返回值的过程最好放在进程池回收之后进行</strong>，避免阻塞后面的语句。</p>
<p>最后我们使用一下语句回收进程池：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pool.close()</div><div class="line">pool.join()</div></pre></td></tr></table></figure></p>
<p>最后附上完整的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(pid)</span>:</span></div><div class="line">    <span class="comment"># do something</span></div><div class="line">    <span class="keyword">return</span> result</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    multiprocessing.freeze_support()</div><div class="line">    pool = multiprocessing.Pool()</div><div class="line">    cpus = multiprocessing.cpu_count()</div><div class="line">    results = []</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, cpus):</div><div class="line">        result = pool.apply_async(task, args=(i,))</div><div class="line">        results.append(result)</div><div class="line"></div><div class="line">    pool.close()</div><div class="line">    pool.join()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">        print(result.get())</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Export PATH 可以用通配符吗？]]></title>
      <url>https://jingsam.github.io/2015/12/16/export-path.html</url>
      <content type="html"><![CDATA[<p>我在 Cygwin 上安装 bundler 之后，使用 bundle 命令提示 command not found。以我的经验来看，估计是 bundle 的路径没有添加到 <code>PATH</code> 环境变量中。查找 bundle 文件发现它存在于 ~/bin 目录下，把这个目录 export 到 PATH 变量中，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=~/bin:$PATH</div></pre></td></tr></table></figure></p>
<p>而后发现 bundle 命令还是不行运行，百思不得解之际，突然想到是不是 <code>PATH</code> 变量中不支持使用 <code>~</code> 这样的通配符？遂改用绝对路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=/home/jingsam/bin:$PATH</div></pre></td></tr></table></figure></p>
<p>问题解决！</p>
<p>至于 <code>PATH</code> 变量到底支不支持通配符，等以后查询到相关信息再来更新。</p>
<p><strong>更新</strong>：PATH 可以引用 <code>$HOME</code> 变量，因此可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export PATH=$HOME/bin:$PATH</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[解决octopress-genesis-theme安装失败的问题]]></title>
      <url>https://jingsam.github.io/2015/12/16/solve-octopress-genesis-theme-self-contradictory-dependencies.html</url>
      <content type="html"><![CDATA[<p>最近在一台新机器上搭建 Octopress 博客时，bundle 安装组件时无限 Resolving dependencies。我的 <code>Gemfile</code> 如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">source <span class="string">'https://ruby.taobao.org/'</span></div><div class="line"></div><div class="line">gem <span class="string">'octopress'</span>, <span class="string">'~&gt; 3.0.0'</span></div><div class="line"></div><div class="line">group <span class="symbol">:jekyll_plugins</span> <span class="keyword">do</span></div><div class="line">  gem <span class="string">'octopress-genesis-theme'</span></div><div class="line">  gem <span class="string">'octopress-codefence'</span></div><div class="line">  gem <span class="string">'octopress-solarized'</span></div><div class="line">  gem <span class="string">'octopress-feeds'</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>通过排除法，最终发现是 octopress-genesis-theme 这个组件出现了问题，从提示信息来看，问题是出在它的有些依赖组件需要 jekyll 2，而我安装的是 jekyll 3。所以解决方法就简单了，直接将 jekyll 的版本锁定到 2，更改后的 <code>Gemfile</code> 如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">source <span class="string">'https://ruby.taobao.org/'</span></div><div class="line"></div><div class="line">gem <span class="string">'octopress'</span>, <span class="string">'~&gt; 3.0.0'</span></div><div class="line">gem <span class="string">'jekyll'</span>, <span class="string">'~&gt; 2.0'</span></div><div class="line"></div><div class="line">group <span class="symbol">:jekyll_plugins</span> <span class="keyword">do</span></div><div class="line">  gem <span class="string">'octopress-genesis-theme'</span></div><div class="line">  gem <span class="string">'octopress-codefence'</span></div><div class="line">  gem <span class="string">'octopress-solarized'</span></div><div class="line">  gem <span class="string">'octopress-feeds'</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>以上的方法只是个简单的 Hack，作为强迫症的我，还是希望其他组件支持最新的 jekyll 3。组件维护者没有更新的情况下，就只能忍忍了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[全世界的公路有多长？基于矢量瓦片的大数据分析]]></title>
      <url>https://jingsam.github.io/2015/12/01/big-data-analysis-with-vector-tiles.html</url>
      <content type="html"><![CDATA[<p>随着地理位置服务（LBS）的兴起，当今地理数据的增长速度远超以往。地理数据的增长不仅表现在数据量的增长，其种类也多种多样，面面俱到。地理大数据以更精细的数据描述整个地球，使我们以更精细地尺度了解整个世界成为了可能。</p>
<p>然而，地理大数据带来了机会也同时带来了挑战。巨量的数据使得传统地理分析方法无能为力，因此要提出与大数据相适应的理计算方法。针对基于单机、基于数据库的传统地理分析方法，一些研究人员探索并行处理的方法。但是这些方法仍然基于传统的数据模型和格式，当数据量增大到一定程度时最终会遇到处理瓶颈。为了处理地理大数据，需要突破传统地理分析方法的思维模式，扩展出新的数据模型和与之相适应的地理计算方法。</p>
<h2 id="矢量瓦片"><a href="#矢量瓦片" class="headerlink" title="矢量瓦片"></a>矢量瓦片</h2><p>矢量瓦片（vector tiles）是一种新颖的数据格式，是将矢量要素按规则格网切割而形成的瓦片数据。矢量瓦片的数据组织方式，非常便于算法分块并行处理。矢量瓦片支持分而冶之的计算方法，使地理计算方法易于从单核到多核、从单机向集群的扩展。总而言之，矢量瓦片简直就是为处理地理大数据而生。</p>
<p>接下来，我将通过统计全世界的公路里程这个示例，向大家展示矢量瓦片的威力。全世界的公路到底有多长？恐怕大多数人心里没底。要解决这个问题有个简单方法——查询统计数据，<a href="https://zh.wikipedia.org/wiki/%E5%90%84%E5%9B%BD%E5%85%AC%E8%B7%AF%E9%87%8C%E7%A8%8B%E5%88%97%E8%A1%A8" target="_blank" rel="external">维基百科</a>上面有世界各国的公路里程。但是，我们不免怀疑统计数据的可信程度，俗话说相信别人比不上相信自己，我们为什么不亲自动手计算下呢？</p>
<p>巧妇难为无米之炊，要统计公路里程首先要有公路的数据。OpenStreetMap（OSM）是一个由全世界志愿者贡献地理数据的网络地图项目，堪称地理数据的维基百科。OSM 公开了全世界地理矢量数据集，任何人都可以免费地下载使用。我下载了全球矢量瓦片（zoom 12）数据集 <a href="http://osmlab.github.io/osm-qa-tiles/" target="_blank" rel="external">OSM-QA-Tiles</a> ，数据集大小有 22 GB。这个数据集里面的矢量数据都是未经过制图综合，所以数据精度是有保障的。</p>
<h2 id="TileReduce"><a href="#TileReduce" class="headerlink" title="TileReduce"></a>TileReduce</h2><p>然后，我要选择一个合适的计算框架来处理如此巨量的数据。<a href="https://github.com/mapbox/tile-reduce" target="_blank" rel="external">TileReduce</a> 是 Mapbox 的一个开源项目，它被设计用来对矢量瓦片做 MapReduce 操作。TileReduce 基于 Javascript 开发，可以借助 Nodejs 运行在各个平台上。运行以下命令，完成开发环境的搭建：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir tile-reduce-test</div><div class="line"><span class="built_in">cd</span> tile-reduce-test</div><div class="line">npm init</div><div class="line">npm install tile-reduce --save</div></pre></td></tr></table></figure></p>
<p>接下来，新建<code>index.js</code>，负责规约操作。其中<code>mbtiles</code>指定了数据的位置，所以记得将它指向你下载的数据的位置。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"></div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> tileReduce = <span class="built_in">require</span>(<span class="string">'tile-reduce'</span>);</div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> total = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> remoteSources = [</div><div class="line">  &#123;</div><div class="line">    name: <span class="string">'osm'</span>,</div><div class="line">    mbtiles: path.join(__dirname, <span class="string">'/latest.planet.z12.mbtiles'</span>),</div><div class="line">    layers: [<span class="string">'osm'</span>]</div><div class="line">  &#125;</div><div class="line">];</div><div class="line"></div><div class="line">tileReduce(&#123;</div><div class="line">    bbox: [<span class="number">-180.0</span>,<span class="number">-85.1</span>,<span class="number">180.0</span>,<span class="number">85.1</span>],</div><div class="line">    zoom: <span class="number">12</span>,</div><div class="line">    map: path.join(__dirname, <span class="string">'/count.js'</span>),</div><div class="line">    sources: remoteSources</div><div class="line">  &#125;)</div><div class="line">  .on(<span class="string">'reduce'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">    total += num;</div><div class="line">  &#125;)</div><div class="line">  .on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'total: %d'</span>, total);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p>新建<code>count.js</code>，负责对每个瓦片进行处理。里面用到了<code>turf</code>来计算道路线段的长度，所以需要<code>npm install turf --save</code>来安装这个库。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// count.js</span></div><div class="line"></div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> turf = <span class="built_in">require</span>(<span class="string">'turf'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">tilelayers, tile, writeData, done</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = <span class="number">0</span>;</div><div class="line">  <span class="keyword">var</span> layer = tilelayers.osm.osm;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> roadTypes = [</div><div class="line">    <span class="string">'motorway'</span>,</div><div class="line">    <span class="string">'trunk'</span>,</div><div class="line">    <span class="string">'primary'</span>,</div><div class="line">    <span class="string">'secondary'</span>,</div><div class="line">    <span class="string">'tertiary'</span>,</div><div class="line">    <span class="string">'unclassified'</span>,</div><div class="line">    <span class="string">'residential'</span>,</div><div class="line">    <span class="string">'road'</span>,</div><div class="line">  ];</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; layer.features.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> feature = layer.features[i];</div><div class="line">    <span class="keyword">if</span> (roadTypes.indexOf(feature.properties.highway) &gt; <span class="number">-1</span>) &#123;</div><div class="line">      length += line_length(feature, <span class="string">'kilometers'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  done(<span class="literal">null</span>, length);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">line_length</span>(<span class="params">feature, units</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> length = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (feature.geometry.type == <span class="string">'LineString'</span>) &#123;</div><div class="line">    length = turf.lineDistance(feature, units);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (feature.geometry.type == <span class="string">'MultiLineString'</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; feature.geometry.coordinates.length; i++) &#123;</div><div class="line">      <span class="keyword">var</span> linestring = turf.linestring(feature.geometry.coordinates[i]);</div><div class="line">      length += turf.lineDistance(linestring, units);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> length;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大功即将告成，运行以下命令开始计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node index.js</div></pre></td></tr></table></figure></p>
<p>我在一台 32 核服务器上运行了 30 min 58 s，处理了 1680 万个矢量瓦片，最终得到了全球公路总里程有 3215 万公里。考虑到这么大的数据量，这个速度比较令人接受的。</p>
<p>查询维基百科上的数据得到的总里程是 6428 万公里，少了近一倍。我觉得有两方面的原因：</p>
<ol>
<li>我计算的道路只包括 OSM 中 Tag 为 <code>motorway, trunk, primary, secondary, tertiary, unclassified, residential, road</code>的公路，实际上还包括其他类型的公路没有统计；</li>
<li>OSM 的数据完善程度在世界各地区不一样，欧洲和美洲比较完善，而中国和非洲的数据密度偏低，所以会造成部分道路未统计到。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然计算结果并不准确，重要的是我们验证了应用矢量瓦片进行地理大数据分析的技术可行性。在本文中只是做了一个简单的公路里程统计，矢量瓦片可以支持更深层次统计分析，这方面还有广泛的研究与应用价值。</p>
<p>注：本文的所用的示例代码可以在<a href="https://github.com/jingsam/tile-reduce-test" target="_blank" rel="external">这里</a>找到。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS 安装 Nodejs]]></title>
      <url>https://jingsam.github.io/2015/12/01/install-nodejs-on-centos.html</url>
      <content type="html"><![CDATA[<p>最近实验室的一台服务器上需要安装 nodejs，记录下折腾的过程。如果没时间看我废话，直接跳到<strong>总结</strong>部分即可找到解决方案。</p>
<h2 id="修复-yum-源"><a href="#修复-yum-源" class="headerlink" title="修复 yum 源"></a>修复 yum 源</h2><p>安装 nodejs，理所当然地认为只要执行下面的命令就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install nodejs</div></pre></td></tr></table></figure></p>
<p>结果提示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Loaded plugins: fastestmirror, refresh-packagekit</div><div class="line">You need to be root to perform this <span class="built_in">command</span>.</div></pre></td></tr></table></figure></p>
<p>这个简单，加上<code>sudo</code>执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum install nodejs</div></pre></td></tr></table></figure></p>
<p>结果还是有错误，仔细一看，发现里面有一条关键提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://mirrors.163.com/centos/%24releasever/os/x86_64/repodata/repomd.xml: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 404 Not Found&quot;</div></pre></td></tr></table></figure></p>
<p><code>%24releasever</code>是个什么鬼？Google 了一下发现是系统版本号变量<code>$releasever</code>。<code>$releasever</code>本应该被替换为 CentOS 的版本号 6.1 的，不知道为什么没有获取到。<code>$releasever</code>变量是从<code>/etc/yum.conf</code>的<code>distroverpkg</code>获取到, 我的<code>distroverpkg=centos-release</code>。改成<code>distroverpkg=redhat-release</code>后，<code>$releasever</code>变为<code>6Server</code>，再执行<code>yum install</code>仍然不行。</p>
<p>看来该换一种思路，分析问题发生的原因，即是<code>repomd.xml</code>文件获取不到。通过到网站上查询，发现这个文件存在于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://mirrors.163.com/centos/6/os/x86_64/repodata/repomd.xml</div></pre></td></tr></table></figure></p>
<p>因此，我就直接更改<code>/etc/yum.repos.d/CentOS6-Base-163.repo</code>文件，将里面的<code>$releasever</code>替换为 6，然后执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo yum clean all</div><div class="line">sudo yum makecache</div></pre></td></tr></table></figure></p>
<p>一切顺利，yum 源修复成功。虽然直接修改<code>$releasever</code>不是很优雅，只要能运行就行，不折腾了。</p>
<h2 id="添加-EPEL-源"><a href="#添加-EPEL-源" class="headerlink" title="添加 EPEL 源"></a>添加 EPEL 源</h2><p>再次尝试<code>sudo yum install nodejs</code>，提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No package node available.</div></pre></td></tr></table></figure></p>
<p>原来 CentOS 的官方源并没有 Nodejs 的安装包，安装需要添加 EPEL 源，执行以下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo rpm -ivh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</div><div class="line">sudo rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6</div></pre></td></tr></table></figure></p>
<p>最后执行以下命令，终于成功安装 Nodejs.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum -y install nodejs npm --enablerepo=epel</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Nodejs 不存在官方的源中，所以安装需要添加 EPEL 源后再安装，完整的命令如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo rpm -ivh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</div><div class="line">sudo rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-6</div><div class="line">sudo yum -y install nodejs npm --enablerepo=epel</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[关于智能家居的碎碎念]]></title>
      <url>https://jingsam.github.io/2015/10/28/all-about-smart-home.html</url>
      <content type="html"><![CDATA[<p>这两年“智能”这个概念很火，各种产品在宣传的时候必冠以智能，如智能电灯、智能电视、智能空调、智能冰箱、智能插座，不一而足。在智能家居领域，如小米等厂商推出了一系列产品，试图改变我们使用传统家电的方式。然而，根据实际体验，我觉得“智能”这个词被滥用了。</p>
<p>智能家居的核心在于让人不操心。真正的智能家居，能够心有灵犀地了解用户的需求，能够将人从重复性家务工作中解放出来。智能家居将人类从低智活动中解放出来，使得人们将精力放在高智活动上。</p>
<p>能用手机APP控制的家电并不能成为智能家电。用手机APP控制家电无非是改变了控制方式，并没有从本质上改变使用家电的方式。遥控器的发明，让人们可以远程地控制电视、空调，但没有人认为有遥控器的家电就是智能家电。用手机APP控制相比于用遥控器控制，事情的复杂度并没有降低。但你费尽心机地去点开APP，在一大堆菜单中寻找你要的功能时，其实你这时候还不如用遥控。APP控制，使复杂度不降反升，人们需要操更多的心了，这就与智能家居的核心相背离了。</p>
<p>真正优秀的智能家居，你应该感觉不到它的存在。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Octopress 3.0博客搭建教程]]></title>
      <url>https://jingsam.github.io/2015/10/21/blogging-with-octopress-3-0.html</url>
      <content type="html"><![CDATA[<p>Octopress是一款专为黑客准备的博客系统，它简洁美观且定制性强。相信大家已经在网上看到过很多Octopress 2.0的博客教程，但本文所要描述的是Octopress 3.0的博客搭建过程。</p>
<p>Octopress 3.0相对于2.0有很大的不同。Octopress 2.0是通过git分发的，需要修改Octopress源代码来构建博客系统，因此难以合并未来的更新。Octopress的作者Mathis认为git并不是一个合适的软件分发方式，因此从3.0开始通过gem方式分发。并且增加了一系列octopress命令，代替之前的rake命令。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>Octopresss基于Jekyll，而jekyll是用Ruby开发的，因此系统要安装有Ruby。新建一个blog文件夹，作为博客的主目录。在主目录下新建文件<code>Gemfile</code>，文件内容如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">source <span class="string">'https://ruby.taobao.org/'</span>  <span class="comment"># 更改为淘宝镜像，下载更稳定</span></div><div class="line"></div><div class="line">gem <span class="string">'octopress'</span>, <span class="string">'~&gt; 3.0.0'</span>        <span class="comment"># 安装Octopress 3.0，依赖包包括jekyll会自动安装</span></div><div class="line"></div><div class="line">group <span class="symbol">:jekyll_plugins</span> <span class="keyword">do</span>           <span class="comment"># 安装插件，具体内容后面再讲</span></div><div class="line">  gem <span class="string">'octopress-genesis-theme'</span>    <span class="comment"># 主题插件</span></div><div class="line">  gem <span class="string">'octopress-codefence'</span>        <span class="comment"># GitHub风格代码块</span></div><div class="line">  gem <span class="string">'octopress-solarized'</span>        <span class="comment"># 代码块高亮采用solarized dark主题</span></div><div class="line">  gem <span class="string">'octopress-feeds'</span>            <span class="comment"># 订阅功能</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p>
<p>更多Octopress插件可在<a href="https://github.com/octopress" target="_blank" rel="external">这里</a>找到。</p>
<p>在主目录下，通过<code>bundle</code>命令安装所有需要gem包。如果提示<code>bundle</code>命令不存在，则需要先安装bundler，命令如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install bundler</div></pre></td></tr></table></figure></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在主目录下，应用如下命令进行初始化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">octopress init .</div></pre></td></tr></table></figure></p>
<p>初始化完成后会在目录下生成<code>_templates</code>文件夹，里面包含draft、page、post三个文件，这些文件是用来作为自定义模板的。其实还有一个<code>octopress new</code>初始化命令，其效果等同于<code>jekyll new</code> + <code>octopress init</code>。不推荐使用这种方式，因为<code>jekyll new</code>产生的文件octopress用不着。</p>
<h2 id="配置yml"><a href="#配置yml" class="headerlink" title="配置yml"></a>配置yml</h2><p>在主目录下，新建<code>_config.yml</code>文件，添加如下配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="attr">title:</span> <span class="string">your</span> <span class="string">blog</span></div><div class="line"><span class="attr">url:</span> <span class="attr">http://your-site.com</span></div><div class="line"></div><div class="line"><span class="attr">date_format:</span> <span class="string">"%Y-%m-%d"</span></div><div class="line"><span class="attr">time_format:</span> <span class="string">"%H:%M"</span></div><div class="line"></div><div class="line"><span class="comment"># Default extension for new posts and pages</span></div><div class="line"><span class="attr">post_ext:</span> <span class="string">md</span></div><div class="line"><span class="attr">page_ext:</span> <span class="string">html</span></div><div class="line"></div><div class="line"><span class="comment"># Default templates for posts and pages</span></div><div class="line"><span class="comment"># Found in _templates/</span></div><div class="line"><span class="attr">post_layout:</span> <span class="attr">theme:post</span></div><div class="line"><span class="attr">page_layout:</span> <span class="attr">theme:page</span></div><div class="line"></div><div class="line"><span class="comment"># Format titles with titlecase?</span></div><div class="line"><span class="attr">titlecase:</span> <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment"># Change default template file (in _templates/)</span></div><div class="line"><span class="attr">post_template:</span> <span class="string">post</span></div><div class="line"><span class="attr">page_template:</span> <span class="string">page</span></div><div class="line"><span class="attr">draft_template:</span> <span class="string">draft</span></div></pre></td></tr></table></figure></p>
<p>octopress-genesis-theme主题插件的配置文件需在_plugins/theme下新建config.yml，我的配置文件内容如下<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Settings for main header</span></div><div class="line"><span class="attr">title:</span> <span class="string">jingsam's</span> <span class="string">blog</span></div><div class="line"><span class="attr">subtitle:</span> <span class="string">A</span> <span class="string">geospatial</span> <span class="string">hacker</span></div><div class="line"></div><div class="line"><span class="comment"># Links for main navigation</span></div><div class="line"><span class="attr">nav:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">&#123;</span> <span class="attr">url:</span> <span class="string">'/'</span><span class="string">,</span> <span class="attr">title:</span> <span class="string">'Post'</span> <span class="string">&#125;</span></div><div class="line"><span class="bullet">  -</span> <span class="string">&#123;</span> <span class="attr">url:</span> <span class="string">'/archive/'</span><span class="string">,</span> <span class="attr">title:</span> <span class="string">'Archive'</span> <span class="string">&#125;</span></div><div class="line"><span class="bullet">  -</span> <span class="string">&#123;</span> <span class="attr">url:</span> <span class="string">'/feed/'</span><span class="string">,</span> <span class="attr">title:</span> <span class="string">'Subscribe'</span> <span class="string">&#125;</span></div><div class="line"></div><div class="line"><span class="comment"># Link labels</span></div><div class="line"><span class="attr">permalink_label:</span> <span class="string">"Permalink"</span></div><div class="line"><span class="attr">read_more_label:</span> <span class="string">"Continue Reading →"</span></div><div class="line"></div><div class="line"><span class="comment"># Show excerpts on post index</span></div><div class="line"><span class="attr">excerpt_posts:</span> <span class="literal">true</span></div><div class="line"><span class="comment"># Excerpt linkposts on index</span></div><div class="line"><span class="attr">excerpt_linkposts:</span> <span class="literal">false</span></div><div class="line"></div><div class="line"><span class="attr">search:</span> <span class="string">google</span></div><div class="line"></div><div class="line"><span class="attr">sharing:</span></div><div class="line"><span class="bullet">  -</span> <span class="string">facebook</span></div><div class="line"><span class="bullet">  -</span> <span class="string">twitter</span></div><div class="line"><span class="bullet">  -</span> <span class="string">gplus</span></div><div class="line"><span class="bullet">  -</span> <span class="string">email</span></div><div class="line"></div><div class="line"><span class="comment"># Defaults to sharing with links (for speed and privacy)</span></div><div class="line"><span class="comment"># To use javascript share buttons, set share_with: buttons</span></div><div class="line"><span class="attr">share_with:</span> <span class="string">links</span></div><div class="line"></div><div class="line"><span class="comment"># Embed comments, options: false, facebook, disqus</span></div><div class="line"><span class="attr">comments:</span> <span class="string">disqus</span></div><div class="line"></div><div class="line"><span class="comment"># Center the text in post and page headings.</span></div><div class="line"><span class="attr">center_headings:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<h2 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h2><p>写作新的博文使用如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">octopress new post <span class="string">"my title"</span></div></pre></td></tr></table></figure></p>
<p>如果从以前的博客系统迁移过来，只需将所有的markdown格式的文章放到<code>_posts</code>目录下。</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>Octopress支持rsync、s3、git方式发布。以发布到GitHub上为例，首先初始化deploy参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">octopress deploy init git git@github.com:user/project</div></pre></td></tr></table></figure></p>
<p>以上命令将会生成一个<code>_deploy.yml</code>文件，填写相应的参数后完成配置。需注意的是如果<code>_deploy.yml</code>包含密码信息，请在<code>.gitignore</code>中设置忽略，避免密码泄露。另外，我们需要建立两个分支，<code>master</code>分支用来发布网页，<code>source</code>分支用来管理源代码，切不可直接deploy到<code>source</code>分支上破坏了源代码。如果发布分支和源代码分支是同一分支，deploy时Octopress会出现警告。</p>
<p>最后使用如下命令完成发布：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">octopress deploy</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本教程介绍了Octopress 3.0博客搭建流程。Octopress 3.0相对于2.0几乎是重新设计，所做的修改不会污染到源代码，因此更安全地升级。然而Octopress 3.0的文档还不是很完善，需要长时间地摸索，用户可通过如下命令查看octopress及其插件的文档：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">octopress docs</div></pre></td></tr></table></figure></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[简约至上]]></title>
      <url>https://jingsam.github.io/2015/08/12/simpe-and-usable.html</url>
      <content type="html"><![CDATA[<p>趁着多看限免，花了一个小时读完了《简约至上》，本书以设计一个简单易用的DVD遥控器为例，向我们展示了简约设计的四大原则：删除不必要的、组织要提供的、隐藏非核心的、以及转移到正确的平台。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除不必要的功能往往是在对软件进行简化时首先想到的手段，甚至有些人会认为这是唯一的手段。删除不必要的功能，说起来容易做起来很难。不同的用户对功能的重要性排序是不一样的，某种功能对一类用户很重要，对另一类用户可能就显得多余。这就需要我们在设计前要充分了解用户的需求，包括用户使用的环境、用户的角色、使用的情景。软件开发毕竟是在有限的资源下满足更多人的需求，因此要倾听占大多数的主流用户的需求。至于专家型用户和随意型用户，他们总是想要你造出会飞的汽车，现实是没多少人会买会飞的汽车。</p>
<h2 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h2><p>将功能进行合理地分类和组织，也是进行简化设计的有效手段之一。然而如何进行分类也是一项很难的工作。我们在设定类别时不要从实现的角度，而是要从用户的视角着手，避免使用一些晦涩的术语，要使用用户熟悉的词汇。例如，有些汽车经销商的页面上会出现整车、配件、装饰的分类，如果用户想换一个漂亮的轮毂，是该从配件还是从装饰中寻找？为什么不按照车轮、座椅、后视镜等用户耳熟能详的词汇呢？有些功能从属的类别模棱两可，用户从他所认知的类别中没有找到想要的功能会显得很沮丧，所以将这种功能重复出现于多个类别中是有必要的。</p>
<h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>隐藏是最被滥用的手段。有些不必要的功能，开发人员花了精力去实现，删除觉得对不起自己的心血，因此往往选择把这些功能隐藏起来。务必<strong>欲删，从速！</strong>隐藏的功能应该是非核心的又是必不可少的。隐藏的功能会使其使用路径变长，对于主流用户可能永远都不会去使用。最常用的隐藏方法是软件中的“选项”，“选项”里应该有默认值，即使用户不去碰它，软件也应该完美地运行。</p>
<h2 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h2><p>将部分功能向合适的平台转移，有助于提升软件的使用体验。例如在手机上看地图，由于屏幕很小，看起来就很费劲，然而转移到桌面平台上，体验就好得多。功能转移的平台，应该是可信任的和可获取的。比如某项功能需要到很专业的设备上使用才能达到完美的效果，然而专业的设备对大多数人是不可获取的，因此我们需要进行重新设计，使得该功能在一般设备上也能获得较好的体验。</p>
<p>除了上面的四项原则，本书还提到在设计软件时，要照顾用户的感受。不要用给用户很多限制，不要用命令的口气，不要让用户感到受挫。软件的本源是工具，要让用户充当指挥者的角色，指挥软件完成任务。让用户觉得一切尽在掌握，即使这种感觉仅仅是假象而已。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Netlogo读写GIS数据的方法]]></title>
      <url>https://jingsam.github.io/2015/08/03/how-to-load-gis-data-in-netlogo.html</url>
      <content type="html"><![CDATA[<p>使用NetLogo进行地理过程模拟时，不可避免地要对GIS数据进行读写，本文主要讲栅格数据的读写，矢量数据留待以后再讲。</p>
<p>Netlogo目前只支持ESRI ASCII Grid(后缀通常为.asc或.grd)格式的栅格数据，所以其他格式的数据请先使用ArcGIS里面的“Raster to ASCII”工具进行转换。</p>
<p>NetLogo读写GIS数据需要gis扩展支持，因此需要代码页前部声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extensions [gis]</div></pre></td></tr></table></figure></p>
<p>读取数据前，首先需要设置坐标系，但并不是必须的。NetLogo支持地理坐标系和投影坐标系，以WKT格式描述坐标系，需提供坐标系文件(后缀通常为.prj)，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gis:load-coordinate-system &quot;Transverse_Mercator.prj&quot;</div></pre></td></tr></table></figure></p>
<p>对于投影坐标系，NetLogo目前只支持有限的几种坐标系：</p>
<p>|Albers_Conic_Equal_Area      |Lambert_Conformal_Conic_2SP |Polyconic          |<br>|Lambert_Azimuthal_Equal_Area |Mercator_1SP                |Robinson           |<br>|Azimuthal_Equidistant        |Miller                      |Stereographic      |<br>|Cylindrical_Equal_Area       |Oblique_Mercator            |Transverse_Mercator|<br>|Equidistant_Conic            |hotine_oblique_mercator<br>|Gnomonic                     |Orthographic</p>
<p>设置完坐标系后，即可利用函数<code>gis:load-dataset</code>读取数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let data gis:load-dataset dem.asc</div></pre></td></tr></table></figure></p>
<p>将数据读取至变量<code>data</code>之后，一般还需要将数据写入瓦片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gis:set-world-envelope (gis:envelope-of data)</div><div class="line">gis:apply-raster data patch-own-variable</div></pre></td></tr></table></figure></p>
<p>目前NetLogo仅仅支持栅格数据的保存，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gis:store-dataset data mydata.asc</div></pre></td></tr></table></figure></p>
<p>最后附上完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">extensions [gis]      ;读写GIS数据需要用到gis扩展</div><div class="line"></div><div class="line">patches-own [patch-own-variable]</div><div class="line"></div><div class="line">;读取</div><div class="line">to import-data [file]</div><div class="line">  gis:load-coordinate-system (word projection &quot;.prj&quot;)    ;设置坐标系（非必须）</div><div class="line">  let data gis:load-dataset file</div><div class="line"></div><div class="line">  gis:set-world-envelope (gis:envelope-of data)          ;将窗口范围设置为数据框范围</div><div class="line">  gis:apply-raster data patch-own-variable               ;将数据读取至patch-own-variable变量</div><div class="line">end</div><div class="line"></div><div class="line">;保存</div><div class="line">to save-data [data file]</div><div class="line">  gis:store-dataset data file</div><div class="line">end</div></pre></td></tr></table></figure>
]]></content>
      
        
    </entry>
    
  
  
</search>
